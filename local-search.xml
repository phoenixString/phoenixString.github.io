<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaSE-从入门到入秃</title>
    <link href="/2021/02/21/JavaSE-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A7%83/"/>
    <url>/2021/02/21/JavaSE-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A7%83/</url>
    
    <content type="html"><![CDATA[<p>JavaSE知识:面向对象,封装,继承,多态,抽象类和接口,匿名内部类,lambda表达式,泛型,包装类,异常处理机制,Collection,Map,反射,多线程,锁,IO流,NIO,函数式接口,JVM…</p><a id="more"></a><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="JavaSE-从入门到入秃"><a href="#JavaSE-从入门到入秃" class="headerlink" title="JavaSE-从入门到入秃"></a>JavaSE-从入门到入秃</h1><h2 id="Charpter1-Introduction"><a href="#Charpter1-Introduction" class="headerlink" title="Charpter1.Introduction"></a>Charpter1.Introduction</h2><h3 id="1-1-Java具有可移植性"><a href="#1-1-Java具有可移植性" class="headerlink" title="1.1 Java具有可移植性"></a>1.1 Java具有可移植性</h3><p>Java的数据类型具有固定的大小,同时二进制数据以固定的格式进行存储和传输。</p><p>而C/C++中,int 可能是 16 位整数、 32 位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。</p><h3 id="1-2-常见Java术语"><a href="#1-2-常见Java术语" class="headerlink" title="1.2 常见Java术语"></a>1.2 常见Java术语</h3><p><img src="https://s3.ax1x.com/2021/01/26/sX21XD.png" alt="常见Java术语" title="常见Java术语"></p><h3 id="1-3-Java的一些规范"><a href="#1-3-Java的一些规范" class="headerlink" title="1.3 Java的一些规范"></a>1.3 Java的一些规范</h3><p>Java区分大小写;</p><p>Java变量/类的命名应遵循驼峰命名法;具体参见孤尽老师的《<em>阿里巴巴Java开发手册</em>》</p><p>源代码的文件名必须与公共类的名字相同;</p><p>一般不在一行中声明多个变量，逐一声明变量可以提高程序的可读性;</p><h3 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h3><p>类注释：以/** 为开始 */为结束</p><p>行注释：//或者/* */</p><p>方法注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*@param:变量描述</span><br><span class="hljs-comment">*@return:描述</span><br><span class="hljs-comment">*@throws:类描述</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h3><p>Java是强类型语言,变量必须声明类型;(JavaScript是弱类型语言,直接用var声明变量,同时具有弱类型语言的===判断全等)</p><p>基本类型:int short long byte(无c++中的long long) float double char boolean</p><p>(String不是基本类型,String是封装好的类,所以S大写!)</p><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="(1)整型"></a>(1)整型</h4><p>长整型数值有L或l后缀;</p><p>十六进制ox前缀,八进制o前缀,二进制0b前缀;</p><p>Java中没有无符号整型unsigned;</p><h4 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="(2)浮点类型"></a>(2)浮点类型</h4><p>float类型有后缀f或者F,没有后缀的默认都为double类型;</p><ul><li><p>特殊的浮点类型:正无穷大,负无穷大,NaN(不是一个数字，一般是0/0或者负数的平方根会出现结果为NaN)</p></li><li><p>Java中认为所有的非数值都是不相同的,判断是不是NaN可以使用Double.isNaN方法</p></li><li><p>浮点误差的来源是浮点数值采用二进制系统表示,在二进制系统中无法精确的表示小数,如果需要精确计算需要使用BigDecimal类.</p></li></ul><h4 id="3-char类型"><a href="#3-char类型" class="headerlink" title="(3)char类型"></a>(3)char类型</h4><p>char类型的字面量值需要用单引号括起来（eg:’A’;</p><p>char类型的值可以表示为十六进制值，范围从\u0000到\Uffff;</p><p>还有一些特殊的转义序列，类似于c语言;</p><p>程序中一般不使用char类型，除非确实要使用UTF-16代码单元;</p><h4 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="(4)boolean类型"></a>(4)boolean类型</h4><ul><li><p>整型值和boolean类型值不能相互转换（而C++中可以</p><p>eg：我们熟悉的 if（x) 在c++中值0代替false，非0代替true，但是在Java中就不能通过编译;</p></li></ul><h3 id="1-6-变量"><a href="#1-6-变量" class="headerlink" title="1.6 变量"></a>1.6 变量</h3><p>声明变量后必须用赋值语句进行显式初始化，使用未初始化的变量会报错；</p><p>Java可以把声明放在代码中的任何地方;(交给JVM去找)</p><ul><li>在Java中，使用关键词final指示常量，而在c++中使用const或者#define;</li><li>可以使用static final设置一个类常量;</li></ul><h3 id="1-7-运算符"><a href="#1-7-运算符" class="headerlink" title="1.7 运算符"></a>1.7 运算符</h3><h4 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="(1)数学函数与常量"></a>(1)数学函数与常量</h4><p>在Math类中包含各种各样的数学函数,可以调用一些方法,eg:Math.sqrt(x);</p><ul><li><p>floorMod方法：确保余数≥0;</p></li><li><p>可以不用在每个方法前加Math. ，在源文件顶部加 import static java.lang.Math.*; 即可，静态导入;</p></li></ul><h4 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="(2)强制类型转换"></a>(2)强制类型转换</h4><p>在()中给出想要转换的目标类型;</p><h4 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="(3)运算符重载"></a>(3)运算符重载</h4><p>Java中不支持运算符重载,而C++可以;</p><p>唯一例外是String类里面的=和+,而这是JVM的问题,程序员本身无法实现运算符重载;</p><h3 id="1-8-字符串：String类"><a href="#1-8-字符串：String类" class="headerlink" title="1.8 字符串：String类"></a>1.8 字符串：String类</h3><h4 id="1-拼接"><a href="#1-拼接" class="headerlink" title="(1)拼接"></a>(1)拼接</h4><p>Java允许使用+号拼接两个字符串(JVM的操作);</p><p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串;</p><p>这种特性一般在print语句中,eg:System.out.println(“The answer is “ + answer);</p><h4 id="2-不可变字符串"><a href="#2-不可变字符串" class="headerlink" title="(2)不可变字符串"></a>(2)不可变字符串</h4><p>String类没有提供用于修改字符串的方法;</p><p><a href="https://blog.csdn.net/eydwyz/article/details/88861417">为什么String类字符串在Java中是不可修改的</a></p><h4 id="3-String类类似于char-指针"><a href="#3-String类类似于char-指针" class="headerlink" title="(3)String类类似于char*指针"></a>(3)String类类似于char*指针</h4><p>String类并非字符型数组(c++中是)</p><h4 id="4-检测字符串是否相等"><a href="#4-检测字符串是否相等" class="headerlink" title="(4)检测字符串是否相等"></a>(4)检测字符串是否相等</h4><ul><li><p>使用equals方法检测是否相等，不区分大小写可以使用equalsIgnoreCase方法;</p></li><li><p>一定不要使用==运算符检测两个字符串相等,==只是确定两个字符串是否放在同一个内存区域上。在C++中可以，因为C++可以重载运算符;</p></li><li><p>equals方法是Object超类定义的boolean类型方法;</p></li></ul><h4 id="5-空串与NULL串"><a href="#5-空串与NULL串" class="headerlink" title="(5)空串与NULL串"></a>(5)空串与NULL串</h4><p>空串””是长度为0的字符串，可以使用length检测;</p><p>null是特殊的值，检测使用str==null检测;</p><h4 id="6-StringBuilder-StringBuffer类"><a href="#6-StringBuilder-StringBuffer类" class="headerlink" title="(6)StringBuilder,StringBuffer类"></a>(6)StringBuilder,StringBuffer类</h4><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303">String,StringBuffer,StringBuilder类的区别</a></p><h3 id="1-9-输入输出"><a href="#1-9-输入输出" class="headerlink" title="1.9 输入输出"></a>1.9 输入输出</h3><h4 id="1-输入"><a href="#1-输入" class="headerlink" title="(1)输入"></a>(1)输入</h4><p>首先构造个Scanner对象,并与标准输入流System.in关联:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure><p>现在可以使用Scanner类的各种方法实现输入操作;</p><p>eg:nextLine方法可以输入一行,next方法可以输入一个单词;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String name = in.nextLine();<br>String firstName = in.next();<br></code></pre></td></tr></table></figure><p>Scanner类定义在java.util包中,需要加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure><ul><li>读取密码使用Console类对象</li></ul><h4 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="(2)格式化输出"></a>(2)格式化输出</h4><p>类似于c语言的printf方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.printf(<span class="hljs-string">&quot;%8.2f&quot;</span>,x);<br></code></pre></td></tr></table></figure><h4 id="3-文件输入输出"><a href="#3-文件输入输出" class="headerlink" title="(3)文件输入输出"></a>(3)文件输入输出</h4><p>读取:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner (Paths.get(<span class="hljs-string">&quot;Myfile.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>写入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;Myfile.txt&quot;</span>,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-10-大数值"><a href="#1-10-大数值" class="headerlink" title="1.10 大数值"></a>1.10 大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimal。</p><p>这两个类可以处理包含任意长度数字序列的数值。 </p><p>Biglnteger 类实现了任意精度的整数运算, BigDecimal 实现了任意精度的浮点数运算。</p><ul><li><p>使用静态的valueOf方法可以将普通的数值转化为大数值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li><li><p>Java不能重载运算符,需要使用add和multiply方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger c = a.add(b);<span class="hljs-comment">//c=a+b;</span><br>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>)));<span class="hljs-comment">//d=c*(b+2);</span><br></code></pre></td></tr></table></figure></li><li><p>加add减subtract乘multiply除divide余mod相等compareTo方法</p></li></ul><h3 id="1-11-数组"><a href="#1-11-数组" class="headerlink" title="1.11 数组"></a>1.11 数组</h3><h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="(1)创建数组"></a>(1)创建数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><ul><li>创建一个数字数组，所有数据初始化为0，boolean类型初始化为false，对象数组类型初始化为NULL;</li></ul><h4 id="2-for-each-循环"><a href="#2-for-each-循环" class="headerlink" title="(2)for each 循环"></a>(2)for each 循环</h4><p>可以用来依次处理数组中的每个元素，无需care下标值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(variable : collection) statement<br>    <span class="hljs-comment">//先声明与数组类型相同的变量用于后续遍历</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element ： a) <br>    System.out.println(element);<br><span class="hljs-comment">//打印a数组中的所有元素并换行</span><br></code></pre></td></tr></table></figure><h3 id="1-12-可变参数"><a href="#1-12-可变参数" class="headerlink" title="1.12 可变参数"></a>1.12 可变参数</h3><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：(本质是通过可变数组传递)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(addToSum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        System.out.println(addToSum(<span class="hljs-number">21</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... Arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : Arr) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br>输出结果:<br><span class="hljs-number">9</span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><hr><h2 id="Charpter2-Object-with-Class"><a href="#Charpter2-Object-with-Class" class="headerlink" title="Charpter2.Object with Class"></a>Charpter2.Object with Class</h2><h3 id="2-1-面向过程和面向对象"><a href="#2-1-面向过程和面向对象" class="headerlink" title="2.1 面向过程和面向对象"></a>2.1 面向过程和面向对象</h3><ul><li>C语言为面向过程语言,强调Algorithm+Data Structures =Programs,算法第一位,数据结构第二位.</li><li>Java为面向对象语言,作为OOP语言,将数据放在第一位,然后再考虑操作数据的算法.OOP适用于解决规模较大的问题.</li></ul><h3 id="2-2-Class"><a href="#2-2-Class" class="headerlink" title="2.2 Class"></a>2.2 Class</h3><h4 id="1-对象变量"><a href="#1-对象变量" class="headerlink" title="(1)对象变量"></a>(1)对象变量</h4><ul><li>一个对象变量并没有实际包含一个对象，而是仅仅引用一个对象。</li></ul><h4 id="2-按值调用"><a href="#2-按值调用" class="headerlink" title="(2)按值调用"></a>(2)按值调用</h4><ul><li>在Java中总是按值传递;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> price=<span class="hljs-number">300</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raisePrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>&#123;<br>    tmp+=<span class="hljs-number">200</span>;<br>&#125;<br>raisePrice(price);<br><span class="hljs-comment">//最终发现price值并没有改变，因为在Java中形参是按值传递</span><br></code></pre></td></tr></table></figure><ul><li>关于对象作为引用参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(Employee s)</span></span>&#123;<br>    s.salary+=<span class="hljs-number">500</span>;<span class="hljs-comment">//这里为了清晰没有使用封装后的setter;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里,形参为对象,传递时先拷贝其内容再引用,本质还是按值传递.</p><p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Q1K.png" alt="图解"></p><ul><li>“按值传递”的一个经典案例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Employee e1,Employee e2)</span></span>&#123;<br>    Employee tmp = e1;<br>    e1 = e2;<br>    e2 = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似可以实现e1与e2引用对象的交换，实际失败了;</p><p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Mp6.png" alt="图解"></p><p>原因:实际上交换的是两个拷贝，并没有交换e1，e2引用对象的本身。</p><ul><li>更准确的define值调用和引用调用:</li><li>值调用:在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参锁存储的内容是实参存储内容的一份拷贝。</li><li>引用调用:在参数传递的过程中，形参和实参完全是同一块内存空间。</li></ul><h3 id="2-3-封装"><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h3><h4 id="1-Concept"><a href="#1-Concept" class="headerlink" title="(1)Concept"></a>(1)Concept</h4><p>将类的某些信息隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作;</p><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="(2)实现"></a>(2)实现</h4><p>getter()&amp;setter()方法</p><p>在IDEA中 Alt+Insert ,可以直接设置</p><p>也可使用Lombok的jar包 @Getter @Setter</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;输入的年龄非法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-静态域和静态方法"><a href="#2-4-静态域和静态方法" class="headerlink" title="2.4 静态域和静态方法"></a>2.4 静态域和静态方法</h3><h4 id="1-静态域"><a href="#1-静态域" class="headerlink" title="(1)静态域"></a>(1)静态域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">()</span></span>&#123;<br>        id=nextId;<br>        nextId++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//nextId属于静态域，即使该类没有对象仍存在，可以直接调用，无需引用对象;</span><br></code></pre></td></tr></table></figure><h4 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="(2)静态常量"></a>(2)静态常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI=<span class="hljs-number">3.14159265358979323846</span>;<br>&#125;<br><span class="hljs-comment">//使用final是因为该值不可变,使用static是因为无需对象即可调用PI，PI为静态域而非实例域;</span><br></code></pre></td></tr></table></figure><h4 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="(3)静态方法"></a>(3)静态方法</h4><ul><li>静态方法是一种不能向对象实施操作的方法;也可以认为是没有this参数的方法</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextId</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nextId;<br>&#125;<br><span class="hljs-keyword">int</span> n = Employee.nextId();<br><span class="hljs-comment">//可以通过类名调用这个方法</span><br></code></pre></td></tr></table></figure><ul><li><p>使用静态方法的两种情况：  </p><p>1.方法不需要访问对象状态，其所需参数都是通过显式参数提供(eg：Math.pow)</p><p>2.方法只需要访问类的静态域(访问静态域必须用静态方法)</p></li></ul><h3 id="2-5-对象构造"><a href="#2-5-对象构造" class="headerlink" title="2.5 对象构造"></a>2.5 对象构造</h3><h4 id="1-重载-Overload"><a href="#1-重载-Overload" class="headerlink" title="(1)重载 Overload"></a>(1)重载 Overload</h4><p>如果多个方法有相同的名字，不同的参数，便产生了重载。</p><p>在编译过程中，编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。这个过程叫做重载解析。</p><h4 id="2-无参数构造器"><a href="#2-无参数构造器" class="headerlink" title="(2)无参数构造器"></a>(2)无参数构造器</h4><ul><li>必要性：在new一个对象时就会使用无参数构造器。</li><li>如果在编写一个类时没有写构造器，那么系统会提供一个无参数的构造器。</li><li>如果类中提供了至少一个构造器，系统不会自动提供无参构造器，必须自己写，否则new的时候会报错。</li></ul><p>无参构造器形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassName</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-调用另一个构造器"><a href="#3-调用另一个构造器" class="headerlink" title="(3)调用另一个构造器"></a>(3)调用另一个构造器</h4><p>如果构造器的第一个语句形如this(…)，表明这个构造器将调用同一类的另一个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Employee #&quot;</span>+nextId,s);<span class="hljs-comment">// calls Employee(String,double)</span><br>    nextId++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-Package"><a href="#2-6-Package" class="headerlink" title="2.6 Package"></a>2.6 Package</h3><p>使用包的主要原因是确保类名的唯一性，Sun公司建议将公司的因特网域名以逆序的形式作为包名.eg:com.google</p><ul><li>包的导入：使用import语句 eg：import java.util.*;</li><li>还可以导入静态域：eg：import static java.lang.System.*;</li><li>将类放到包中:package com.google.corejava;</li></ul><hr><h2 id="Charpter3-Extends"><a href="#Charpter3-Extends" class="headerlink" title="Charpter3.Extends"></a>Charpter3.Extends</h2><h3 id="3-1-类，超类和子类"><a href="#3-1-类，超类和子类" class="headerlink" title="3.1 类，超类和子类"></a>3.1 类，超类和子类</h3><h4 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="(1)定义子类"></a>(1)定义子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>    statement;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中，我们使用extends关键词表示继承，而在C++中使用：。在Java中所有的继承都是公有继承,没有C++中的私有继承和保护继承。</p><ul><li>已存在的类称为超类，基类或者父类;</li></ul><h4 id="2-重写-覆盖-Override"><a href="#2-重写-覆盖-Override" class="headerlink" title="(2)重写/覆盖 Override"></a>(2)重写/覆盖 Override</h4><ul><li><p>在IDEA中可以直接Alt+Insert然后选择Override</p></li><li><p>使用super调用超类 eg:super.getSalary();可以调用超类的方法，也可以类似this那样调用超类的构造器;</p></li></ul><h4 id="3-继承层次"><a href="#3-继承层次" class="headerlink" title="(3)继承层次"></a>(3)继承层次</h4><p>一个祖先类可以拥有多个子孙继承链，但是Java中不支持多继承。</p><h4 id="4-“断子绝孙”-final类和方法"><a href="#4-“断子绝孙”-final类和方法" class="headerlink" title="(4)“断子绝孙”-final类和方法"></a>(4)“断子绝孙”-final类和方法</h4><ul><li>不允许被继承/扩展的类可以使用final修饰符声明，final类中的所有方法自动变为final方法</li><li>类中的特定方法也可以被final声明，被final声明的方法不能重写</li></ul><h4 id="5-受保护访问"><a href="#5-受保护访问" class="headerlink" title="(5)受保护访问"></a>(5)受保护访问</h4><p>private-仅对本类可见 public-对所有类可见</p><p>protected-对本包和所有子类可见 default默认-对本包可见</p><h4 id="6-继承规则"><a href="#6-继承规则" class="headerlink" title="(6)继承规则"></a>(6)继承规则</h4><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><h3 id="3-2-多态"><a href="#3-2-多态" class="headerlink" title="3.2 多态"></a>3.2 多态</h3><h4 id="1-理解"><a href="#1-理解" class="headerlink" title="(1)理解"></a>(1)理解</h4><ul><li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是<strong>学生</strong>也是<strong>人</strong>，即出现<strong>两种形态</strong>。                                                      </li><li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</li></ul><h4 id="2-体现"><a href="#2-体现" class="headerlink" title="(2)体现"></a>(2)体现</h4><ul><li><p>定义格式：父类类型 变量名=new 子类类型();</p></li><li><p>多态体现为父类引用变量可以指向子类对象</p></li><li><p>注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p></li></ul><h4 id="3-多态中成员的特点"><a href="#3-多态中成员的特点" class="headerlink" title="(3)多态中成员的特点"></a>(3)多态中成员的特点</h4><ul><li>多态成员变量:编译运行看左边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f.num);<span class="hljs-comment">//输出超类的num</span><br></code></pre></td></tr></table></figure><ul><li>多态成员方法:编译看左边，运行看右边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f1.show());<span class="hljs-comment">//调用重写后的方法</span><br></code></pre></td></tr></table></figure><h4 id="4-多态的转型"><a href="#4-多态的转型" class="headerlink" title="(4)多态的转型"></a>(4)多态的转型</h4><ul><li><p>多态的转型分为向上转型和向下转型两种</p></li><li><p>向上转型:多态本身就是向上转型的过程  </p></li><li><p>向下转型:一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型.一般当要使用子类特有功能时候用到;</p><p>使用格式：子类类型 变量名=（子类类型） 父类类型的变量;</p></li></ul><h3 id="3-3-抽象类"><a href="#3-3-抽象类" class="headerlink" title="3.3 抽象类"></a>3.3 抽象类</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h4><p>将具体概念的诸多个性排出，集中描述其共性，产生抽象性概念。</p><p>所有不同职业，年龄的人，共性都是人。</p><p>拥有抽象方法的类就是抽象类，抽象类要用abstract修饰声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;haha!&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//抽象方法，继承时必须重写</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        People people = <span class="hljs-keyword">new</span> people();<span class="hljs-comment">//error 抽象类不可进行实例化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用原则"><a href="#2-使用原则" class="headerlink" title="(2)使用原则"></a>(2)使用原则</h4><p>1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>2.抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>3.抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>4.子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p><h3 id="3-4-Object-所有类的超类"><a href="#3-4-Object-所有类的超类" class="headerlink" title="3.4 Object:所有类的超类"></a>3.4 Object:所有类的超类</h3><h4 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="(1)equals方法"></a>(1)equals方法</h4><ul><li>重写equals方法:先调用超类的equals方法判断,再增加特定的判断条件;</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (!sԤerequals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>        Manager other = (Manager) otherObject; <br>        <span class="hljs-keyword">return</span> bonus == other.bonus; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="(2)hashCode方法"></a>(2)hashCode方法</h4><ul><li>hashCode是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li></ul><h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="(3)toString方法"></a>(3)toString方法</h4><ul><li>Objcet超类默认带toString方法，不过可以自己重写变得更好一点;</li><li>在IDEA中可以通过Alt+Insert找到toString;</li></ul><hr><h2 id="Charpter4-Interface"><a href="#Charpter4-Interface" class="headerlink" title="Charpter4.Interface"></a>Charpter4.Interface</h2><h3 id="4-1-接口（Interface"><a href="#4-1-接口（Interface" class="headerlink" title="4.1 接口（Interface)"></a>4.1 接口（Interface)</h3><h4 id="1-Concept-1"><a href="#1-Concept-1" class="headerlink" title="(1)Concept"></a>(1)Concept</h4><ul><li><p>接口在Java中是一个抽象类型,是抽象方法的集合;</p></li><li><p>一般来说，如果一个抽象类只由抽象方法和全局常量所组成，这种情况下我们定义成一个接口;接口中没有构造方法;</p></li><li><p>接口是对动作的抽象，抽象类是对本质的抽象;</p></li></ul><h4 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="(2)接口的使用"></a>(2)接口的使用</h4><ul><li><p>接口必须要有子类，一个子类可以通过实现(implements)多个接口；</p></li><li><p>接口的子类（如果不是抽象类），那么必须要重写接口中的全部抽象方法；</p></li><li><p>接口的对象可以利用子类对象的向上转型（多态）进行实例化;</p></li><li><p>对于接口，抽象方法和全局常量可以不用写public abstract或者public static final，并且接口中的访问权限只有public一种;注意子类重写方法的时候必须用public修饰;</p></li><li><p>在Java中，一个抽象类只能继承一个抽象类;而一个接口可以通过extends继承多个接口;(但接口不能继承抽象类)</p></li><li><p>接口不能通过new实例化一个对象，但是可以声明接口的变量，接口变量必须引用实现了接口的类的对象;</p></li></ul><h3 id="4-2-clone-Cloneable接口"><a href="#4-2-clone-Cloneable接口" class="headerlink" title="4.2 clone()/Cloneable接口"></a>4.2 clone()/Cloneable接口</h3><h4 id="1-拷贝和克隆"><a href="#1-拷贝和克隆" class="headerlink" title="(1)拷贝和克隆"></a>(1)拷贝和克隆</h4><p><img src="https://s3.ax1x.com/2021/01/26/sX2ufx.png" alt="拷贝vs克隆"></p><h4 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="(2)Object类的clone方法"></a>(2)Object类的clone方法</h4><ul><li><p>Object类的clone方法声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象;</p></li><li><p>Object类默认的clone方法是”浅拷贝”,并没有克隆对象中引用的其他对象;如果原对象和浅拷贝对象共享的子对象是不可变的类,那么这种共享相对安全,如String类,但是通常子对象是可变的,这样会导致这种共享是不安全的;</p><p><img src="https://s3.ax1x.com/2021/01/26/sX2l6O.png" alt="浅拷贝"></p></li></ul><h4 id="3-Cloneable接口"><a href="#3-Cloneable接口" class="headerlink" title="(3)Cloneable接口"></a>(3)Cloneable接口</h4><ul><li><p>Cloneable接口是Java提供的一组标记接口之一,通常用途是确定一个类实现一个或者一组特定的方法,标记接口不包含任何方法,唯一的作用是允许在类型查询中使用instanceof;</p></li><li><p>重写方法创建深拷贝的例子</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>        Employee cloned = (Employee) <span class="hljs-keyword">super</span>.clone();<br>        cloned.hireDay = (Date) hireDay.clone();<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-内部类"><a href="#4-3-内部类" class="headerlink" title="4.3 内部类"></a>4.3 内部类</h3><hr><h2 id="Chartper5-Exception"><a href="#Chartper5-Exception" class="headerlink" title="Chartper5.Exception"></a>Chartper5.Exception</h2><h3 id="5-1-异常分类"><a href="#5-1-异常分类" class="headerlink" title="5.1 异常分类"></a>5.1 异常分类</h3><ul><li>在Java语言中，所有异常对象都是派生于Throwable类的一个实例.</li></ul><p><img src="https://s3.ax1x.com/2021/01/26/sjCSEQ.png" alt="异常分类"></p><ul><li><p>Error类描述了Java运行时系统的内部错误和资源耗尽错误,这种情况很少见;</p></li><li><p>Exception类分解为两个分支，一个分支派生于RuntimeException(由于程序本身错误),另一个分支包含其他异常,程序本身没有问题,但是由于出现像I/O错误这种的异常叫做其他异常;</p><p>eg：派生于RuntimeException的异常包括以下几种情况:错误的类型转换,数组访问越界（ArrayIndexOutOfBoundsException),访问null空指针(NullPointerException)等等;</p></li><li><p>实际上，派生于Error类或RuntimeException类的所有异常称为非受查异常,所有其他的称为受查异常,编译器将检查所有的受查异常是否提供了异常处理器;</p></li></ul><h3 id="5-2-抛出异常"><a href="#5-2-抛出异常" class="headerlink" title="5.2. 抛出异常"></a>5.2. 抛出异常</h3><ul><li><p>方法应在首部使用throws声明所有可能抛出的异常（受查异常，无需声明派生于Error类或RuntimeException类的异常），每个异常用,隔开;</p></li><li><p>创建异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFormatException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOExpection</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<span class="hljs-comment">//也可不写</span><br>&#125;<br><br>...&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileFormatException();<span class="hljs-comment">//抛出这个自己定义的异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-捕获异常"><a href="#5-3-捕获异常" class="headerlink" title="5.3 捕获异常"></a>5.3 捕获异常</h3></li></ul><h4 id="1-try-catch语句块"><a href="#1-try-catch语句块" class="headerlink" title="(1)try-catch语句块"></a>(1)try-catch语句块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    code;<br>    more code;<br>&#125;<span class="hljs-keyword">catch</span>(ExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;<span class="hljs-keyword">catch</span>(OtherExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;...<br></code></pre></td></tr></table></figure><ul><li>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其他代码，抛出的异常直接被所对应的catch捕获并执行catch中的处理器代码;</li><li>在catch子句中可以再次抛出一个异常，再之后再进行解决;</li></ul><h4 id="2-finally子句"><a href="#2-finally子句" class="headerlink" title="(2)finally子句"></a>(2)finally子句</h4><ul><li><p>不管是否有异常被捕获，finally子句中的代码都会被执行;一般在需要关闭资源的时候使用finally子句;</p></li><li><p>当finally子句中包含return语句时，将会出现一种意想不到的效果。假如利用return语句从try语句块中退出，在方法返回前，finally子句的内容将被执行，如果finally子句中也有一个return语句，这个返回值会覆盖原始的返回值;</p></li></ul><h4 id="3-分析堆栈轨迹元素"><a href="#3-分析堆栈轨迹元素" class="headerlink" title="(3)分析堆栈轨迹元素"></a>(3)分析堆栈轨迹元素</h4><ul><li>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息;</li></ul><h3 id="5-4-异常声明碰到继承关系"><a href="#5-4-异常声明碰到继承关系" class="headerlink" title="5.4 异常声明碰到继承关系"></a>5.4 异常声明碰到继承关系</h3><ul><li>当重写一个函数时，子类不能比超类声明抛出更多的异常;</li><li>在子类的构造函数中,必须声明超类所可能抛出的全部异常;</li><li>利用多态(向上转型)的思想去思考这个问题;</li></ul><hr><h2 id="Charpter6-Generic"><a href="#Charpter6-Generic" class="headerlink" title="Charpter6.Generic"></a>Charpter6.Generic</h2><h3 id="6-1-为什么使用泛型"><a href="#6-1-为什么使用泛型" class="headerlink" title="6.1 为什么使用泛型"></a>6.1 为什么使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>Iterator it = coll.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>String str = (String) it.next();<br>System.out.println(str.length());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序时，程序报错 java.lang.ClassCastException（类型转换异常）;</p><p>因为任何类型的数据都可以强制转换成object类型数据储存在集合中，当我们取出一个对象时，就必须进行强制类型转换，这时候可能会出现类型转换异常，比如这里的5是int类型，int类型不能强制转换为String类;</p><h3 id="6-2-泛型概念"><a href="#6-2-泛型概念" class="headerlink" title="6.2 泛型概念"></a>6.2 泛型概念</h3><p>可以在类或方法中预支地使用未知的类型;</p><h3 id="6-3-泛型的定义与使用"><a href="#6-3-泛型的定义与使用" class="headerlink" title="6.3 泛型的定义与使用"></a>6.3 泛型的定义与使用</h3><h4 id="1-定义和使用泛型类"><a href="#1-定义和使用泛型类" class="headerlink" title="(1)定义和使用泛型类"></a>(1)定义和使用泛型类</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相当于把String赋值给E</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-定义和使用泛型方法"><a href="#2-定义和使用泛型方法" class="headerlink" title="(2)定义和使用泛型方法"></a>(2)定义和使用泛型方法</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethod</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode</span><span class="hljs-params">(E e)</span></span>&#123;<br>        System.out.println(e.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethodApplicaton</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ModeMethod m = <span class="hljs-keyword">new</span> ModeMethod();<br>        m.mode(<span class="hljs-number">123</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-定义和使用泛型的接口"><a href="#3-定义和使用泛型的接口" class="headerlink" title="(3)定义和使用泛型的接口"></a>(3)定义和使用泛型的接口</h4><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型接口：</p><p>01.定义类时确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>02.始终不确定泛型的类型，直到创建对象时才确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-泛型通配符"><a href="#6-4-泛型通配符" class="headerlink" title="6.4 泛型通配符"></a>6.4 泛型通配符</h3><h4 id="1-通配符基本使用"><a href="#1-通配符基本使用" class="headerlink" title="(1)通配符基本使用"></a>(1)通配符基本使用</h4><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以使用通配符&lt;?&gt;表示;但是一旦使用泛型的通配符后,只能使用Object类的共性方法,子类自身的方法无法使用</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Collection&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="2-通配符高级使用-受限泛型"><a href="#2-通配符高级使用-受限泛型" class="headerlink" title="(2) 通配符高级使用-受限泛型"></a>(2) 通配符高级使用-受限泛型</h4><ul><li><p>泛型的上限:只能接受该类型以及其子类</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? extends 上限类&gt;对象名称<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>泛型的下限:只能接受该类型以及其超类</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? <span class="hljs-keyword">super</span> 下限类&gt;对象名称<br></code></pre></td></tr></table></figure><p>eg:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Charpter7-Wrapper-Class"><a href="#Charpter7-Wrapper-Class" class="headerlink" title="Charpter7.Wrapper Class"></a>Charpter7.Wrapper Class</h2><h3 id="7-1-包装类概述"><a href="#7-1-包装类概述" class="headerlink" title="7.1 包装类概述"></a>7.1 包装类概述</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中//无需导包）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="7-2-包装类的自动装箱、自动拆箱机制"><a href="#7-2-包装类的自动装箱、自动拆箱机制" class="headerlink" title="7.2 包装类的自动装箱、自动拆箱机制"></a>7.2 包装类的自动装箱、自动拆箱机制</h3><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure><p>而Java为了方便我们使用，以及出于其他目的如性能调优，给我们提供了自动装箱、拆箱机制。这种机制简化了基本类型和包装类型的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Interger i = <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(100);</span><br>i = i +<span class="hljs-number">200</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 200;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h3 id="7-3-包装类中的缓存机制"><a href="#7-3-包装类中的缓存机制" class="headerlink" title="7.3 包装类中的缓存机制"></a>7.3 包装类中的缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer num3 = <span class="hljs-number">10</span>;<br>Integer num4 = <span class="hljs-number">10</span>;<br>Integer num5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num6 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num7 = <span class="hljs-number">128</span>;<br>Integer num8 = <span class="hljs-number">128</span>;<br>System.out.println((num3==num4) +<span class="hljs-string">&quot;&quot;</span>+ num3.equals(num4));<span class="hljs-comment">//ture true</span><br>System.out.println((num5==num6) +<span class="hljs-string">&quot;&quot;</span>+ num5.equals(num6));<span class="hljs-comment">//false true</span><br>System.out.println((num7==num8) +<span class="hljs-string">&quot;&quot;</span>+ num7.equals(num8));<span class="hljs-comment">//false true</span><br></code></pre></td></tr></table></figure><p>为什么num7==num8会返回false呢,我们来看看底层缓存机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br> <br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br> <br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>当Integer类第一次被使用到，Integer的静态内部类就被加载，加载的时候会创建-128到127的Integer对象，同时创建一个数组cache来缓存这些对象。当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，也就是说不会再新建对象；当使用new关键字or使用valueOf()方法创建小于-128大于127的值对象时，就会创建新对象。</p><p>接着,Integer类重写了equals方法,让我们看看equals方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>equals方法重写后比较两个Integer对象的值,所以确定两个Integer对象的值是否相等时,应该使用equals方法而非简单的==,否则因为缓冲机制可能会带来一些问题;</p><p>此外，在8种包装类型中，有缓存区的有Character、Byte、Short、Integer、Long，而且它们的实现方式基本一样，都是-128到127的缓存范围。Boolean虽然没有缓存区，但是因为只有两个值true、false，所以Boolean在成员变量中就创建了两个相应的对象。没有缓存区的只有Float、Double，之所以没有原因很简单，即便是0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</p><p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p><h3 id="7-4-包装类使用过程中有可能引起的空指针异常"><a href="#7-4-包装类使用过程中有可能引起的空指针异常" class="headerlink" title="7.4 包装类使用过程中有可能引起的空指针异常"></a>7.4 包装类使用过程中有可能引起的空指针异常</h3><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-keyword">null</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p>此时会出现NullPointerException;需要注意</p><p>//Reference:<a href="https://blog.csdn.net/sinat_30973431/article/details/89332443">Java中的包装类</a></p><hr><h2 id="Charpter8-Collection"><a href="#Charpter8-Collection" class="headerlink" title="Charpter8.Collection"></a>Charpter8.Collection</h2><h3 id="8-1-Introduction"><a href="#8-1-Introduction" class="headerlink" title="8.1 Introduction"></a>8.1 Introduction</h3><p><img src="https://s3.ax1x.com/2021/01/28/yCmIL8.png" alt="概述"></p><p><img src="https://s3.ax1x.com/2021/01/30/yAPzNj.png" alt="Collection"></p><p>集合是Java中的一种容器，可以用来存储多个数据。</p><ul><li><p>集合和数组的区别</p><p>(1)长度区别:数组的长度固定,集合的长度可变;</p><p>(2)内容区别:数组可以存储基本数据类型,也能存储引用类型,而集合只能存储引用类型;</p><p>(3)元素区别:数组中的元素必须是同一类型,集合可以存储不同类型的数据;</p></li><li><p>集合分两大类,单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p></li><li><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p></li></ul><h3 id="8-2-Collection接口常用方法"><a href="#8-2-Collection接口常用方法" class="headerlink" title="8.2 Collection接口常用方法"></a>8.2 Collection接口常用方法</h3><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;az&quot;</span>);<br>        col.remove(<span class="hljs-string">&quot;az&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> hasJava = col.contains(<span class="hljs-string">&quot;Java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hasJava = &quot;</span> + hasJava);<br>        Iterator&lt;String&gt; it = col.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String next = it.next();<br>            System.out.println(<span class="hljs-string">&quot;next = &quot;</span> + next);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        col.clear();<br>        <span class="hljs-keyword">boolean</span> empty = col.isEmpty();<br>        System.out.println(<span class="hljs-string">&quot;empty = &quot;</span> + empty);<br>        col.add(<span class="hljs-string">&quot;had&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;String&quot;</span>);<br>        <span class="hljs-keyword">int</span> size = col.size();<br>        System.out.println(<span class="hljs-string">&quot;size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        Object[] obj = col.toArray();<br>        <span class="hljs-keyword">for</span> (Object o : obj) &#123;<br>            System.out.println(o);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Map,List,Set接口中有一个静态方法of(),方便用于建立少量且元素数目不可变的集合(of()方法只能用于这三个接口,其子类没有)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="8-3-Iterator迭代器"><a href="#8-3-Iterator迭代器" class="headerlink" title="8.3 Iterator迭代器"></a>8.3 Iterator迭代器</h3><ul><li><p>Iterator接口主要用于迭代遍历Collection中的元素;</p></li><li><p>获取迭代器:<code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p></li><li><p>常用方法:</p><p><code>public E next()</code>:返回迭代的下一个元素。</p><p><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</p><p><code>public void remove()</code>：删除迭代器新返回的元素。</p></li><li><p>通过迭代器实现遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过迭代器清空集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            it.next();<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一些细节:</p><p>如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常;</p><p>如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException;</p><p>在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，java会抛出异常并发修改异常（ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p><p>(Reference:<a href="https://blog.csdn.net/qq_33642117/article/details/52039691">Java迭代器Iterator的详解</a></p></li></ul><h3 id="8-4-List集合"><a href="#8-4-List集合" class="headerlink" title="8.4 List集合"></a>8.4 List集合</h3><h4 id="1-List接口"><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h4><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引index的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h4 id="2-List接口中的常用方法"><a href="#2-List接口中的常用方法" class="headerlink" title="(2)List接口中的常用方法"></a>(2)List接口中的常用方法</h4><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        String s = list.get(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;list.remove(0) = &quot;</span> + list.remove(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;list.set(0,\&quot;reflect\&quot;) = &quot;</span> + list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;reflect&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-ArrayList集合"><a href="#3-ArrayList集合" class="headerlink" title="(3)ArrayList集合"></a>(3)ArrayList集合</h4><p><code>java.util.ArrayList</code>集合的底层是数组，元素增删慢，查找快，线程不安全，效率高，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><h4 id="4-LinkedList集合"><a href="#4-LinkedList集合" class="headerlink" title="(4)LinkedList集合"></a>(4)LinkedList集合</h4><p><code>java.util.LinkedList</code>集合的底层是双向链表，元素增删快，查找慢，线程不安全，效率高。</p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li></ul><h4 id="5-Vector集合"><a href="#5-Vector集合" class="headerlink" title="(5)Vector集合"></a>(5)Vector集合</h4><p><code>java.util.Vector</code>集合的底层是数组，元素增删慢，查询快，线程安全，效率低。</p><h3 id="8-5-Set接口"><a href="#8-5-Set接口" class="headerlink" title="8.5 Set接口"></a>8.5 Set接口</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)特点"></a>(1)特点</h4><ol><li>它是一个元素存取无序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就不一定按照11、22、33的顺序完成的,可能是22、33、11）。</li><li>它是没有索引的集合。</li><li>集合中不可以有重复的元素。</li></ol><h4 id="2-HashSet集合"><a href="#2-HashSet集合" class="headerlink" title="(2)HashSet集合"></a>(2)HashSet集合</h4><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><ul><li>hashCode:是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li></ul><h4 id="3-Set集合不允许重复的原理"><a href="#3-Set集合不允许重复的原理" class="headerlink" title="(3)Set集合不允许重复的原理"></a>(3)Set集合不允许重复的原理</h4><p>hashCode值相同<strong>且</strong>equals方法返回值为true时判断重复,不允许进行操作;</p><p>存储的包装类必须重写hashCode方法和equals方法;</p><h4 id="4-HashSet存储自定义类元素"><a href="#4-HashSet存储自定义类元素" class="headerlink" title="(4)HashSet存储自定义类元素"></a>(4)HashSet存储自定义类元素</h4><ul><li>需要重写hashCode方法和equals方法，否则不允许重复会被打破；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashSet&lt;Person&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Person person01 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>        Person person02 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        Person person03 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        set.add(person01);<br>        set.add(person02);<br>        set.add(person03);<br>        Iterator&lt;Person&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Person p = it.next();<br>            System.out.println(p);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;person01.hashCode() = &quot;</span> + person01.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person02.hashCode() = &quot;</span> + person02.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person03.hashCode() = &quot;</span> + person03.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未重写hashCode和equals方法前输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>person01.hashCode() = <span class="hljs-number">1967205423</span><br>person02.hashCode() = <span class="hljs-number">42121758</span><br>person03.hashCode() = <span class="hljs-number">20671747</span><br></code></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//先用==暴力判断</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//如果比较的对象为null或者两者属于不同的类型直接返回false</span><br>        Person person = (Person) o;<span class="hljs-comment">//向下转型</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;<br>                Objects.equals(name, person.name);<span class="hljs-comment">//第一个参数和第二个参数均相同</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重写hashCode和equals方法后输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>person01.hashCode() = <span class="hljs-number">24022538</span><br>person02.hashCode() = <span class="hljs-number">26104871</span><br>person03.hashCode() = <span class="hljs-number">26104871</span><br></code></pre></td></tr></table></figure><p>关于重写hashCode和equals方法:<a href="https://blog.csdn.net/u012557538/article/details/89861552">重写hashCode和equals方法</a></p><h4 id="5-LinkedHashSet"><a href="#5-LinkedHashSet" class="headerlink" title="(5)LinkedHashSet"></a>(5)LinkedHashSet</h4><p>LinkedHashSet的底层数据结构是HashMap和链表,可以保证元素唯一且有序，线程不安全，效率高。</p><h3 id="8-6-Collections"><a href="#8-6-Collections" class="headerlink" title="8.6 Collections"></a>8.6 Collections</h3><h4 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="(1)常用功能"></a>(1)常用功能</h4><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(list,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;liuliang&quot;</span>);<br>        Collections.shuffle(list);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br>[lisi, zhangsan, liuliang]<br>[lisi, liuliang, zhangsan]<br></code></pre></td></tr></table></figure><h4 id="2-重写Comparable接口中的compareTo方法"><a href="#2-重写Comparable接口中的compareTo方法" class="headerlink" title="(2)重写Comparable接口中的compareTo方法"></a>(2)重写Comparable接口中的compareTo方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangermazi&quot;</span>,<span class="hljs-number">23</span>));<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br><span class="hljs-comment">//        return 0;</span><br><span class="hljs-comment">//        return this.age - o.age ;//按年龄升序</span><br>        <span class="hljs-keyword">return</span> o.age - <span class="hljs-keyword">this</span>.age;<span class="hljs-comment">//按年龄降序</span><br>    &#125;<br>&#125;<br><br>升序:[Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;]<br>降序:[Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;]<br></code></pre></td></tr></table></figure><h4 id="3-Comparator比较器"><a href="#3-Comparator比较器" class="headerlink" title="(3)Comparator比较器"></a>(3)Comparator比较器</h4><ul><li><p>Comparable和Comparator的区别:</p><p>Comparable:this(自己)和别人(参数)比较,自己需要实现Comparable接口,重写比较规则的compareTo方法</p><p>Comparator:相当于找一个第三方的裁判对两者进行比较</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">12</span>));<br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge() - o1.getAge();<br>                <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>                    result = o2.getName().charAt(<span class="hljs-number">0</span>) - o1.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span>  result;<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Student&#123;name=<span class="hljs-string">&#x27;xiaoming&#x27;</span>, age=<span class="hljs-number">17</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">12</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="Charpter9-Map"><a href="#Charpter9-Map" class="headerlink" title="Charpter9.Map"></a>Charpter9.Map</h2><h3 id="9-1-Introduction"><a href="#9-1-Introduction" class="headerlink" title="9.1 Introduction"></a>9.1 Introduction</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><ul><li><p>Map&lt;K,V&gt; K(Key)-代表键的类型  V(Value)-代表值的类型；</p></li><li><p>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。通过键可以找到对应的值；</p></li></ul><h3 id="9-2-Map接口中的常用方法"><a href="#9-2-Map接口中的常用方法" class="headerlink" title="9.2 Map接口中的常用方法"></a>9.2 Map接口中的常用方法</h3><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Hint:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p><h3 id="9-3-Map集合的遍历方式"><a href="#9-3-Map集合的遍历方式" class="headerlink" title="9.3 Map集合的遍历方式"></a>9.3 Map集合的遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * `public Set&lt;K&gt; keySet()`: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment"> * `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">50</span>);<br>        map.put(<span class="hljs-string">&quot;李鬼&quot;</span>,<span class="hljs-number">10086</span>);<br><br>        <span class="hljs-comment">/* 1.使用keySet方法先获取map集合中的key存到新的Set集合中</span><br><span class="hljs-comment">           2.然后使用map集合的get方法获取value</span><br><span class="hljs-comment">           3.foreach循环遍历输出即可</span><br><span class="hljs-comment">        */</span><br><span class="hljs-comment">//        Set&lt;String&gt; containKeySet = map.keySet();</span><br><span class="hljs-comment">//        for (String key : containKeySet) &#123;</span><br><span class="hljs-comment">//            Integer values = map.get(key);</span><br><span class="hljs-comment">//            System.out.println(key+values);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">/*  1.使用map集合里的entrySet方法获取map集合里的键值对到新的Set集合中</span><br><span class="hljs-comment">            2.利用entry中的getKey方法和geyValue方法获取key和value,根据所需输出</span><br><span class="hljs-comment">            Hint:也可以直接使用foreach循环输出Set集合,得到的是key=value这样的格式效果</span><br><span class="hljs-comment">         */</span><br>        <br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; maps : set) &#123;<br>            String key = maps.getKey();<br>            Integer value = maps.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;对应&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-4-LinkedHashMap"><a href="#9-4-LinkedHashMap" class="headerlink" title="9.4 LinkedHashMap"></a>9.4 LinkedHashMap</h3><p>LinkedHashMap的底层是哈希表和双向链表,双向链表用于维护键值对的顺序,所以该集合是有序的;</p><h3 id="9-5-综合练习"><a href="#9-5-综合练习" class="headerlink" title="9.5 综合练习"></a>9.5 综合练习</h3><h4 id="9-5-1-字符出现次数"><a href="#9-5-1-字符出现次数" class="headerlink" title="9.5.1 字符出现次数"></a>9.5.1 字符出现次数</h4><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li> 获取一个字符串对象</li><li> 创建一个Map集合，键代表字符，值代表次数。</li><li> 遍历字符串得到每个字符。</li><li> 判断Map中是否有该键。</li><li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li> 打印最终结果</li></ol><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character tmp:s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(tmp)==<span class="hljs-keyword">null</span>)&#123;<br>                map.put(tmp,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                Integer sum = map.get(tmp);<br>                sum++;<br>                map.put(tmp,sum);<br>            &#125;<br>        &#125;<br>        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : set) &#123;<br>            Character key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(<span class="hljs-string">&quot;出现&quot;</span>+key+<span class="hljs-string">&quot;的次数为&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-5-2-斗地主有序版"><a href="#9-5-2-斗地主有序版" class="headerlink" title="9.5.2 斗地主有序版"></a>9.5.2 斗地主有序版</h4><p><strong>需求:</strong></p><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:1.  准备牌：完成数字与纸牌的映射关系：</span><br><span class="hljs-comment">使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</span><br><span class="hljs-comment">         */</span><br>        List&lt;String&gt; colors = List.of(<span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        List&lt;String&gt; numbers = List.of(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        List&lt;Integer&gt; pokerIndex = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Integer,String&gt; poker = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Integer index=<span class="hljs-number">0</span>;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;大王&quot;</span>);<br>        index++;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;小王&quot;</span>);<br>        index++;<br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                pokerIndex.add(index);<br>                poker.put(index,color+number);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*  2.洗牌通过数字完成洗牌发牌</span><br><span class="hljs-comment">         */</span><br>        Collections.shuffle(pokerIndex);<br><br><span class="hljs-comment">//        System.out.println(pokerIndex);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</span><br><span class="hljs-comment">        存放的过程中要求数字大小与斗地主规则的大小对应。</span><br><span class="hljs-comment">        将代表不同纸牌的数字分配给不同的玩家与底牌。</span><br><span class="hljs-comment">         */</span><br>        ArrayList&lt;Integer&gt; player01 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player02 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player03 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; temppoker = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Integer count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : pokerIndex) &#123;<br>            <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">50</span>)&#123;<br>                temppoker.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                player01.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<br>                player02.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">2</span>)&#123;<br>                player03.add(num);<br>            &#125;<br>            count++;<br>        &#125;<br>        Collections.sort(player01);<br>        Collections.sort(player02);<br>        Collections.sort(player03);<br>        Collections.sort(temppoker);<br><br><span class="hljs-comment">//        System.out.println(player01);</span><br><span class="hljs-comment">//        System.out.println(player02);</span><br><span class="hljs-comment">//        System.out.println(player03);</span><br><span class="hljs-comment">//        System.out.println(temppoker);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        4.  看牌：通过Map集合找到对应字符展示。</span><br><span class="hljs-comment">通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</span><br><span class="hljs-comment">         */</span><br>        search(<span class="hljs-string">&quot;周润发&quot;</span>,player01,poker);<br>        search(<span class="hljs-string">&quot;刘德华&quot;</span>,player02,poker);<br>        search(<span class="hljs-string">&quot;古天乐&quot;</span>,player03,poker);<br>        search(<span class="hljs-string">&quot;底牌&quot;</span>,temppoker,poker);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(String name,ArrayList list,Map poker)</span> </span>&#123;<br>        List&lt;Object&gt; listed = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            Object o1 = poker.get(o);<br>            listed.add(o1);<br>        &#125;<br>        System.out.print(name+<span class="hljs-string">&quot;:&quot;</span>);<br>        Iterator&lt;Object&gt; it = listed.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object next = it.next();<br>            System.out.print(next+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br>输出：<br>周润发:大王 ♦<span class="hljs-number">2</span> ♠<span class="hljs-number">2</span> ♠K ♣Q ♠Q ♣<span class="hljs-number">9</span> ♥<span class="hljs-number">8</span> ♠<span class="hljs-number">8</span> ♣<span class="hljs-number">7</span> ♥<span class="hljs-number">7</span> ♦<span class="hljs-number">6</span> ♥<span class="hljs-number">6</span> ♠<span class="hljs-number">6</span> ♠<span class="hljs-number">5</span> ♣<span class="hljs-number">4</span> ♥<span class="hljs-number">4</span> ♠<span class="hljs-number">4</span> <br>刘德华:♥<span class="hljs-number">2</span> ♣A ♠A ♦K ♣K ♣J ♥J ♠J ♦<span class="hljs-number">10</span> ♥<span class="hljs-number">10</span> ♠<span class="hljs-number">10</span> ♦<span class="hljs-number">9</span> ♥<span class="hljs-number">9</span> ♠<span class="hljs-number">9</span> ♣<span class="hljs-number">6</span> ♣<span class="hljs-number">5</span> ♥<span class="hljs-number">5</span> ♥<span class="hljs-number">3</span> <br>古天乐:小王 ♣<span class="hljs-number">2</span> ♦A ♥A ♥K ♦Q ♥Q ♦J ♣<span class="hljs-number">10</span> ♦<span class="hljs-number">8</span> ♣<span class="hljs-number">8</span> ♦<span class="hljs-number">7</span> ♠<span class="hljs-number">7</span> ♦<span class="hljs-number">5</span> ♦<span class="hljs-number">4</span> ♦<span class="hljs-number">3</span> ♣<span class="hljs-number">3</span> ♠<span class="hljs-number">3</span> <br>底牌:♠<span class="hljs-number">2</span> ♥Q ♥<span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure><h2 id="Charpter10-MultiThreading"><a href="#Charpter10-MultiThreading" class="headerlink" title="Charpter10.MultiThreading"></a>Charpter10.MultiThreading</h2><h3 id="10-1-并发与并行"><a href="#10-1-并发与并行" class="headerlink" title="10.1 并发与并行"></a>10.1 并发与并行</h3><ul><li><p><strong>并发</strong>:指两个或多个事件在同一个时间段内发生;</p></li><li><p><strong>并行</strong>:指两个或多个事件在同一个时间点发生;</p></li></ul><h3 id="10-2-线程与进程"><a href="#10-2-线程与进程" class="headerlink" title="10.2 线程与进程"></a>10.2 线程与进程</h3><ul><li><p><strong>进程</strong>:是指一个内存中运行的应用程序,一个应用程序可以同时进行多个进程,进程是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建,运行到消亡的过程;</p></li><li><p><strong>线程</strong>:是进程中的一个执行单元,负责当前进程中程序的执行;一个进程中可以有单线程或者多线程;</p></li><li><p><strong>线程调度</strong>:</p><p>(1)分时调度:所有线程轮流获得CPU的使用权,平均分配每个线程占用CPU的时间;</p><p>(2)抢占调度:优先让优先级高的线程使用CPU,如果线程的优先级相同,那么会随机选择一个使用CPU;<strong>Java就是使用抢占调度的方式</strong></p></li></ul><h3 id="10-3-线程类"><a href="#10-3-线程类" class="headerlink" title="10.3 线程类"></a>10.3 线程类</h3><p><code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread thread = <span class="hljs-keyword">new</span> TestThread();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+<span class="hljs-string">&quot;This is my thread!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常用API:</strong></p><ul><li><p><code>public Thread</code>:分配一个新线程对象。</p></li><li><p><code>public Thread(String name) </code>:分配一个指定名字的新的线程对象。</p></li><li><p><code>public Thread(Runnable target) </code>:分配一个带有指定目标新的线程对象</p></li><li><p><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。 </p></li><li><p><code>public String getName() </code>:获取当前线程名称。 </p></li><li><p><code>public void start() </code>:导致此线程开始执行; Java虚拟机调用此线程的run方法</p></li><li><p><code>public void run() </code>:此线程要执行的任务在此处定义代码。 </p></li><li><p><code>public static void sleep(long millis) </code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。//需要用try-catch语句可能抛出printStackTrace异常</p></li><li><p><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p></li></ul><h3 id="10-4-Runnable接口"><a href="#10-4-Runnable接口" class="headerlink" title="10.4 Runnable接口"></a>10.4 Runnable接口</h3><ul><li><p>通过实现Runnable接口来开启多线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.定义Runnable接口的实现类,重写run()方法;</span><br><span class="hljs-comment">2.创建Runnable实现类的实例对象,并以此实例对象作为Thread的参数来创建Thread对象</span><br><span class="hljs-comment">3.启用Thread对象的start()方法来开启多线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>       thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;这是第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过实现Runnable接口开启多线程的优势:</p><p>1.可以避免java单继承的局限性(继承了Thread就不能继承其他类)</p><p>2.使代码可以被多个线程共享,实现代码和线程独立</p><p>3.线程池只能放入实现Runnable或Callable类线程,不能直接放入继承Thread的类</p></li></ul><h3 id="10-5-通过匿名内部类实现创建线程"><a href="#10-5-通过匿名内部类实现创建线程" class="headerlink" title="10.5 通过匿名内部类实现创建线程"></a>10.5 通过匿名内部类实现创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;这是匿名内部类创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="10-6-引出线程安全问题"><a href="#10-6-引出线程安全问题" class="headerlink" title="10.6 引出线程安全问题"></a>10.6 引出线程安全问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    引出问题:在电影票卖票有多个售票窗口卖票,且这多个售票窗口共享需要兜售的票资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>        Thread thread01 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread02 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread03 = <span class="hljs-keyword">new</span> Thread(run);<br>        thread01.start();<br>        thread02.start();<br>        thread03.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">20</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">18</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">19</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">16</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">14</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">12</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">10</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">8</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">6</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">4</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">2</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">1</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">0</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第-<span class="hljs-number">1</span>张票<br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 在这里出现了卖重复的票和卖0/-1这种不存在的票，几个线程共享使用数据导致票数不同步，这种问题称为线程不安全。</p><h3 id="10-7-线程同步"><a href="#10-7-线程同步" class="headerlink" title="10.7 线程同步"></a>10.7 线程同步</h3><p>为了解决线程安全问题，Java中提供了同步机制(synchronized)来解决;</p><h4 id="10-7-1-同步代码块"><a href="#10-7-1-同步代码块" class="headerlink" title="10.7.1 同步代码块"></a>10.7.1 同步代码块</h4><ul><li><code>synchronized</code>关键字可以用于方法的某个区块中,表示对这个区块的资源实行互斥访问;</li></ul><p>创建格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同步锁:可以是任意类型(Object)的对象,注意多个线程对象要使用同一把同步锁;在开启多线程时，仅允许一个线程拿到同步锁，谁拿到同步锁即获得CPU的使用权,其他的线程得等该线程完成代码块释放锁后拿到锁才能执行;</li></ul><p>针对上面线程安全问题的优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-7-2-同步方法"><a href="#10-7-2-同步方法" class="headerlink" title="10.7.2 同步方法"></a>10.7.2 同步方法</h4><ul><li>可以使用<code>synchronized</code>修饰方法使方法成为同步方法;</li></ul><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> methodName&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面线程安全问题的优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                 System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同步方法本质也使用了同步锁,对于非静态方法,同步锁就是this;对于静态方法,同步锁就是当前方法所在类的字节码对象(类名.class)</li></ul><h4 id="10-7-3-Lock锁"><a href="#10-7-3-Lock锁" class="headerlink" title="10.7.3 Lock锁"></a>10.7.3 Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁操作;优化了加锁和释放锁的方式;</p><ul><li><code>public void lock();</code>加同步锁;</li><li><code>public void unlock();</code>释放同步锁;</li></ul><p><code>ReentrantLock</code>是一个互斥锁，也是一个<strong>可重入锁</strong>（Reentrant就是再次进入的意思）。<code>ReentrantLock</code>锁在同一个时间点只能被一个线程锁持有，但是它可以被单个线程多次获取，每获取一次<code>AQS</code>的<code>state</code>就加1，每释放一次<code>state</code>就减1。</p><p>针对上面线程安全问题的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意如果使用try-catch代码块,一定要把unlock()过程放到finally里,防止程序抛出了异常而一直不释放锁;</li></ul><h3 id="10-8-线程状态"><a href="#10-8-线程状态" class="headerlink" title="10.8 线程状态"></a>10.8 线程状态</h3><p>在线程的生命周期中,会呈现不同的线程状态;</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>New</td><td>线程刚被创建，但还并未启动，还没调用start方法</td></tr><tr><td>Runnable(可运行)</td><td>线程在JVM中运行的状态</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个同步锁，而该锁已被其他对象占有，则该线程进入Blocked状态;等该线程获取到锁时，转变为Runnable状态;</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行唤醒动作时,该线程进入Waiting状态.进入该状态不能主动唤醒,必须等待另一个线程调用notify方法;（当我们调用Thread.sleep(time);方法时,线程进入睡眠状态也就是TimedWaiting状态，等待时间到后自动唤醒;或者使用带参数的wait方法也可;）</td></tr><tr><td>TimedWaiting(计时等待)</td><td>类似于waiting状态,但是传入了一个参数,在一直没有另一个线程唤醒时,到了超时参数后会自动唤醒;</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出或者是因为没有捕获的异常终止了run方法而导致线程被终止</td></tr></tbody></table><h3 id="10-9-等待唤醒机制"><a href="#10-9-等待唤醒机制" class="headerlink" title="10.9 等待唤醒机制"></a>10.9 等待唤醒机制</h3><ul><li><p>常用方法:</p><p><code>Object.wait()</code>:使线程不再执行操作,进入waitset,等待notify使其回到readyset;</p><p><code>Object.notify()</code>:使所选取对象的一个线程释放;</p><p><code>Object.notifyAll()</code>:使所选取对象的所有线程释放;</p></li></ul><p>包子铺卖包子问题代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    包子铺卖包子问题:</span><br><span class="hljs-comment">        1.创建包子类,内有包子的皮和馅料实例,还有包子的状态(有或无);</span><br><span class="hljs-comment">        2.创建包子铺类,当包子的状态为无时就被唤醒做包子,做完后将包子状态改为有,唤醒买家;当包子的状态为有时就休眠;</span><br><span class="hljs-comment">        3.创建买家类,当包子的状态为有时就被唤醒买包子吃,吃完后将包子状态改为无,唤醒包子铺;当包子的状态为无时就休眠;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>        BaoZiPu baoZiPu = <span class="hljs-keyword">new</span> BaoZiPu(bz);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(bz);<br>        Thread baoziputhread = <span class="hljs-keyword">new</span> Thread(baoZiPu);<br>        Thread consumerthread = <span class="hljs-keyword">new</span> Thread(consumer);<br>        baoziputhread.start();<br>        consumerthread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String pi;<br>    <span class="hljs-keyword">public</span> String xian;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> state = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;店家正在做包子,请等待!&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;肉&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;厚皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;韭菜&quot;</span>;<br>                    &#125;<br>                    flag++;<br>                    bz.state = <span class="hljs-keyword">true</span>;<br>                    bz.notify();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bz = bz;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;我买了这个&quot;</span> + bz.pi + bz.xian + <span class="hljs-string">&quot;包子,一秒钟吃完!&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">1000</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        bz.state = <span class="hljs-keyword">false</span>;<br>                        System.out.println(<span class="hljs-string">&quot;吃完了,针不戳!&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>                        bz.notify();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            bz.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个厚皮韭菜包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>......<br></code></pre></td></tr></table></figure><h3 id="10-10-线程池"><a href="#10-10-线程池" class="headerlink" title="10.10 线程池"></a>10.10 线程池</h3><ul><li><strong>概念：</strong>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li></ul><h2 id="Charpter11-File"><a href="#Charpter11-File" class="headerlink" title="Charpter11.File"></a>Charpter11.File</h2><h3 id="11-1-Introduction"><a href="#11-1-Introduction" class="headerlink" title="11.1 Introduction"></a>11.1 Introduction</h3><p><code>java.io.File</code>类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h3 id="11-2-构造方法"><a href="#11-2-构造方法" class="headerlink" title="11.2 构造方法"></a>11.2 构造方法</h3><ul><li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用public File(String pathname) </span><br><span class="hljs-comment">*/</span><br>String pathname = <span class="hljs-string">&quot;D:\\a.txt&quot;</span>;<br>        File file = <span class="hljs-keyword">new</span> File(pathname);<br>        System.out.println(<span class="hljs-string">&quot;file = &quot;</span> + file);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用public File(String parent, String child) </span><br><span class="hljs-comment">*/</span><br>        String parent = <span class="hljs-string">&quot;D:\\&quot;</span>;<br>        String child = <span class="hljs-string">&quot;c.txt&quot;</span>;<br>        File file2 = <span class="hljs-keyword">new</span> File(parent,child);<br>        System.out.println(file2);<br>        child = <span class="hljs-string">&quot;d.txt&quot;</span>;<br>        file2 = <span class="hljs-keyword">new</span> File(parent,child);<br>        System.out.println(file2);<br></code></pre></td></tr></table></figure><ul><li>Hint:无论File类对象保存的路径是否存在,都不影响File对象的创建;</li></ul><h3 id="11-3-分隔符问题"><a href="#11-3-分隔符问题" class="headerlink" title="11.3 分隔符问题"></a>11.3 分隔符问题</h3><ul><li><p>在File类中,有四个静态变量：</p><p><code>static String pathSeparator</code> 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。<br><code>static char pathSeparatorChar</code> 与系统有关的路径分隔符。</p><p><code>static String separator</code> 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。<br><code>static char separatorChar</code> 与系统有关的默认名称分隔符。</p></li><li><p>```<br>static String pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。<br>static char pathSeparatorChar 与系统有关的路径分隔符。</p><p>static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。<br>static char separatorChar 与系统有关的默认名称分隔符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>* 在Windows操作系统中,路径分隔符pathSeparator为分号<span class="hljs-string">&quot;;&quot;</span>,在Linux操作系统中,路径分隔符为冒号<span class="hljs-string">&quot;:&quot;</span><br><br>* 在Windows操作系统中,默认名称分隔符separator为反斜杠<span class="hljs-string">&quot;\\&quot;</span>,在Linux操作系统中,路径分隔符为正斜杠<span class="hljs-string">&quot;/&quot;</span><br><br>* 因为带\的为转义字符,所以理论上的\应写成两个\才能表示;比如`C:\windows\a.txt`在代码中就应该写成`C:\\windows\\a.txt`<br><br>### <span class="hljs-number">11.4</span> 绝对路径和相对路径<br><br>* 老生常谈的问题<br><span class="hljs-operator">  * </span>**绝对路径**：从盘符开始的路径，这是一个完整的路径。<br><span class="hljs-operator">  * </span>**相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。<br><br>### <span class="hljs-number">11.5</span> File类常用的方法<br><br>* `public String get<span class="hljs-constructor">AbsolutePath()</span> ` ：返回此File的绝对路径名字符串。<br><br>* ` public String get<span class="hljs-constructor">Path()</span> ` ：将此File转换为路径名字符串。 <br><br>* `public String get<span class="hljs-constructor">Name()</span>`  ：返回由此File表示的文件或目录的名称。  <br><br>* `public long length<span class="hljs-literal">()</span>`  ：返回由此File表示的文件的字节大小 。<br><br>  (如果File对象表示的是目录的话,在JDK8返回值为<span class="hljs-number">0</span>，在JDK11返回值为<span class="hljs-number">4096</span>)<br><br>```java<br>        String pathname = <span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo\\a.txt&quot;</span>;<br>        File file1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">pathname</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">AbsoluteFile()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">Path()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">Name()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.length<span class="hljs-literal">()</span>);<br><br>        File file2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;a.txt&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file2.get<span class="hljs-constructor">AbsoluteFile()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file2.get<span class="hljs-constructor">Path()</span>);<br><br>        File file3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file3.length<span class="hljs-literal">()</span>);<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        输出结果:</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        a.txt</span><br><span class="hljs-comment">        6</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        a.txt</span><br><span class="hljs-comment">        0</span><br><span class="hljs-comment">        */</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</p></li><li><p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</p></li><li><p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p></li><li><p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p><blockquote><p>注意:<br>1.此方法只能创建文件,不能创建文件夹<br>2.创建文件的路径必须存在,否则会抛出异常</p></blockquote></li><li><p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。如果此File表示目录，则目录必须为空才能删除。delete方法是直接在硬盘删除文件/文件夹,不走回收站。</p></li><li><p><code>public boolean mkdir()</code> ：创建由此File表示的目录。mkdir = make directory；</p></li><li><p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。（可以创建多级文件夹）</p></li></ul><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(E:\\Test code\\Java);<br>    String[] dic = file.list();<br>    <span class="hljs-keyword">for</span>(String name : dic)&#123;<br>        System.out.println(name);<br>    &#125;<br>    File[] files = file.listFiles();<br>    <span class="hljs-keyword">for</span> (File file0 : files) &#123;<br>            System.out.println(file0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>递归打印多级目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span></span>&#123;<br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span>( File file : dir )&#123;<br>            <span class="hljs-keyword">if</span>(file.isFile())&#123;<br>System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span>+file.getAbsolutePath())&#125;;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;目录:&quot;</span>+file.getAbsolutePath());<br>            <span class="hljs-comment">//如果是目录的话继续递归</span><br>            printDir(file);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Charpter12-IOStream"><a href="#Charpter12-IOStream" class="headerlink" title="Charpter12. IOStream"></a>Charpter12. IOStream</h2><h3 id="12-1-Classfication"><a href="#12-1-Classfication" class="headerlink" title="12.1 Classfication"></a>12.1 Classfication</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。一般来说，涉及中文输入输出使用字符流;</li></ul><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<strong>InputStream</strong></td><td align="center">字节输出流<strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<strong>Reader</strong></td><td align="center">字符输出流<strong>Writer</strong></td></tr></tbody></table><h3 id="12-2-字节流"><a href="#12-2-字节流" class="headerlink" title="12.2 字节流"></a>12.2 字节流</h3><h4 id="12-2-1-一切皆为字节"><a href="#12-2-1-一切皆为字节" class="headerlink" title="12.2.1 一切皆为字节"></a>12.2.1 一切皆为字节</h4><p>一切文件数据（无论是文本，图片还是视频等）在存储时都是以二进制数据的形式保存，都是一个一个的字节，在传输时候也是如此。所以字节流可以传输任意文件数据。底层传输的始终是二进制的数据。</p><h4 id="12-2-2-OutputStream"><a href="#12-2-2-OutputStream" class="headerlink" title="12.2.2 OutputStream"></a>12.2.2 OutputStream</h4><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><h4 id="12-2-3-FileOutputStream"><a href="#12-2-3-FileOutputStream" class="headerlink" title="12.2.3 FileOutputStream"></a>12.2.3 FileOutputStream</h4><ul><li><code>FileOutputStream</code>是<code>java.io.OutputStream</code>类的子类,用于文件输出流,将数据写出到文件中;</li><li><strong>构造方法</strong>:<ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul></li></ul><ul><li><p><strong>写出字节数据</strong>:会抛出IOException</p><blockquote><p>一次写多个字节:<br>如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表<br>如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK)</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>public abstract void write(int b) ：将指定的字节输出流。<br>*&#x2F;<br>FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        fos.write(97);<br>        fos.write(85);<br>        fos.close();<br>&#x2F;&#x2F; 结果:aU<br>&#x2F;*<br>public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。  <br>*&#x2F;<br>FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &#123;97,98,99,100,52,85&#125;;<br>        fos.write(bytes);<br>        fos.close();<br>&#x2F;&#x2F; 结果：abcd4U<br>&#x2F;*<br>可以写入中文,使用String类的getBytes方法将其转换为byte[];<br>*&#x2F;<br>        FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Test code\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &quot;这是一个示例&quot;.getBytes();<br>        fos.write(bytes);<br>        fos.close();<br>&#x2F;*<br>public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  这里的off指的是打算输出的byte数组的所需的第一个索引,len为输出的长度;<br>*&#x2F;<br>        FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &#123;97,98,99,100,52,85&#125;;<br>        fos.write(bytes,2,3);<br>        fos.close();<br>&#x2F;&#x2F; 结果:cd4<br></code></pre></td></tr></table></figure><ul><li><p><strong>数据的续写与覆盖</strong></p><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了</p></li><li><p><strong>数据的换行</strong></p><ul><li><p>回车符<code>\r</code>和换行符<code>\n</code> ：</p><p>​    回车符：回到一行的开头（return）。</p><p>​    换行符：下一行（newline）。</p></li><li><p>系统中的换行：</p><p>​    Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</p><p>​    Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</p><p>​    Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;</span>,<span class="hljs-keyword">false</span>);<br><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;这是一个示例\r\n&quot;</span>.getBytes();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++) &#123;<br>    fos.write(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-2-4-InputStream"><a href="#12-2-4-InputStream" class="headerlink" title="12.2.4 InputStream"></a>12.2.4 InputStream</h4><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><h4 id="12-2-5-FileInputStream"><a href="#12-2-5-FileInputStream" class="headerlink" title="12.2.5 FileInputStream"></a>12.2.5 FileInputStream</h4><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><ul><li><p><strong>构造方法</strong>:</p><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p></li><li><p><strong>读取字节数据</strong>:</p><ul><li><p><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 读取完后指针自动向后移动一位,返回值为其读取到的值,若读取到文件末尾则返回-1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\Testcode\\Java\\IODemo\\a.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)temp); <span class="hljs-comment">//注意这里需要强转,不然输出的是转码后的int类型数据.</span><br>        &#125;<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//输出结果与a.txt存的内容一样:2w6e26</span><br></code></pre></td></tr></table></figure></li><li><p><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p><blockquote><p>明确两件事情:<br> 1.方法的参数byte[]的作用?</p><pre><code> 起到缓冲作用,存储每次读取到的多个字节 数组的长度一把定义为1024(1kb)或者1024的整数倍</code></pre><p> 2.方法的返回值int是什么?</p><pre><code> 每次读取的有效字节个数</code></pre></blockquote><ul><li><p>String类的构造方法</p><ul><li><p>String(byte[] bytes) :把字节 数组转换为字符串</p></li><li><p>String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数</p><blockquote><p>为什么使用该方法?我们定义byte[]数组的时候长度定义为1024字节,如果读取的数据＜1024字节则会有很多0补齐数组,而我们需要的只是读取出的数据,所以以0为开始索引,以读取的返回值为length来构造String类对象;</p></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo\\b.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,temp));<span class="hljs-comment">//使用String类的构造方法将byte[]类型的数组转换为String类的字符串</span><br>        &#125;<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:这是一个示例 这是一个示例</span><br></code></pre></td></tr></table></figure><h4 id="12-2-6-案例：图片复制"><a href="#12-2-6-案例：图片复制" class="headerlink" title="12.2.6 案例：图片复制"></a>12.2.6 案例：图片复制</h4></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close(); <span class="hljs-comment">//注意先开后关,后开先关;</span><br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了1694毫秒</span><br><span class="hljs-comment">//没有优化 直接一个字节一个字节读取,接下来我们用byte[]接受再测试下效率:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了4毫秒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10240</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了1毫秒</span><br></code></pre></td></tr></table></figure><h3 id="12-3-字符流"><a href="#12-3-字符流" class="headerlink" title="12.3 字符流"></a>12.3 字符流</h3><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。使用字节流读取中文文件，一个中文在GBK中占用2个字节而在UTF-8中占用3个字节。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h4 id="12-3-1-Reader"><a href="#12-3-1-Reader" class="headerlink" title="12.3.1 Reader"></a>12.3.1 Reader</h4><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h4 id="12-3-2-FileReader"><a href="#12-3-2-FileReader" class="headerlink" title="12.3.2 FileReader"></a>12.3.2 FileReader</h4><p><code>java.io.FileReader </code>类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><p><strong>构造方法</strong>：</p><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul></li><li><p><strong>读取字符数据</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">比较FileReader与FileInputStream的区别</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((length = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)length);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">while</span>((length = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)length);<br>        &#125;<br>        fis.close();<br>        fr.close();<br>    &#125;<br><br><span class="hljs-comment">/*输出结果:   è¿æ¯ä¸ä¸ªç¤ºä¾</span><br><span class="hljs-comment">        这是一个示例</span><br><span class="hljs-comment">足以佐证字符流输出的优势</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 优化：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        &#125;<br>    fr.close();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="12-3-3-Writer"><a href="#12-3-3-Writer" class="headerlink" title="12.3.3 Writer"></a>12.3.3 Writer</h4></li></ul><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><h4 id="12-3-4-FileWriter"><a href="#12-3-4-FileWriter" class="headerlink" title="12.3.4 FileWriter"></a>12.3.4 FileWriter</h4><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><strong>构造方法</strong>:<ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul></li></ul><ul><li><p><strong>写出字符</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">            void write(int c) 写入单个字符。</span><br><span class="hljs-comment">         */</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;c.txt&quot;</span>);<br>        fw.write(<span class="hljs-number">97</span>);<br>        fw.write(<span class="hljs-number">98</span>);<br>        fw.write(<span class="hljs-number">50</span>);<br>        fw.flush();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            void write(String str) 写入字符串。</span><br><span class="hljs-comment">         */</span><br>        fw.write(<span class="hljs-string">&quot;写入字符串...&quot;</span>);<br>        fw.flush();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">char</span>[] cbuf = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>&#125;;<br>        fw.write(cbuf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        fw.close();<br>    &#125;<br><span class="hljs-comment">// 文件结果:ab2写入字符串...bc</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>close与flush的区别</strong></p><ul><li><code>flush</code> :刷新缓冲区，流对象可以继续使用。</li><li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul></li><li><p>FileWriter与FileOutputStream的重要区别是FileWriter写入后必须刷新缓冲区才能将数据写入文件中，而FileOutputStream则无需手动刷新;</p></li><li><p>续写与换行操作同FileOutputStream;</p></li></ul><h3 id="12-4-How-to-deal-with-IOException"><a href="#12-4-How-to-deal-with-IOException" class="headerlink" title="12.4 How to deal with IOException"></a>12.4 How to deal with IOException</h3><ul><li><p><strong>JDK7前的处理</strong>：<code>try-catch-finally</code>代码块来处理异常部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>    FileReader fr = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//需要提升fr的作用域,否则在finally中将无法找到这个变量,而我们之后要使用fr变量,所以必须初始化为NULL;</span><br>    <span class="hljs-keyword">try</span>&#123;<br>    fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>   <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>        System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>    &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//先判断fr是否为null，防止引发空指针异常;</span><br>            <span class="hljs-keyword">if</span> (fr != <span class="hljs-keyword">null</span>) &#123;<br>                fr.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;     <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>JDK7的处理方法</strong></p><p>在JDK7中,出现了优化的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (创建流对象语句，如果多个,使用<span class="hljs-string">&#x27;;&#x27;</span>隔开) &#123;<br><span class="hljs-comment">// 读写数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span>( FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>); )&#123;<br>       <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>JDK9的处理方法</strong></p><p>在JDK9中 <code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>B b = <span class="hljs-keyword">new</span> B();<br><span class="hljs-keyword">try</span>(a;b)&#123;<br>    statement<br>&#125;<span class="hljs-keyword">catch</span>(E e)&#123;<br>    statement<br>&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>( fr )&#123;<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-5-Properties"><a href="#12-5-Properties" class="headerlink" title="12.5 Properties"></a>12.5 Properties</h3></li></ul><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一<code>Properties</code>对象。</p><ul><li><p><strong>常用方法</strong>:</p><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li><li><code>public void load(Reader reader)</code>： 从字符输入流中读取键值对。一般用于读取含有中文的键值对。 </li></ul></li><li><p><strong>使用</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Properties p = <span class="hljs-keyword">new</span> Properties();<br>        p.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>));<br>        Set&lt;String&gt; keys = p.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            System.out.println(key+<span class="hljs-string">&quot;的key为&quot;</span>+p.getProperty(key));<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 输出: lisi的key为234</span><br><span class="hljs-comment">        zhangsan的key为123</span><br><span class="hljs-comment">        wangwu的key为345</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/* 附:a.txt内容:</span><br><span class="hljs-comment">                # 注释注释</span><br><span class="hljs-comment">                zhangsan=123</span><br><span class="hljs-comment">                lisi 234</span><br><span class="hljs-comment">                wangwu 345</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><blockquote><p>注意:<br> 1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)<br> 2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取<br> 3.存储键值对的文件中,键与值默认都是字符串,不用再加引号</p></blockquote></li><li><p><strong>存储</strong>:</p><p>可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</p><ul><li><p>void store(OutputStream out, String comments)</p></li><li><p>void store(Writer writer, String comments)</p><p>参数:</p><pre><code>OutputStream out:字节输出流,不能写入中文Writer writer:字符输出流,可以写中文String comments:注释,用来解释说明保存的文件是做什么用的        不能使用中文,会产生乱码,默认是Unicode编码        一般使用&quot;&quot;空字符串</code></pre></li></ul></li></ul><h3 id="12-6-缓冲流"><a href="#12-6-缓冲流" class="headerlink" title="12.6 缓冲流"></a>12.6 缓冲流</h3><h4 id="12-6-1-Introdution"><a href="#12-6-1-Introdution" class="headerlink" title="12.6.1 Introdution"></a>12.6.1 Introdution</h4><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h4 id="12-6-2-字节缓冲流"><a href="#12-6-2-字节缓冲流" class="headerlink" title="12.6.2 字节缓冲流"></a>12.6.2 字节缓冲流</h4><ul><li><p><strong>构造方法</strong>：</p><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流。 默认缓存区大小是8192个字节即8KB。 </li><li><code>public BufferedInputStream(InputStream in, int size) </code>:创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。默认缓存区大小是8192个字节即8KB。 </li><li><code>public BufferedOutputStream(OutputStream out, int size)</code>: 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</li></ul></li><li><p><strong>具体使用</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d.txt&quot;</span>));<br>    bos.write(<span class="hljs-string">&quot;好家伙&quot;</span>.getBytes());<br>    bos.close();<br>  <br>    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>));<br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((length = bis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,length));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意使用BufferedOutputStream类的方法时输出数据后需要flush(),否则数据仅在缓冲区中,并没有实际输入到数据中去;</p></blockquote></li></ul><h4 id="12-6-3-字符缓冲流"><a href="#12-6-3-字符缓冲流" class="headerlink" title="12.6.3 字符缓冲流"></a>12.6.3 字符缓冲流</h4><ul><li><p><strong>构造方法</strong>：</p><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul></li><li><p><strong>特有方法</strong>：</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul></li><li><p><strong>具体使用</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * BufferedReader：`public String readLine()`: 读一行文字。</span><br><span class="hljs-comment">     * BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。</span><br><span class="hljs-comment">     */</span><br>    BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++) &#123;<br>        bw.write(<span class="hljs-string">&quot;你猜&quot;</span>);<br>        bw.newLine();<br>    &#125;<br>    bw.flush();<br>    bw.close();<br>  <br>    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    String temp;<br>    <span class="hljs-keyword">while</span>((temp = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>        System.out.println(temp);<br>    &#125;<br>    br.close();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>public String readLine()</code>的返回值为所读取到的String类型的字符串,当读取最后一行结束后返回为null；</p></blockquote></li></ul><h4 id="12-6-4-文本排序"><a href="#12-6-4-文本排序" class="headerlink" title="12.6.4 文本排序"></a>12.6.4 文本排序</h4><p>请将文本信息恢复顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。<br>8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>9.今当远离，临表涕零，不知所言。<br>6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br></code></pre></td></tr></table></figure><p><strong>代码实现</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:将f.txt中的文本进行排序,按每行前面的123456排序;</span><br><span class="hljs-comment">        分析:</span><br><span class="hljs-comment">            1.想要进行排序就要依次读取文本中的各行,使用BufferedReader中的readLine()方法读取</span><br><span class="hljs-comment">            2.读取完了之后我们要进行存储,既然要排序,可以在存储中完成排序,即使用HashMap集合,将每行文本分割成序号和内容即可</span><br><span class="hljs-comment">            3.由于HashMap集合是一个有序的集合，自动按key进行排序，我们只需将HashMap集合再次写出到新的文本中使用BufferedWriter中的write()和newLine()方法即可;</span><br><span class="hljs-comment">     */</span><br>    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    String temp;<br>    HashMap&lt;String,String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">while</span>((temp = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>        String[] split = temp.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        hashMap.put(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);<br>    &#125;<br>    BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;target.txt&quot;</span>));<br>    Set&lt;String&gt; keys = hashMap.keySet();<br>    <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>        String value = hashMap.get(key);<br>        bw.write(key+<span class="hljs-string">&quot;.&quot;</span>+value);<br>        bw.newLine();<br>    &#125;<br>    bw.close();<br>    br.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-7-转换流"><a href="#12-7-转换流" class="headerlink" title="12.7 转换流"></a>12.7 转换流</h3><h4 id="12-7-1-字符编码与字符集问题"><a href="#12-7-1-字符编码与字符集问题" class="headerlink" title="12.7.1 字符编码与字符集问题"></a>12.7.1 字符编码与字符集问题</h4><ul><li><p><strong>字符编码:</strong></p><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul></li><li><p><strong>字符集</strong>:</p><ul><li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul></li></ul><h4 id="12-7-2-编码引出的问题"><a href="#12-7-2-编码引出的问题" class="headerlink" title="12.7.2 编码引出的问题"></a>12.7.2 编码引出的问题</h4><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;GBK.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> read;<br>        <span class="hljs-keyword">while</span> ((read = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<br>        &#125;<br>        fileReader.close();<br>    &#125;<br>&#125;<br>输出结果：<br>���<br></code></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><h4 id="12-7-3-InputStreamReader类"><a href="#12-7-3-InputStreamReader类" class="headerlink" title="12.7.3 InputStreamReader类"></a>12.7.3 InputStreamReader类</h4><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><ul><li><p><strong>构造方法</strong>：</p><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul></li><li><p><strong>指定编码读取</strong>:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//        `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;d.txt&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] charss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> tempp =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((tempp = fr.read(charss)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(charss));<br>        &#125;<br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = isr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,temp));<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 结果:</span><br>                �üһ                                                                       <br>                �üһ                                                                       <br>                好家伙<br></code></pre></td></tr></table></figure><h4 id="12-7-4-OutputStreamWriter类"><a href="#12-7-4-OutputStreamWriter类" class="headerlink" title="12.7.4 OutputStreamWriter类"></a>12.7.4 OutputStreamWriter类</h4><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><ul><li><strong>构造方法</strong>：<ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul></li></ul><ul><li><p><strong>指定编码写出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 定义文件路径</span><br>      String FileName = <span class="hljs-string">&quot;E:\\out.txt&quot;</span>;<br>    <span class="hljs-comment">// 创建流对象,默认UTF-8编码</span><br>      OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName));<br>      <span class="hljs-comment">// 写出数据</span><br>    osw.write(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 保存为6个字节</span><br>      osw.close();<br>    <br><span class="hljs-comment">// 定义文件路径</span><br>String FileName2 = <span class="hljs-string">&quot;E:\\out2.txt&quot;</span>;<br>   <span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>      OutputStreamWriter osw2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName2),<span class="hljs-string">&quot;GBK&quot;</span>);<br>      <span class="hljs-comment">// 写出数据</span><br>    osw2.write(<span class="hljs-string">&quot;你好&quot;</span>);<span class="hljs-comment">// 保存为4个字节</span><br>      osw2.close();<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="12-7-5-转换文件编码"><a href="#12-7-5-转换文件编码" class="headerlink" title="12.7.5 转换文件编码"></a>12.7.5 转换文件编码</h4></li></ul><p><strong>需求</strong>:将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><p><strong>代码实现</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       需求:将GBK编码的文本文件d.txt，转换为UTF-8编码的文本文件dutf.txt。</span><br><span class="hljs-comment">       分析:</span><br><span class="hljs-comment">            1.首先创建InputStreamReader对象，指定字符编码为GBK,使用read()方法读取其内容</span><br><span class="hljs-comment">            2.创建OutputStreamWriter对象,指定字符编码为UTF-8,使用write()方法将1中读取到的内容写进新的txt文本中;</span><br><span class="hljs-comment">            3.释放流对象;</span><br><span class="hljs-comment">     */</span><br>    InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br>    OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;dutf.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">while</span>((temp = isr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>        osw.write(chars,<span class="hljs-number">0</span>,temp);<br>    &#125;<br>    osw.close();<br>    isr.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-8-序列化"><a href="#12-8-序列化" class="headerlink" title="12.8 序列化"></a>12.8 序列化</h3><h4 id="12-8-1-Introduction"><a href="#12-8-1-Introduction" class="headerlink" title="12.8.1 Introduction"></a>12.8.1 Introduction</h4><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p><h4 id="12-8-2-ObjectOutputStream类"><a href="#12-8-2-ObjectOutputStream类" class="headerlink" title="12.8.2 ObjectOutputStream类"></a>12.8.2 ObjectOutputStream类</h4><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><ul><li><p><strong>构造方法</strong>:</p><p><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</p></li><li><p><strong>序列化操作</strong>:</p><blockquote><p>一个对象要想序列化，必须满足两个条件:</p><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul></blockquote></li><li><p><strong>写出对象方法</strong>:</p><p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        oos.close();<br>    &#125;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>        &#125;<br>        String name;<br>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> age;<br>        String sex;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="12-8-3-ObjectInputStream类"><a href="#12-8-3-ObjectInputStream类" class="headerlink" title="12.8.3 ObjectInputStream类"></a>12.8.3 ObjectInputStream类</h4><p>ObjectInputStream为反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><ul><li><p><strong>构造方法</strong>：</p><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li></ul></li><li><p><strong>读取对象方法</strong>：</p><p><code>public final Object readObject ()</code> : 读取一个对象。注意返回值为Object类型的对象,使用时还要向下转型;</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        oos.close();<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        Person per= (Person) ois.readObject();<br>        System.out.println(per);<br>        Person per2= (Person) ois.readObject();<br>        System.out.println(per2);<br>        ois.close();<br>    &#125;<br><span class="hljs-comment">// 结果：</span><br>        Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br>        Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;woman&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</p></li><li><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常</p><blockquote><p>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul></blockquote><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><p>为了解决这个问题,我们可以在定义类的时候自己定义死serialVersionUID,实现代码: <code> private static final long serialVersionUID = 1L;</code></p></li></ul><h4 id="12-8-4-序列化集合"><a href="#12-8-4-序列化集合" class="headerlink" title="12.8.4 序列化集合"></a>12.8.4 序列化集合</h4><p><strong>代码实现</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br>        oos.writeObject(list);<br>        ArrayList&lt;Person&gt; list1 = (ArrayList&lt;Person&gt;) ois.readObject();<br>        <span class="hljs-keyword">for</span> (Person p : list1) &#123;<br>            System.out.println(p);<br>        &#125;<br>        ois.close();<br>        oos.close();<br>    &#125;<br><span class="hljs-comment">//结果:</span><br>Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;woman&#x27;</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br><span class="hljs-comment">//age因为使用了transient修饰符所以没有被序列化</span><br></code></pre></td></tr></table></figure><h3 id="12-9-打印流"><a href="#12-9-打印流" class="headerlink" title="12.9 打印流"></a>12.9 打印流</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><ul><li><p><strong>构造方法</strong>:</p><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li></ul></li><li><p><strong>改变打印流向</strong>:</p><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。我们可以通过setOut方法改变打印流向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 调用系统的打印流,控制台直接输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>      <br><span class="hljs-comment">// 创建打印流,指定文件的名称</span><br>        PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>);<br>      <br>      <span class="hljs-comment">// 设置系统的打印流流向,输出到ps.txt</span><br>        System.setOut(ps);<br>      <span class="hljs-comment">// 调用系统的打印流,ps.txt中输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2021/02/14/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/14/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>MySQL相关知识:SQL语句,增删改查,范式,视图,事务,索引…</p><a id="more"></a><h1 id="MySQL-笔记（持续更新中）"><a href="#MySQL-笔记（持续更新中）" class="headerlink" title="MySQL 笔记（持续更新中）"></a>MySQL 笔记（持续更新中）</h1><h2 id="Charpter1-Introduction"><a href="#Charpter1-Introduction" class="headerlink" title="Charpter1. Introduction"></a>Charpter1. Introduction</h2><h3 id="1-1-SQL"><a href="#1-1-SQL" class="headerlink" title="1.1 SQL"></a>1.1 <strong>SQL</strong></h3><p>Structured Query Language(结构化查询语言)</p><h3 id="1-2-SQL通用语法"><a href="#1-2-SQL通用语法" class="headerlink" title="1.2 SQL通用语法"></a>1.2 SQL通用语法</h3><ul><li><p>MySQL中SQL语句不区分大小写,可以使用小写可读性略强,但是关键字建议使用大写;</p></li><li><p>SQL语句可以单行或多行书写,所有语句以分号结尾;</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>多行书写:有利于提高可读性,更清晰<br>*&#x2F;<br>mysql&gt; insert into student values<br>    -&gt; (15,&#39;zs&#39;,18),<br>    -&gt; (16,&#39;df&#39;,12),<br>    -&gt; (22,&#39;as&#39;,14);<br>&#x2F;*<br>单行书写<br>*&#x2F;<br>mysql&gt; insert into student values (15,&#39;zs&#39;,18),(16,&#39;df&#39;,12),(22,&#39;as&#39;,14);<br></code></pre></td></tr></table></figure></li><li><p>注释:</p><ul><li>单行注释: 使用 – 注释内容 或 # 注释内容(MySQL中特有#)</li><li>多行注释:类似于Java,使用/* 注释内容 */</li></ul></li></ul><h3 id="1-3-MySQL的基本命令"><a href="#1-3-MySQL的基本命令" class="headerlink" title="1.3 MySQL的基本命令"></a>1.3 MySQL的基本命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql #启动mysql服务<br><span class="hljs-built_in">net</span> stop mysql  #关闭mysql服务<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>关于mysql登陆的方式<br>第一种直接输入密码,密码可视,有泄漏风险;<br>第二种输入密码时隐藏,相对比较安全;<br>第三种用于登陆指定主机的MySQL服务器;<br>*&#x2F;<br>mysql -u 用户名 -p 密码;<br>mysql -u 用户名 -p; # 之后会提示让你输入密码<br>mysql -h 需要登陆的ip地址 -u 用户名 -p 密码;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit;# 退出mysql<br>quit;# 退出mysql<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">\c # 退出当前语句<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -u 用户名 -p 密码 数据库名称 &gt; 保存的路径 # 备份数据库<br>&#x2F;* 还原数据库:<br>1.登陆数据库<br>2.创建数据库<br>3.使用数据库<br>4.执行备份文件:<br>*&#x2F;<br>source 文件路径;<br></code></pre></td></tr></table></figure><h2 id="Charpter2-Data-Definition-Language"><a href="#Charpter2-Data-Definition-Language" class="headerlink" title="Charpter2. Data Definition Language"></a>Charpter2. Data Definition Language</h2><h3 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h3><h4 id="2-1-1-Create"><a href="#2-1-1-Create" class="headerlink" title="2.1.1 Create"></a>2.1.1 Create</h4><ul><li><p>创建数据库:<code>create database 数据库名称;</code></p></li><li><p>先判断是否存在再创建数据库:<code>create database if not exists 数据库名称;</code></p></li><li><p>创建数据库并指定字符编码:<code> create database 数据库名称 charset=字符集名;</code></p></li></ul><h4 id="2-1-2-Retrieve"><a href="#2-1-2-Retrieve" class="headerlink" title="2.1.2 Retrieve"></a>2.1.2 Retrieve</h4><ul><li>查询所有数据库的名称:<code> show databases;</code></li><li>查询某个数据库的创建语句:<code>show create database 数据库名称;</code></li></ul><h4 id="2-1-3-Update"><a href="#2-1-3-Update" class="headerlink" title="2.1.3 Update"></a>2.1.3 Update</h4><ul><li>修改数据库的字符集:<code> alter database 数据库名称 charset=字符集名;</code></li></ul><h4 id="2-1-4-Delete"><a href="#2-1-4-Delete" class="headerlink" title="2.1.4 Delete"></a>2.1.4 Delete</h4><ul><li>删除数据库:<code>drop database 数据库名称;</code></li><li>先判断是否存在再删除数据库:<code>drop database if exist 数据库名称;</code></li></ul><h4 id="2-1-5-Use"><a href="#2-1-5-Use" class="headerlink" title="2.1.5 Use"></a>2.1.5 Use</h4><ul><li>使用数据库:<code>use 数据库名称;</code></li><li>查询当前正在使用的数据库:<code>select database();</code></li></ul><h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><h4 id="2-2-1-整数型"><a href="#2-2-1-整数型" class="headerlink" title="2.2.1 整数型"></a>2.2.1 整数型</h4><table><thead><tr><th>类型</th><th>字节大小</th><th>有符号范围</th><th>无符号范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-2^63~2^63-1</td><td>0~2^64</td></tr></tbody></table><h4 id="2-2-2-浮点型"><a href="#2-2-2-浮点型" class="headerlink" title="2.2.2 浮点型"></a>2.2.2 浮点型</h4><ul><li><p>FLOAT(M,D) – M:可以存储的位数,D:小数点后面的位数。</p></li><li><p>DOUBLE(M,D) – M:可以存储的位数,D:小数点后面的位数。</p></li><li><p>对于精度要求更高的可以使用定点型：DECIMAL(M,D)。</p></li></ul><h4 id="2-2-3-字符串类型"><a href="#2-2-3-字符串类型" class="headerlink" title="2.2.3 字符串类型"></a>2.2.3 字符串类型</h4><ul><li>CHAR(M):一个固定长度的字符串，在存储时始终用空格填充指定长度。存储时占用M个字节。CHAR的查询效率高于VARCHAR，对于字符串长度确定的字段可以使用CHAR。</li><li>VARCHAR(M):一个可变长度的字符串，用的最多。存储时占用L+1（L为字符串的实际长度）个字节。</li></ul><h4 id="2-2-4-时间日期类型"><a href="#2-2-4-时间日期类型" class="headerlink" title="2.2.4 时间日期类型"></a>2.2.4 时间日期类型</h4><ul><li><p>TIME：D HH:MM:SS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Create table timeTest(<br>a Time<br>);<br>Insert into timeTest values(&#39;13:45:21&#39;);<br>Insert into timeTest values(&#39;-3 13:45:21&#39;); --&#39;-3&#39;表示间隔三天<br>Insert into timeTest values(&#39;13:45&#39;); --有冒号从小时开始<br>Insert into timeTest values(&#39;114514&#39;); --没有冒号也没有天数 从秒开始<br></code></pre></td></tr></table></figure></li><li><p>DATETIME:时间和日期的组合 YYYY-MM-DD HH:MM:SS</p></li><li><p>TIMESTAMP:类似于DATETIME，但是defalut为本机时间CURRENT_TIMESTAMP;</p></li></ul><h4 id="2-2-5-数据类型约束"><a href="#2-2-5-数据类型约束" class="headerlink" title="2.2.5 数据类型约束"></a>2.2.5 数据类型约束</h4><ul><li>UNSIGNED：无符号</li><li>ZEROFILL：零填充,长度不够时以0填充到指定长度,字段自动为UNSIGNED</li><li>NOT NULL：非空约束</li><li>DEFAULT：默认值</li><li>AUTO_INCREMENT：自动增长</li><li>PRIMARY_KEY：主键</li></ul><h3 id="2-3-表操作"><a href="#2-3-表操作" class="headerlink" title="2.3 表操作"></a>2.3 表操作</h3><h4 id="2-3-1-Create"><a href="#2-3-1-Create" class="headerlink" title="2.3.1 Create"></a>2.3.1 Create</h4><ul><li><p>创建表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>分行写可读性更强<br>*&#x2F;<br>create table 表名称(<br>字段1 数据类型1,<br>字段2 数据类型2,<br>字段3 数据类型3,<br>...<br>字段n 数据类型n<br>);<br></code></pre></td></tr></table></figure></li><li><p>复制表：<code>create table 表名 like 被复制的表名;</code></p></li></ul><h4 id="2-3-2-Retrieve"><a href="#2-3-2-Retrieve" class="headerlink" title="2.3.2 Retrieve"></a>2.3.2 Retrieve</h4><ul><li>查询某个数据库中的所有表:<code>show tables;</code></li><li>查询某个表的结构:<code>desc 表名;</code></li></ul><h4 id="2-3-3-Update"><a href="#2-3-3-Update" class="headerlink" title="2.3.3 Update"></a>2.3.3 Update</h4><ul><li>修改表名:<code>alter table 表名 rename to 新表名;</code></li><li>修改表的字符集:<code>alter table 表名 charset=字符集;</code></li><li>添加一列:<code>alter table 表名 add 列名 数据类型;</code></li><li>修改列名称属性:<code>alter table 表名 change 列名 新列名 数据类型;</code></li><li>修改列数据类型:<code>alter table 表名 motify 列名 新数据类型;</code></li><li>删除列:<code>alter table 表名 drop 列名;</code></li></ul><h4 id="2-3-4-Delete"><a href="#2-3-4-Delete" class="headerlink" title="2.3.4 Delete"></a>2.3.4 Delete</h4><ul><li>删除表：<code>drop table 表名;</code></li><li>先检查表是否存在再删除:<code>drop table if exists 表名;</code></li></ul><h2 id="Charpter3-Data-Manipulation-Language"><a href="#Charpter3-Data-Manipulation-Language" class="headerlink" title="Charpter3. Data Manipulation Language"></a>Charpter3. Data Manipulation Language</h2><h3 id="3-1-添加数据-增"><a href="#3-1-添加数据-增" class="headerlink" title="3.1 添加数据(增)"></a>3.1 添加数据(增)</h3><ul><li><p>语法:<code>insert into 表名 (列名1,列名2,...,列名n) values(值1,值2,...值n);</code></p></li><li><p>增加多个数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values<br>    -&gt; (值1,值2,...值n),<br>    -&gt; (值1*,值2*,...值n*),<br>    -&gt; ...<br>    -&gt; (值1**,值2**,...值n**)<br>;<br></code></pre></td></tr></table></figure></li><li><p>注意:</p><p>​    1.列名和表名一定要一一对应;</p><p>​    2.列名可以省略可以为空或者有默认值的字段;</p><p>​    3.可以省略列名,默认给所有列添加值,那么值不一定漏了或者对应错了;</p><p>​    4.除了数字类型,其他的类型均需要加引号(单双均可).</p></li></ul><h3 id="3-2-删除数据-删"><a href="#3-2-删除数据-删" class="headerlink" title="3.2 删除数据(删)"></a>3.2 删除数据(删)</h3><ul><li><p>语法:<code>delete from 表名 [where 条件];</code></p></li><li><p>注意:如果不加条件,会删除表中所有的记录</p></li><li><p>删除所有数据的两种方法:</p><p>​    1.<code>delete from 表名;</code> –依次删除表中所有数据,表中有多少数据就要执行多少次,效率低,同时如果有auto_imcrement字段,之前自增的记录仍在;</p><p>​    2.<code>truncate table 表名;</code> –直接删除该表,同时创建一个空的该表;效率高;</p></li></ul><h3 id="3-3-修改数据-改"><a href="#3-3-修改数据-改" class="headerlink" title="3.3 修改数据(改)"></a>3.3 修改数据(改)</h3><ul><li><p>语法:<code>update 表名 set 列名1=值1 , 列名2=值2 , ... [where 条件];</code></p></li><li><p>注意:如果不加条件,会对表中所有的数据进行更改</p></li></ul><h2 id="Charpter4-Data-Query-Language"><a href="#Charpter4-Data-Query-Language" class="headerlink" title="Charpter4. Data Query Language"></a>Charpter4. Data Query Language</h2><h3 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a>4.1 基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>字段列表<br>from<br>表名列表<br>where<br>条件列表<br>group by<br>分组列表<br>having<br>分组后的操作<br>order by<br>排序<br>limit<br>分页限定<br></code></pre></td></tr></table></figure><h3 id="4-2-基础查询"><a href="#4-2-基础查询" class="headerlink" title="4.2 基础查询"></a>4.2 基础查询</h3><p>1.多个字段的查询:<code>select 字段名1,字段名2..,字段名n from 表名;</code></p><p>2.去重查询:使用distinct 关键字(提供的字段完全一样才去重)</p><p>eg:<code>select distinct 字段名1,字段名2..,字段名n from 表名;</code></p><p>3.关于NULL的处理:如果有NULL参与四则运算,计算结果都为NULL；</p><ul><li>ifnull(字段名,替换值) 来代替该字段;如果该字段为NULL,则替换为所提供的替换值;</li></ul><p>4.计算:可以直接使用四则运算计算某些列的值</p><p>eg:如果说有test1,test2两个字段,那么我们可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select test1 + ifnull(test2,0) as sum from testScore;<br></code></pre></td></tr></table></figure><h3 id="4-3-条件查询"><a href="#4-3-条件查询" class="headerlink" title="4.3 条件查询"></a>4.3 条件查询</h3><h4 id="4-3-1-运算符"><a href="#4-3-1-运算符" class="headerlink" title="4.3.1 运算符"></a>4.3.1 运算符</h4><ul><li><p><code>&gt;</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>=</code> <code>&lt;&gt;</code> –MySQL中使用=表示==等于,使用&lt;&gt;表示!=不等于</p></li><li><p><code>between...and</code> 值在某个区间内</p></li><li><p><code>in(set)</code> 值在某个集合内</p></li><li><p><code> is null</code> 如果值为NULL(不能直接用=来判定)</p></li><li><p><code>and</code> 和 <code>or</code> 或 <code>not</code>非</p></li><li><p><code>like</code>模糊查询:</p><p>占位符: <code>_</code>:单个任意字符;<code>%</code>多个任意字符(可以为0个)</p></li></ul><h4 id="4-3-2-Example"><a href="#4-3-2-Example" class="headerlink" title="4.3.2 Example"></a>4.3.2 Example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where age&gt;18;<br>select * from student where age&lt;&gt;18; -- 查询年龄不等于18岁的值<br>select * from student where age&gt;18 and age&lt;30;<br>select * from student where age between 18 and 30; -- 两种方法结果一样<br>select * from student where age in (18,20,26); -- 查询年龄为18或20或26岁的字段<br>select * from student where mathScore is NULL; -- 查询数学成绩为NULL的字段<br>select * from student where mathScore is NOT NULL; -- 查询数学成绩不为NULL的字段<br>select * from student where name like &#39;张%&#39;; -- 查询所有姓张的字段<br>select * from student where name like &#39;_家%&#39;; -- 查询第二个字为家的字段<br>select * from student where name like &#39;%家%&#39;; -- 查询姓名中含有家字的字段<br>select * from student where name like &#39;__&#39;; -- 查询姓名为两个字的字段<br></code></pre></td></tr></table></figure><h3 id="4-4-排序查询"><a href="#4-4-排序查询" class="headerlink" title="4.4 排序查询"></a>4.4 排序查询</h3><ul><li><p>语法：<code>order by 排序子段1 排序方式1, ... , 排序字段n 排序方式n</code></p></li><li><p>排序方式：</p><p>​    ASC：升序,默认</p><p>​    DESC：降序</p></li><li><p>注意：如果有多个排序条件，按顺序为第n条件，先判断靠前的条件；</p></li></ul><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student order by englishScore; -- 按英语成绩升序排序<br>select * from student order by englishScore DESC,mathScore DESC; -- 按英语成绩降序排列,如果英语成绩相同,按数学成绩降序排列;<br></code></pre></td></tr></table></figure><h3 id="4-5-聚合函数"><a href="#4-5-聚合函数" class="headerlink" title="4.5 聚合函数"></a>4.5 聚合函数</h3><ul><li><p>将一列数据作为一个整体,进行纵向的计算</p></li><li><p>常用聚合函数</p><p>​    1.max/min():计算最大最小值</p><p>​    2.sum():计算和</p><p>​    3.avg():计算平均值</p><p>​    4.count():计算数据的条数(一般选择主键)</p></li><li><p>注意：聚合函数的计算自动舍弃NULL值,可以使用ifnull函数来解决;</p></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select avg(mathScore) from student; -- 计算数学成绩的平均值<br>select count(id) from student; -- 计算有多少学生<br></code></pre></td></tr></table></figure><h3 id="4-6-分组查询"><a href="#4-6-分组查询" class="headerlink" title="4.6 分组查询"></a>4.6 分组查询</h3><ul><li><p>语法:<code>group by 分组依据字段</code></p></li><li><p>限定:where 和 having</p><p>​    1.where:在分组前进行限定,如果不满足条件则不参与分组,where后不能跟聚合函数;</p><p>​    2.having:在分组后进行限定,如果不满足条件则会被舍弃不会显示在查询结果中,having后可以跟聚合函数;</p></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex,AVG(mathScore) from student group by sex; -- 依据性别分组,分别查询男生和女生的数学平均分;<br>select sex,AVG(mathScore) from student where mathScore &gt; 80 group by sex; -- 只统计数学成绩＞80分的数据<br>select sex,AVG(mathScore),count(id) as 人数 from student group by sex having 人数 &gt; 5; -- 只统计分组后人数＞5的数据<br></code></pre></td></tr></table></figure><h3 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h3><ul><li>语法:<code>limit 开始的索引,每页查询的条数;</code>(注意索引是从0开始)</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student limit 0,3; -- 第1页 前三个数据<br>select * from student limit 3,3; -- 第2页<br>select * from student limit 6,3; -- 第3页<br></code></pre></td></tr></table></figure><h2 id="Charpter5-约束"><a href="#Charpter5-约束" class="headerlink" title="Charpter5. 约束"></a>Charpter5. 约束</h2><h3 id="5-1-非空约束"><a href="#5-1-非空约束" class="headerlink" title="5.1 非空约束"></a>5.1 非空约束</h3><ul><li><p>关键字:<code>not null</code> 即值不能为NULL</p></li><li><p>具体使用:</p><p>​    1.创建字段时加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int,<br>name varchar(20) not null -- name值必须为非空<br>)<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加非空约束</p><p><code>alter table student modify name varchar(20) not null;</code></p><p>​    3.删除非空约束</p><p><code>alter table student modify name varchar(20);</code></p></li></ul><h3 id="5-2-主键约束"><a href="#5-2-主键约束" class="headerlink" title="5.2 主键约束"></a>5.2 主键约束</h3><ul><li><p>关键字:<code>Primary Key</code> 非空且唯一</p></li><li><p>具体使用:</p><p>​    1.创建字段时加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key, -- id值为主键,非空且唯一<br>name varchar(20) not null <br>)<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加主键约束</p><p><code>alter table student motify id int primary key;</code></p><p>​    3.删除主键</p><p><code>alter table student drop primary key</code> # 注意:不能直接使用motify来删除主键,必须drop primary key;</p></li><li><p>auto_increment(自动增长):对数值类型进行值的自动增长;</p><p>实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment, -- id值为主键,非空且唯一,一般对主键使用自动增长<br>name varchar(20) not null <br>)<br></code></pre></td></tr></table></figure><p>注意:</p><p>自动增长实际上是根据上一行数据的自动增长字段+1;比如对于id=1,id=2,然后自己设置一个id=9,那么如果使用自动增长下一个id则应该为10;</p></li></ul><h3 id="5-3-唯一约束"><a href="#5-3-唯一约束" class="headerlink" title="5.3 唯一约束"></a>5.3 唯一约束</h3><ul><li><p>关键字:<code>unique</code> 即使用unique后该字段的值不能重复出现</p></li><li><p>具体使用:</p><p>​    1.创建字段时添加唯一约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment,<br>    phoneNumber varchar(40) unique -- 添加了唯一约束 每行数据的phoneNumber不能相同<br>)<br></code></pre></td></tr></table></figure><p>​    2.创建后再添加唯一约束</p><p><code>alter table student motify phoneNumber varchar(40) unique;</code></p><p>​    3.删除唯一约束</p><p><code>alter table student drop index phoneNumber;</code> # 必须使用drop index 删除索引 不能直接使用modify;</p></li><li><p>注意:唯一约束中可以存在多个NULL,每个NULL值默认为不相等;</p></li></ul><h3 id="5-4-外键约束"><a href="#5-4-外键约束" class="headerlink" title="5.4 外键约束"></a>5.4 外键约束</h3><ul><li><p>关键字:<code>foreign key</code> 让表与表之间的某些字段产生关系,确保数据的正确性;</p></li><li><p>具体使用</p><p>​    1.创建字段时添加外键</p><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>....<br>外键列<br>constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>id int primary key auto_increment,<br>department_id int,<br>    constraint depid foreign key (department_id) references department(id)<br>);<br>create table department(<br>id int primary key auto_increment,<br>    address varchar(20),<br>    career varchar(20)<br>);<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加外键</p><p><code>alter table 表明 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);</code></p><p>​    3.删除外键</p><p><code>alter table 表名 drop foreign key 外键名称;</code></p></li><li><p>级联操作:通过级联操作可以控制改变一张表的数据同时改变与之关联表的数据;</p><p>​    1.分类:级联更新 On update cascade</p><p>​                级联删除 On delete cascade</p><p>​    2.使用:</p><p>​        <code>alter table 表明 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) On update cascade On delete cascade;</code></p></li></ul><h2 id="Charpter6-数据库设计与范式"><a href="#Charpter6-数据库设计与范式" class="headerlink" title="Charpter6. 数据库设计与范式"></a>Charpter6. 数据库设计与范式</h2><h3 id="6-1-多表关系"><a href="#6-1-多表关系" class="headerlink" title="6.1 多表关系"></a>6.1 多表关系</h3><h4 id="6-1-1-分类"><a href="#6-1-1-分类" class="headerlink" title="6.1.1 分类"></a>6.1.1 分类</h4><ul><li><p>一对一:eg一个人和他的身份证一一对应</p></li><li><p>一对多(多对一):eg一个班级有多个学生,一个学生只能对应一个班级;</p></li><li><p>多对多:eg一个学生可以选择很多门课程,一个课程也可以被很多个学生选择;</p></li></ul><h4 id="6-1-2-实现"><a href="#6-1-2-实现" class="headerlink" title="6.1.2 实现"></a>6.1.2 实现</h4><ul><li><p>一对多:在多的一方建立外键,指向一的那方的主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table class(<br>    id int unique primary key,<br>    address varchar(20)<br>);<br>create table student(<br>id int primary key auto_increment,<br>    class_id int,<br>    constraint classid foreign key (class_id) references class(id)<br>);<br></code></pre></td></tr></table></figure></li><li><p>多对多:多对多关系的实现需要借助第三张中间表，中间表至少包含两个字段，作为第三张表的外键分别指向两张表的主键;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment,<br>    name varchar(20),<br>    address varchar(35),<br>    sex varchar(5)<br>);<br>create table course(<br>id int primary key auto_increment,<br>    course_name varchar(10),<br>    introduction varchar(100)<br>);<br>create table choice_for_course(<br>stu_id int,<br>    course_id int,<br>    constraint stuid foreign key (stu_id) references student(id),<br>    constraint courseid foreign key (course_id) references course(id)<br>);<br></code></pre></td></tr></table></figure></li><li><p>一对一:可以在任意一方添加<strong>唯一</strong>外键指向另一方主键/在同一张表中使用</p></li></ul><h3 id="6-2-范式"><a href="#6-2-范式" class="headerlink" title="6.2 范式"></a>6.2 范式</h3><h4 id="6-2-1-一些基本概念"><a href="#6-2-1-一些基本概念" class="headerlink" title="6.2.1 一些基本概念"></a>6.2.1 一些基本概念</h4><ul><li><p>函数依赖：A–&gt;B 如果通过A属性(属性组)的值,可以唯一确定B属性的值,则称B依赖于A;</p><p>eg:通过学号我们可以唯一确定姓名;通过学号和课程名可以唯一确定该同学的成绩;</p></li><li><p>完全函数依赖:A–&gt;B 如果A是一个属性组,那么确定B属性值需要依赖于A属性组中所有的属性值;</p><p>eg:想要得知课程成绩必须知道学号和课程名,缺一不可;</p></li><li><p>部分函数依赖:A–&gt;B 如果A是一个属性组,那么确定B属性值只需要依赖于A属性组中部分的属性值;</p></li><li><p>传递函数依赖:A–&gt;B B–&gt;C 如果通过A属性(属性组)的值可以唯一确定B属性的值,在通过B属性(属性组)的值可以唯一确定C属性的值,则称C传递依赖于A;</p></li></ul><ul><li>码:如果在一张表中,一个属性(属性组)被其他所有属性完全依赖,则称为该属性为该表的码;</li><li>主属性:码属性中的所有属性;</li></ul><h4 id="6-2-2-数据库第一范式"><a href="#6-2-2-数据库第一范式" class="headerlink" title="6.2.2 数据库第一范式"></a>6.2.2 数据库第一范式</h4><ul><li><p>表述:每一列都是不可分割的原子项;</p><p>eg:<img src="https://s3.ax1x.com/2021/02/13/ystsr6.png" alt="example1"></p></li></ul><p>在该表中，系可以分割为系名和系主任，违背了第一范式。修改:</p><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>99</td></tr></tbody></table><h4 id="6-2-3-数据库第二范式"><a href="#6-2-3-数据库第二范式" class="headerlink" title="6.2.3 数据库第二范式"></a>6.2.3 数据库第二范式</h4><p>首先,我们来看看第一范式汇总存在的问题:</p><p>1.有过多的数据冗余,比如张无忌,经济系,张三丰,出现次数过多;</p><p>2.在数据添加中存在问题,比如我们想新增一个系或者系主任,没有学号姓名等数据无法添加;</p><p>3.在数据删除中存在问题,比如张无忌同学毕业了,那么他的数据会被删除,导致系的信息也被删除了;</p><p>那么我们来引出数据库第二范式</p><ul><li>表述:<strong>在第一范式的基础上</strong>,非码属性必须完全依赖于码属性(在第一范式的基础上消除非主属性对主码的部分函数依赖)</li></ul><p>首先我们得确定该表的码属性,显然为学号和课程名称,非码属性为姓名,系名,系主任,分数;那么哪些非码属性不完全依赖于码属性呢,首先就是姓名,姓名不需要通过课程名确定,然后系,系主任也同理,只有分数是完全依赖于码属性;那么我们就先按这个思想分成两个表:</p><table><thead><tr><th>学号</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>大学英语</td><td>99</td></tr></tbody></table><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td></tr></tbody></table><p>第二个新表中,码属性为学号,姓名,系名,系主任都由学号唯一确定,完全依赖于码属性;</p><h4 id="6-2-4-数据库第三范式"><a href="#6-2-4-数据库第三范式" class="headerlink" title="6.2.4 数据库第三范式"></a>6.2.4 数据库第三范式</h4><p>那么满足第二范式就一定没有问题吗?我们再来看看之前的问题</p><p>比如此时我们需要新办一个系或者增加一个系主任,以及同学毕业问题,问题还未解决.</p><p>那么我们来引入数据库第三范式:</p><ul><li>表述:<strong>在数据库第二范式的基础上</strong>,任何非主属性不依赖于其他非主属性(在第二范式的基础上消除传递依赖);</li></ul><p>我们看看第二个新表中,非主属性为姓名,系名,系主任,(别忘了有可能有重名现象),我们发现,系主任这个是完全依赖于系名的,一个系只有一个系主任,那么即系主任传递依赖于学号,我们要消除这种传递依赖的情况:</p><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td></tr></tbody></table><table><thead><tr><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>经济系</td><td>张三丰</td></tr><tr><td>法律系</td><td>任我行</td></tr></tbody></table><p>这样我们就满足了数据库第三范式;</p><p>满足数据库第一第二第三范式的设计相对较合理;</p><h2 id="Charpter7-多表查询"><a href="#Charpter7-多表查询" class="headerlink" title="Charpter7. 多表查询"></a>Charpter7. 多表查询</h2><h3 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h3><ul><li><p>笛卡尔积:若有两个集合A、B,那么其笛卡尔积即为A、B所有可能的组成情况;即结果=A种种类数目*B种类数目;</p></li><li><p>若直接使用多表查询，得到的是笛卡尔积；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table dept(<br>id int primary key auto_increment,<br>    name varchar(20)<br>);<br>INSERT INTO dept (NAME) VALUES (&#39;kaifa&#39;),(&#39;shichang&#39;),(&#39;cehua&#39;);<br>create table emp(<br>id int primary key auto_increment,<br>    name varchar(10),<br>    gender char(5),<br>    salary double,<br>    join_date date,<br>    dept_id int,<br>    foreign key (dept_id) references dept(id)<br>);<br>INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;zhangsan&#39;,&#39;man&#39;,7200,&#39;2013-02-24&#39;,1);<br>INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;lisi&#39;,&#39;woman&#39;,3600,&#39;2010-12-02&#39;,2);<br>INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;xiaowang&#39;,&#39;man&#39;,9000,&#39;2008-08-08&#39;,2);<br>INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;dawang&#39;,&#39;woman&#39;,5000,&#39;2015-10-07&#39;,3);<br>INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;wangwu&#39;,&#39;man&#39;,4500,&#39;2011-03-14&#39;,1);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from dept,emp;<br></code></pre></td></tr></table></figure><p>emp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+----+----------+--------+--------+------------+---------+<br>| id | name     | gender | salary | join_date  | dept_id |<br>+----+----------+--------+--------+------------+---------+<br>|  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>| 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>+----+----------+--------+--------+------------+---------+<br></code></pre></td></tr></table></figure><p>dept:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+----+----------+<br>| id | name     |<br>+----+----------+<br>|  1 | kaifa    |<br>|  2 | shichang |<br>|  3 | cehua    |<br>+----+----------+<br></code></pre></td></tr></table></figure><p>查询结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+----+----------+----+----------+--------+--------+------------+---------+<br>| id | name     | id | name     | gender | salary | join_date  | dept_id |<br>+----+----------+----+----------+--------+--------+------------+---------+<br>|  1 | kaifa    |  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  2 | shichang |  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  3 | cehua    |  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  1 | kaifa    |  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  2 | shichang |  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  3 | cehua    |  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  1 | kaifa    |  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  2 | shichang |  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  3 | cehua    |  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  1 | kaifa    |  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>|  2 | shichang |  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>|  3 | cehua    |  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>|  1 | kaifa    | 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>|  2 | shichang | 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>|  3 | cehua    | 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>+----+----------+----+----------+--------+--------+------------+---------+<br></code></pre></td></tr></table></figure><h3 id="7-2-内连接查询"><a href="#7-2-内连接查询" class="headerlink" title="7.2 内连接查询"></a>7.2 内连接查询</h3><h4 id="7-2-1-隐式内连接"><a href="#7-2-1-隐式内连接" class="headerlink" title="7.2.1 隐式内连接"></a>7.2.1 隐式内连接</h4><ul><li><p>使用where条件消除无用数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select <br>* <br>from <br>dept t1,<br>emp t2 <br>where <br>dept.&#96;id&#96; &#x3D; emp.&#96;dept_id&#96;; <br># 注意这里的&#96;,是Tab键上面的&#96;,也可以省略;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+----+----------+----+----------+--------+--------+------------+---------+<br>| id | name     | id | name     | gender | salary | join_date  | dept_id |<br>+----+----------+----+----------+--------+--------+------------+---------+<br>|  1 | kaifa    |  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  1 | kaifa    | 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>|  2 | shichang |  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  2 | shichang |  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  3 | cehua    |  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>+----+----------+----+----------+--------+--------+------------+---------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>t2.name, -- 员工姓名<br>t2.gender,  -- 员工性别<br>t1.name-- 部门名称<br>from<br>dept t1,<br>emp t2<br>where<br>t1.&#96;id&#96; &#x3D; t2.&#96;dept_id&#96;;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">+----------+--------+----------+<br>| name     | gender | name     |<br>+----------+--------+----------+<br>| zhangsan | man    | kaifa    |<br>| wangwu   | man    | kaifa    |<br>| lisi     | woman  | shichang |<br>| xiaowang | man    | shichang |<br>| dawang   | woman  | cehua    |<br>+----------+--------+----------+<br></code></pre></td></tr></table></figure><h4 id="7-2-2-显式内连接"><a href="#7-2-2-显式内连接" class="headerlink" title="7.2.2 显式内连接"></a>7.2.2 显式内连接</h4></li><li><p>语法:<code>select 字段列表 from 表名1 [inner] join 表名2 on 条件;</code></p></li></ul><p>example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>t2.name, -- 员工姓名<br>t2.gender,  -- 员工性别<br>t1.name-- 部门名称<br>from<br>dept t1<br>inner join<br>emp t2<br>on<br>t1.&#96;id&#96; &#x3D; t2.&#96;dept_id&#96;;<br></code></pre></td></tr></table></figure><h3 id="7-3-外连接查询"><a href="#7-3-外连接查询" class="headerlink" title="7.3 外连接查询"></a>7.3 外连接查询</h3><h4 id="7-3-1-左外连接查询"><a href="#7-3-1-左外连接查询" class="headerlink" title="7.3.1 左外连接查询"></a>7.3.1 左外连接查询</h4><ul><li><p>语法:<code>select 字段列表 from 表名1 left [outer] join 表2 on 条件;</code></p></li><li><p>特点:查询左表所有数据以及左右表交集部分;</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into emp values(11,&#39;tiange&#39;,&#39;man&#39;,1500,&#39;2020-05-15&#39;,NULL);<br># emp表中:<br>+----+----------+--------+--------+------------+---------+<br>| id | name     | gender | salary | join_date  | dept_id |<br>+----+----------+--------+--------+------------+---------+<br>|  6 | zhangsan | man    |   7200 | 2013-02-24 |       1 |<br>|  7 | lisi     | woman  |   3600 | 2010-12-02 |       2 |<br>|  8 | xiaowang | man    |   9000 | 2008-08-08 |       2 |<br>|  9 | dawang   | woman  |   5000 | 2015-10-07 |       3 |<br>| 10 | wangwu   | man    |   4500 | 2011-03-14 |       1 |<br>| 11 | tiange   | man    |   1500 | 2020-05-15 |    NULL |<br>+----+----------+--------+--------+------------+---------+<br>dept表中:<br>+----+----------+<br>| id | name     |<br>+----+----------+<br>|  1 | kaifa    |<br>|  2 | shichang |<br>|  3 | cehua    |<br>+----+----------+<br></code></pre></td></tr></table></figure><p>注意我们新添加的tiange数据中dept_id为NULL,如果不使用外连接查询,直接使用内连接查询的话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>t2.name, -- 员工姓名<br>t2.gender,  -- 员工性别<br>t1.name-- 部门名称<br>from<br>dept t1<br>inner join<br>emp t2<br>on<br>t1.id &#x3D; t2.dept_id;<br><br># 结果:<br>+----------+--------+----------+<br>| name     | gender | name     |<br>+----------+--------+----------+<br>| zhangsan | man    | kaifa    |<br>| wangwu   | man    | kaifa    |<br>| lisi     | woman  | shichang |<br>| xiaowang | man    | shichang |<br>| dawang   | woman  | cehua    |<br>+----------+--------+----------+<br></code></pre></td></tr></table></figure><p>我们发现没有部门id的tiange数据并没有被查询出来;那么如果我们想知道全部数据即使某些数据中部门id为NULL,就必须使用外连接查询;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>t1.name, -- 员工姓名<br>t1.gender,  -- 员工性别<br>t2.name-- 部门名称<br>from<br>emp t1<br>left outer join<br>dept t2<br>on<br>t2.id &#x3D; t1.dept_id;<br><br># 结果:<br>+----------+--------+----------+<br>| name     | gender | name     |<br>+----------+--------+----------+<br>| zhangsan | man    | kaifa    |<br>| wangwu   | man    | kaifa    |<br>| lisi     | woman  | shichang |<br>| xiaowang | man    | shichang |<br>| dawang   | woman  | cehua    |<br>| tiange   | man    | NULL     |<br>+----------+--------+----------+<br></code></pre></td></tr></table></figure><h4 id="7-3-2-右外连接查询"><a href="#7-3-2-右外连接查询" class="headerlink" title="7.3.2 右外连接查询"></a>7.3.2 右外连接查询</h4><ul><li>和左外连接类似,语法:<code>select 字段列表 from 表名1 right [outer] join 表2 on 条件;</code></li></ul><h3 id="7-4-子查询"><a href="#7-4-子查询" class="headerlink" title="7.4 子查询"></a>7.4 子查询</h3><h4 id="7-4-1-基础概念与使用"><a href="#7-4-1-基础概念与使用" class="headerlink" title="7.4.1 基础概念与使用"></a>7.4.1 基础概念与使用</h4><ul><li>Concept:在查询中嵌套查询;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 案例数据库<br>    -- 部门表<br>CREATE TABLE dept (<br>  id INT PRIMARY KEY PRIMARY KEY, -- 部门id<br>  dname VARCHAR(50), -- 部门名称<br>  loc VARCHAR(50) -- 部门所在地<br>);<br><br>-- 添加4个部门<br>INSERT INTO dept(id,dname,loc) VALUES <br>(10,&#39;coding&#39;,&#39;beijing&#39;),<br>(20,&#39;market&#39;,&#39;shanghai&#39;),<br>(30,&#39;sale&#39;,&#39;guangzhou&#39;),<br>(40,&#39;money&#39;,&#39;shenzhen&#39;);<br>-- 职务表，职务名称，职务描述<br>CREATE TABLE job (<br>  id INT PRIMARY KEY,<br>  jname VARCHAR(20),<br>  description VARCHAR(50)<br>);<br><br>-- 添加4个职务<br>INSERT INTO job (id, jname, description) VALUES<br>(1, &#39;top&#39;, &#39;top&#39;),<br>(2, &#39;02&#39;, &#39;0202&#39;),<br>(3, &#39;03&#39;, &#39;0303&#39;),<br>(4, &#39;04&#39;, &#39;0404&#39;);<br>-- 员工表<br>CREATE TABLE emp (<br>  id INT PRIMARY KEY, -- 员工id<br>  ename VARCHAR(50), -- 员工姓名<br>  job_id INT, -- 职务id<br>  mgr INT , -- 上级领导<br>  joindate DATE, -- 入职日期<br>  salary DECIMAL(7,2), -- 工资<br>  bonus DECIMAL(7,2), -- 奖金<br>  dept_id INT, -- 所在部门编号<br>  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),<br>  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)<br>);<br><br>-- 添加员工<br>INSERT INTO   emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES <br>(1001,&#39;zhang01&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),<br>(1002,&#39;zhang02&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),<br>(1003,&#39;zhang03&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),<br>(1004,&#39;zhang04&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),<br>(1005,&#39;zhang05&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),<br>(1006,&#39;zhang06&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),<br>(1007,&#39;zhang07&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),<br>(1008,&#39;zhang08&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),<br>(1009,&#39;zhang09&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),<br>(1010,&#39;zhang10&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),<br>(1011,&#39;zhang11&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),<br>(1012,&#39;zhang12&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),<br>(1013,&#39;zhang13&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),<br>(1014,&#39;zhang14&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);<br>-- 工资等级表<br>CREATE TABLE salarygrade (<br>  grade INT PRIMARY KEY,   -- 级别<br>  losalary INT,  -- 最低工资<br>  hisalary INT -- 最高工资<br>);<br><br>-- 添加5个工资等级<br>INSERT INTO salarygrade(grade,losalary,hisalary) VALUES <br>(1,7000,12000),<br>(2,12010,14000),<br>(3,14010,20000),<br>(4,20010,30000),<br>(5,30010,99990);<br></code></pre></td></tr></table></figure><p>如果我们想查询工资最高的那个员工的姓名，可以拆解为两步；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询最高的工资:<br>select max(salary) from emp; # 结果为50000.0<br># 通过最高工资查询员工姓名:<br>select ename from emp where salary &#x3D; 50000.0; # 得到姓名为 zhang09<br># 那么我们能不能通过一步子查询实现呢?<br>select ename from emp where salary &#x3D; (select max(salary) from emp);<br>#实际上是可行的;把子查询的结果作为参数传递到另一个查询中;<br></code></pre></td></tr></table></figure><h4 id="7-4-2-子查询结果的不同情况"><a href="#7-4-2-子查询结果的不同情况" class="headerlink" title="7.4.2 子查询结果的不同情况"></a>7.4.2 子查询结果的不同情况</h4><p>1.子查询结果是<strong>单行单列</strong>的:子查询可以作为参数条件,使用运算符去判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求:我们想知道所有工资＞平均工资的姓名;<br>select<br>ename<br>from<br>emp<br>where<br>salary &gt; (select avg(salary) from emp);<br># 结果:<br>+---------+<br>| ename   |<br>+---------+<br>| zhang04 |<br>| zhang06 |<br>| zhang07 |<br>| zhang08 |<br>| zhang09 |<br>| zhang13 |<br>+---------+<br></code></pre></td></tr></table></figure><p>2.子查询结果是<strong>多行单列</strong>的:子查询可以作为参数条件,使用in来判断;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求:我们想知道coding和market部门的所有员工信息<br>select<br>*<br>from<br>emp<br>where<br>dept_id<br>in<br>(select id from dept where dname in (&#39;coding&#39;,&#39;market&#39;));<br># 结果:<br>+------+---------+--------+------+------------+----------+-------+---------+<br>| id   | ename   | job_id | mgr  | joindate   | salary   | bonus | dept_id |<br>+------+---------+--------+------+------------+----------+-------+---------+<br>| 1007 | zhang07 |      2 | 1009 | 2001-09-01 | 24500.00 |  NULL |      10 |<br>| 1009 | zhang09 |      1 | NULL | 2001-11-17 | 50000.00 |  NULL |      10 |<br>| 1014 | zhang14 |      4 | 1007 | 2002-01-23 | 13000.00 |  NULL |      10 |<br>| 1001 | zhang01 |      4 | 1004 | 2000-12-17 |  8000.00 |  NULL |      20 |<br>| 1004 | zhang04 |      2 | 1009 | 2001-04-02 | 29750.00 |  NULL |      20 |<br>| 1008 | zhang08 |      4 | 1004 | 2007-04-19 | 30000.00 |  NULL |      20 |<br>| 1011 | zhang11 |      4 | 1004 | 2007-05-23 | 11000.00 |  NULL |      20 |<br>| 1013 | zhang13 |      4 | 1004 | 2001-12-03 | 30000.00 |  NULL |      20 |<br>+------+---------+--------+------+------------+----------+-------+---------+<br></code></pre></td></tr></table></figure><p>3.子查询结果是<strong>多行多列</strong>的:子查询可以作为一张虚拟表参与查询;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求:我们想知道员工入职日期在2002-11-11日之后的员工信息和部门信息<br>select<br>*<br>from<br>dept t1,<br>(select * from emp where emp.&#96;joindate&#96;&gt;&#39;2002-11-11&#39;) t2<br>where<br>t1.id &#x3D; t2.dept_id;<br># 结果:<br>+----+--------+----------+------+---------+--------+------+------------+----------+-------+---------+<br>| id | dname  | loc      | id   | ename   | job_id | mgr  | joindate   | salary   | bonus | dept_id |<br>+----+--------+----------+------+---------+--------+------+------------+----------+-------+---------+<br>| 20 | market | shanghai | 1008 | zhang08 |      4 | 1004 | 2007-04-19 | 30000.00 |  NULL |      20 |<br>| 20 | market | shanghai | 1011 | zhang11 |      4 | 1004 | 2007-05-23 | 11000.00 |  NULL |      20 |<br>+----+--------+----------+------+---------+--------+------+------------+----------+-------+---------+<br># 也可以使用普通内连接查询:<br>select<br>*<br>from<br>emp t1,<br>dept t2<br>where<br>t1.dept_id &#x3D; t2.id<br>and<br>t1.joindate &gt;&#39;2002-11-11&#39;;<br></code></pre></td></tr></table></figure><h3 id="7-5-多表查询练习"><a href="#7-5-多表查询练习" class="headerlink" title="7.5 多表查询练习"></a>7.5 多表查询练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 案例数据库同7.4<br># 需求1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述<br>select<br>t1.id,<br>t1.ename,<br>t1.salary,<br>t2.jname,<br>t2.description<br>from<br>emp t1,<br>job t2<br>where<br>t1.job_id &#x3D; t2.id;<br># 结果1:<br>+------+---------+----------+-------+-------------+<br>| id   | ename   | salary   | jname | description |<br>+------+---------+----------+-------+-------------+<br>| 1009 | zhang09 | 50000.00 | top   | top         |<br>| 1004 | zhang04 | 29750.00 | 02    | 0202        |<br>| 1006 | zhang06 | 28500.00 | 02    | 0202        |<br>| 1007 | zhang07 | 24500.00 | 02    | 0202        |<br>| 1002 | zhang02 | 16000.00 | 03    | 0303        |<br>| 1003 | zhang03 | 12500.00 | 03    | 0303        |<br>| 1010 | zhang10 | 15000.00 | 03    | 0303        |<br>| 1001 | zhang01 |  8000.00 | 04    | 0404        |<br>| 1005 | zhang05 | 12500.00 | 04    | 0404        |<br>| 1008 | zhang08 | 30000.00 | 04    | 0404        |<br>| 1011 | zhang11 | 11000.00 | 04    | 0404        |<br>| 1012 | zhang12 |  9500.00 | 04    | 0404        |<br>| 1013 | zhang13 | 30000.00 | 04    | 0404        |<br>| 1014 | zhang14 | 13000.00 | 04    | 0404        |<br>+------+---------+----------+-------+-------------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求2:查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置<br>select<br>t1.id,<br>t1.ename,<br>t1.salary,<br>t2.jname,<br>t2.description,<br>t3.dname,<br>t3.loc<br>from<br>emp t1,<br>job t2,<br>dept t3<br>where<br>t1.job_id &#x3D; t2.id<br>and<br>t1.dept_id &#x3D; t3.id;<br># 结果2:<br>+------+---------+----------+-------+-------------+--------+-----------+<br>| id   | ename   | salary   | jname | description | dname  | loc       |<br>+------+---------+----------+-------+-------------+--------+-----------+<br>| 1009 | zhang09 | 50000.00 | top   | top         | coding | beijing   |<br>| 1007 | zhang07 | 24500.00 | 02    | 0202        | coding | beijing   |<br>| 1014 | zhang14 | 13000.00 | 04    | 0404        | coding | beijing   |<br>| 1004 | zhang04 | 29750.00 | 02    | 0202        | market | shanghai  |<br>| 1001 | zhang01 |  8000.00 | 04    | 0404        | market | shanghai  |<br>| 1008 | zhang08 | 30000.00 | 04    | 0404        | market | shanghai  |<br>| 1011 | zhang11 | 11000.00 | 04    | 0404        | market | shanghai  |<br>| 1013 | zhang13 | 30000.00 | 04    | 0404        | market | shanghai  |<br>| 1006 | zhang06 | 28500.00 | 02    | 0202        | sale   | guangzhou |<br>| 1002 | zhang02 | 16000.00 | 03    | 0303        | sale   | guangzhou |<br>| 1003 | zhang03 | 12500.00 | 03    | 0303        | sale   | guangzhou |<br>| 1010 | zhang10 | 15000.00 | 03    | 0303        | sale   | guangzhou |<br>| 1005 | zhang05 | 12500.00 | 04    | 0404        | sale   | guangzhou |<br>| 1012 | zhang12 |  9500.00 | 04    | 0404        | sale   | guangzhou |<br>+------+---------+----------+-------+-------------+--------+-----------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求3:查询员工姓名,工资,工资等级<br>select<br>t1.ename,<br>t1.salary,<br>t2.grade<br>from<br>emp t1,<br>salarygrade t2<br>where<br>t1.salary between t2.losalary and t2.hisalary;<br># 结果3:<br>+---------+----------+-------+<br>| ename   | salary   | grade |<br>+---------+----------+-------+<br>| zhang01 |  8000.00 |     1 |<br>| zhang02 | 16000.00 |     3 |<br>| zhang03 | 12500.00 |     2 |<br>| zhang04 | 29750.00 |     4 |<br>| zhang05 | 12500.00 |     2 |<br>| zhang06 | 28500.00 |     4 |<br>| zhang07 | 24500.00 |     4 |<br>| zhang08 | 30000.00 |     4 |<br>| zhang09 | 50000.00 |     5 |<br>| zhang10 | 15000.00 |     3 |<br>| zhang11 | 11000.00 |     1 |<br>| zhang12 |  9500.00 |     1 |<br>| zhang13 | 30000.00 |     4 |<br>| zhang14 | 13000.00 |     2 |<br>+---------+----------+-------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求4:查询出部门编号、部门名称、部门位置、部门人数<br>&#x2F;*<br>需求分析：<br>1.部门编号、名称、位置-dept表；部门人数-emp表<br>2.使用分组查询，按照emp的dept_id完成分组,之后使用count(id)聚合函数<br>3.使用子查询进行关联查询<br>*&#x2F;<br>select<br>t1.id,<br>t1.dname,<br>t1.loc,<br>t2.total<br>from<br>dept t1,<br>(select dept_id,count(id) total from emp group by dept_id) t2<br>where<br>t1.id &#x3D; t2.dept_id;<br># 结果4：<br>+----+--------+-----------+-------+<br>| id | dname  | loc       | total |<br>+----+--------+-----------+-------+<br>| 10 | coding | beijing   |     3 |<br>| 20 | market | shanghai  |     5 |<br>| 30 | sale   | guangzhou |     6 |<br>+----+--------+-----------+-------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 需求5:查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询<br>select<br>t1.ename,<br>t1.mgr,<br>t2.id,<br>t2.ename<br>from<br>emp t1<br>left outer join<br>emp t2 # 自关联可以两次使用表 起别名即可<br>on <br>t1.mgr &#x3D; t2.id;<br># 结果5:<br>+---------+------+------+---------+<br>| ename   | mgr  | id   | ename   |<br>+---------+------+------+---------+<br>| zhang01 | 1004 | 1004 | zhang04 |<br>| zhang02 | 1006 | 1006 | zhang06 |<br>| zhang03 | 1006 | 1006 | zhang06 |<br>| zhang04 | 1009 | 1009 | zhang09 |<br>| zhang05 | 1006 | 1006 | zhang06 |<br>| zhang06 | 1009 | 1009 | zhang09 |<br>| zhang07 | 1009 | 1009 | zhang09 |<br>| zhang08 | 1004 | 1004 | zhang04 |<br>| zhang09 | NULL | NULL | NULL    |<br>| zhang10 | 1006 | 1006 | zhang06 |<br>| zhang11 | 1004 | 1004 | zhang04 |<br>| zhang12 | 1006 | 1006 | zhang06 |<br>| zhang13 | 1004 | 1004 | zhang04 |<br>| zhang14 | 1007 | 1007 | zhang07 |<br>+---------+------+------+---------+<br></code></pre></td></tr></table></figure><h2 id="Charpter8-事务"><a href="#Charpter8-事务" class="headerlink" title="Charpter8. 事务"></a>Charpter8. 事务</h2><h3 id="8-1-基本概念及特性"><a href="#8-1-基本概念及特性" class="headerlink" title="8.1 基本概念及特性"></a>8.1 基本概念及特性</h3><ul><li><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p></li><li><p>四大特性:<strong>ACID,原子性(Atomicity)、一致性(Correspondence)、隔离<br>性(Isolation)、持久性(Durability)。</strong></p><p>   （1）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>   （2）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>   （3）隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。<br>   （4）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li></ul><h3 id="8-2-相关操作"><a href="#8-2-相关操作" class="headerlink" title="8.2 相关操作"></a>8.2 相关操作</h3><ul><li>开启事务:<code>start transaction;</code></li><li>回滚:<code>rollback;</code></li><li>提交:<code>commit;</code></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table account(<br>id int primary key auto_increment,<br>    name varchar(10),<br>    balance double<br>);<br>insert into account values(&#39;zhangsan&#39;,1000),(&#39;lisi&#39;,1000);<br># 假设张三给李四转账500元 先开启事务<br>start transaction;<br>update account set balance &#x3D; balance - 500 where name &#x3D; &#39;zhangsan&#39;;<br>update account set balance &#x3D; balance + 500 where name &#x3D; &#39;lisi&#39;;<br>#提交事务<br>commit;<br>#如果出现异常回滚事务:<br>rollback;<br></code></pre></td></tr></table></figure><h3 id="8-3-事务提交的两种方式"><a href="#8-3-事务提交的两种方式" class="headerlink" title="8.3 事务提交的两种方式"></a>8.3 事务提交的两种方式</h3><ul><li><p>自动提交:MySQL默认为自动提交，每次增删改语句会自动提交一次事务；</p></li><li><p>手动提交:Oracle默认为手动提交,需要先开启事务再提交</p></li><li><p>修改事务的默认提交方式</p><p>​    1.查询事务的默认提交方式: <code>select @@autocommit;</code> 1代表自动提交,0代表手动提交</p><p>​    2.修改默认提交方式:<code>set @@autocommit=0;</code></p></li></ul><h3 id="8-4-事务的隔离级别"><a href="#8-4-事务的隔离级别" class="headerlink" title="8.4 事务的隔离级别"></a>8.4 事务的隔离级别</h3><h4 id="8-4-1-可能存在的问题"><a href="#8-4-1-可能存在的问题" class="headerlink" title="8.4.1 可能存在的问题"></a>8.4.1 可能存在的问题</h4><ul><li><p>脏读:一个事务读取到另一个事务中没有提交的数据;</p><p>事例:老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析:实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p></li><li><p>不可重复读(虚读):在同一个事务中两次读取到的数据不一样;</p><p>事例:程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析:这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p></li><li><p>幻读:一个事务操作数据表中的所有记录,另一个事务添加了一条数据,第一个事务查询不到自己的修改;</p><p>事例:程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p></li></ul><h4 id="8-4-2-隔离级别"><a href="#8-4-2-隔离级别" class="headerlink" title="8.4.2 隔离级别"></a>8.4.2 隔离级别</h4><ul><li><p>Read uncommitted:一个事务可以读取另一个未提交事务的数据。</p><p>可能产生的问题:脏读、不可重复读、幻读;</p></li><li><p>Read committed:一个事务要等另一个事务提交后才能读取数据。</p><p>可能产生的问题:不可重复读、幻读;</p></li><li><p>Repeatable read:重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</p><p>可能产生的问题：幻读;</p></li><li><p>Serializable:串行化，是最高的事务隔离级别。可以解决幻读问题。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使w用。</p></li></ul><p>从上到下安全性递增，但执行效率递减。</p><h4 id="8-4-3-默认隔离级别与设置"><a href="#8-4-3-默认隔离级别与设置" class="headerlink" title="8.4.3 默认隔离级别与设置"></a>8.4.3 默认隔离级别与设置</h4><ul><li><p>大多数数据库默认的事务隔离级别是Read committed，比如SQL Server , Oracle。MySQL的默认隔离级别是Repeatable read。</p></li><li><p>设置默认隔离级别:</p><p>​    1.查询:<code>select @@tx_isolation;</code></p><p>​    2.设置:<code>set global transaction isolation level 级别字符串;</code></p></li></ul><p>//Refenences:<a href="https://blog.csdn.net/qq_33290787/article/details/51924963">事务的隔离级别</a></p>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>摘抄</title>
    <link href="/2021/02/08/%E6%91%98%E6%8A%84/"/>
    <url>/2021/02/08/%E6%91%98%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<p>Read More</p><a id="more"></a><ul><li><p>“在艺术上，靠变故、车祸，意外实现的悲剧都不是好的悲剧。真正好的悲剧是所有事情都是合逻辑的，所有人都是正常的，甚至是善良的，事情仍然无可挽回地缓缓滑向溃败，没有赢家，没有幸存者。”</p></li><li><p>“你讨厌母亲的圆滑市侩，但她也曾经像你一样憧憬过未来，你讨厌父亲的平庸，却不知道他也曾是个怀揣梦想的男孩。人生最大的悲哀在于:拿着爸妈提供的物质，学着他们不懂的知识，见识他们没见识过的世面，体验他们没体验过的人生，到头来却嫌弃他们如此的平庸笨拙。”</p></li><li><p>“如果你现在不觉得一年前的自己是个蠢货,那么说明你这一年里没学到什么东西”</p></li><li><p>“我慢慢明白了为什么我不快乐，因为我总是期待一个结果。 看一本书期待它让我变得深刻，吃饭游泳期待它让我一斤斤瘦下来，发一条短信期待它被回复，对别人好期待被回待以好，写一个故事说一个心情期待被关注被安慰，参加一个活动期待换来充实丰富的经历。这些预设的期待如果实现了，长舒一口气，如果没有实现呢，自怨自艾。 可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花，小时候不期待结果，小时候哭笑都不打折。”</p></li><li><p>“一个人想要变得更强 就必须要看清现在的自己<br>当你还是个弱者的时候 这很容易做到<br>可是当你在某方面变成了强者<br>就会被这短暂的强大蒙蔽双眼”</p></li><li><p>“当你接触的人越多层面越高你会发现<br>越高端越有教养的人大都相互支持抱团发展因为你好了大家都好<br>越低端层次越低的人越是喜欢诋毁嫉妒拆台鄙视<br>因为我不好我也不想让你好<br>所以影响一个人的首要因素是境界及思维和一群有同样格局和思维的人一起前行才是最重要的”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo博客部署遇到的一些问题及解决办法</title>
    <link href="/2021/02/01/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2021/02/01/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Read More</p><a id="more"></a><h2 id="关于Hexo博客部署遇到的一些问题及解决办法"><a href="#关于Hexo博客部署遇到的一些问题及解决办法" class="headerlink" title="关于Hexo博客部署遇到的一些问题及解决办法"></a>关于Hexo博客部署遇到的一些问题及解决办法</h2><h3 id="Spawn-failed"><a href="#Spawn-failed" class="headerlink" title="Spawn failed"></a>Spawn failed</h3><ul><li>使用hexo d后遇到了这种情况</li></ul><p><img src="https://s3.ax1x.com/2021/02/01/yebK1O.png" alt="代码"></p><p>经过了万能的百度后找到了解决办法</p><p>这种情况出现的原因是博客之前进行了多余的本地提交，导致跟git仓库中的不同步；</p><p>在**.deploy_git\.git\logs**（.git文件夹可能被隐藏，强制进入）中的HEAD文件（用万能的VSCode文本查看器）</p><p><img src="https://s3.ax1x.com/2021/02/01/yebQje.png" alt="HEAD"></p><p>对比github仓库里的最后提交时间</p><p><img src="https://s3.ax1x.com/2021/02/01/yebMcD.png" alt="github"></p><p>发现多了一个多余的本地提交，必须先返回到原来的状态才可</p><p>解决问题代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard commitId<br></code></pre></td></tr></table></figure><p>这里的commitId是HEAD中的每一行的第二段ID,找到最后提交的那个状态返回到该状态即可解决该问题;</p><h3 id="文章目录收缩错误"><a href="#文章目录收缩错误" class="headerlink" title="文章目录收缩错误"></a>文章目录收缩错误</h3><p>这里因为忘了截图所以没有图…</p><p>大概的问题是当时我的文章(markdown格式)用的是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">h1<br>h3<br>h4<br>h3<br>h4<br></code></pre></td></tr></table></figure><p>这时目录把我的第一个h3识别成了h2,把我的第一个h4识别成了h3,导致目录收缩错误,变得奇奇怪怪的;</p><p>经过查询后发现,原因可能是这种目录的检索最好是根据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">h1<br>h2<br>h3<br>h4<br>h5<br>h6<br></code></pre></td></tr></table></figure><p>这样有层次来的,越级可能会导致识别出错(之前有时候是没问题的);当我把第一个h1改成了h2后解决了问题;</p>]]></content>
    
    
    <categories>
      
      <category>Problem</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
