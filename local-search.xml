<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2021/02/10/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/02/10/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>MySQL相关知识:SQL语句,增删改查,范式,视图,事务,索引…</p><a id="more"></a><h1 id="MySQL-笔记（持续更新中）"><a href="#MySQL-笔记（持续更新中）" class="headerlink" title="MySQL 笔记（持续更新中）"></a>MySQL 笔记（持续更新中）</h1><h2 id="Charpter1-Introduction"><a href="#Charpter1-Introduction" class="headerlink" title="Charpter1. Introduction"></a>Charpter1. Introduction</h2><h3 id="1-1-SQL"><a href="#1-1-SQL" class="headerlink" title="1.1 SQL"></a>1.1 <strong>SQL</strong></h3><p>Structured Query Language(结构化查询语言)</p><h3 id="1-2-SQL通用语法"><a href="#1-2-SQL通用语法" class="headerlink" title="1.2 SQL通用语法"></a>1.2 SQL通用语法</h3><ul><li><p>MySQL中SQL语句不区分大小写,可以使用小写可读性略强,但是关键字建议使用大写;</p></li><li><p>SQL语句可以单行或多行书写,所有语句以分号结尾;</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>多行书写:有利于提高可读性,更清晰<br>*&#x2F;<br>mysql&gt; insert into student values<br>    -&gt; (15,&#39;zs&#39;,18),<br>    -&gt; (16,&#39;df&#39;,12),<br>    -&gt; (22,&#39;as&#39;,14);<br>&#x2F;*<br>单行书写<br>*&#x2F;<br>mysql&gt; insert into student values (15,&#39;zs&#39;,18),(16,&#39;df&#39;,12),(22,&#39;as&#39;,14);<br></code></pre></td></tr></table></figure></li><li><p>注释:</p><ul><li>单行注释: 使用 – 注释内容 或 # 注释内容(MySQL中特有#)</li><li>多行注释:类似于Java,使用/* 注释内容 */</li></ul></li></ul><h3 id="1-3-MySQL的基本命令"><a href="#1-3-MySQL的基本命令" class="headerlink" title="1.3 MySQL的基本命令"></a>1.3 MySQL的基本命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql #启动mysql服务<br><span class="hljs-built_in">net</span> stop mysql  #关闭mysql服务<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>关于mysql登陆的方式<br>第一种直接输入密码,密码可视,有泄漏风险;<br>第二种输入密码时隐藏,相对比较安全;<br>第三种用于登陆指定主机的MySQL服务器;<br>*&#x2F;<br>mysql -u 用户名 -p 密码;<br>mysql -u 用户名 -p; # 之后会提示让你输入密码<br>mysql -h 需要登陆的ip地址 -u 用户名 -p 密码;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit;# 退出mysql<br>quit;# 退出mysql<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">\c # 退出当前语句<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -u 用户名 -p 密码 数据库名称 &gt; 保存的路径 # 备份数据库<br>&#x2F;* 还原数据库:<br>1.登陆数据库<br>2.创建数据库<br>3.使用数据库<br>4.执行备份文件:<br>*&#x2F;<br>source 文件路径;<br></code></pre></td></tr></table></figure><h2 id="Charpter2-Data-Definition-Language"><a href="#Charpter2-Data-Definition-Language" class="headerlink" title="Charpter2. Data Definition Language"></a>Charpter2. Data Definition Language</h2><h3 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h3><h4 id="2-1-1-Create"><a href="#2-1-1-Create" class="headerlink" title="2.1.1 Create"></a>2.1.1 Create</h4><ul><li><p>创建数据库:<code>create database 数据库名称;</code></p></li><li><p>先判断是否存在再创建数据库:<code>create database if not exists 数据库名称;</code></p></li><li><p>创建数据库并指定字符编码:<code> create database 数据库名称 charset=字符集名;</code></p></li></ul><h4 id="2-1-2-Retrieve"><a href="#2-1-2-Retrieve" class="headerlink" title="2.1.2 Retrieve"></a>2.1.2 Retrieve</h4><ul><li>查询所有数据库的名称:<code> show databases;</code></li><li>查询某个数据库的创建语句:<code>show create database 数据库名称;</code></li></ul><h4 id="2-1-3-Update"><a href="#2-1-3-Update" class="headerlink" title="2.1.3 Update"></a>2.1.3 Update</h4><ul><li>修改数据库的字符集:<code> alter database 数据库名称 charset=字符集名;</code></li></ul><h4 id="2-1-4-Delete"><a href="#2-1-4-Delete" class="headerlink" title="2.1.4 Delete"></a>2.1.4 Delete</h4><ul><li>删除数据库:<code>drop database 数据库名称;</code></li><li>先判断是否存在再删除数据库:<code>drop database if exist 数据库名称;</code></li></ul><h4 id="2-1-5-Use"><a href="#2-1-5-Use" class="headerlink" title="2.1.5 Use"></a>2.1.5 Use</h4><ul><li>使用数据库:<code>use 数据库名称;</code></li><li>查询当前正在使用的数据库:<code>select database();</code></li></ul><h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><h4 id="2-2-1-整数型"><a href="#2-2-1-整数型" class="headerlink" title="2.2.1 整数型"></a>2.2.1 整数型</h4><table><thead><tr><th>类型</th><th>字节大小</th><th>有符号范围</th><th>无符号范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-2^63~2^63-1</td><td>0~2^64</td></tr></tbody></table><h4 id="2-2-2-浮点型"><a href="#2-2-2-浮点型" class="headerlink" title="2.2.2 浮点型"></a>2.2.2 浮点型</h4><ul><li><p>FLOAT(M,D) – M:可以存储的位数,D:小数点后面的位数。</p></li><li><p>DOUBLE(M,D) – M:可以存储的位数,D:小数点后面的位数。</p></li><li><p>对于精度要求更高的可以使用定点型：DECIMAL(M,D)。</p></li></ul><h4 id="2-2-3-字符串类型"><a href="#2-2-3-字符串类型" class="headerlink" title="2.2.3 字符串类型"></a>2.2.3 字符串类型</h4><ul><li>CHAR(M):一个固定长度的字符串，在存储时始终用空格填充指定长度。存储时占用M个字节。CHAR的查询效率高于VARCHAR，对于字符串长度确定的字段可以使用CHAR。</li><li>VARCHAR(M):一个可变长度的字符串，用的最多。存储时占用L+1（L为字符串的实际长度）个字节。</li></ul><h4 id="2-2-4-时间日期类型"><a href="#2-2-4-时间日期类型" class="headerlink" title="2.2.4 时间日期类型"></a>2.2.4 时间日期类型</h4><ul><li><p>TIME：D HH:MM:SS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Create table timeTest(<br>a Time<br>);<br>Insert into timeTest values(&#39;13:45:21&#39;);<br>Insert into timeTest values(&#39;-3 13:45:21&#39;); --&#39;-3&#39;表示间隔三天<br>Insert into timeTest values(&#39;13:45&#39;); --有冒号从小时开始<br>Insert into timeTest values(&#39;114514&#39;); --没有冒号也没有天数 从秒开始<br></code></pre></td></tr></table></figure></li><li><p>DATETIME:时间和日期的组合 YYYY-MM-DD HH:MM:SS</p></li><li><p>TIMESTAMP:类似于DATETIME，但是defalut为本机时间CURRENT_TIMESTAMP;</p></li></ul><h4 id="2-2-5-数据类型约束"><a href="#2-2-5-数据类型约束" class="headerlink" title="2.2.5 数据类型约束"></a>2.2.5 数据类型约束</h4><ul><li>UNSIGNED：无符号</li><li>ZEROFILL：零填充,长度不够时以0填充到指定长度,字段自动为UNSIGNED</li><li>NOT NULL：非空约束</li><li>DEFAULT：默认值</li><li>AUTO_INCREMENT：自动增长</li><li>PRIMARY_KEY：主键</li></ul><h3 id="2-3-表操作"><a href="#2-3-表操作" class="headerlink" title="2.3 表操作"></a>2.3 表操作</h3><h4 id="2-3-1-Create"><a href="#2-3-1-Create" class="headerlink" title="2.3.1 Create"></a>2.3.1 Create</h4><ul><li><p>创建表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>分行写可读性更强<br>*&#x2F;<br>create table 表名称(<br>字段1 数据类型1,<br>字段2 数据类型2,<br>字段3 数据类型3,<br>...<br>字段n 数据类型n<br>);<br></code></pre></td></tr></table></figure></li><li><p>复制表：<code>create table 表名 like 被复制的表名;</code></p></li></ul><h4 id="2-3-2-Retrieve"><a href="#2-3-2-Retrieve" class="headerlink" title="2.3.2 Retrieve"></a>2.3.2 Retrieve</h4><ul><li>查询某个数据库中的所有表:<code>show tables;</code></li><li>查询某个表的结构:<code>desc 表名;</code></li></ul><h4 id="2-3-3-Update"><a href="#2-3-3-Update" class="headerlink" title="2.3.3 Update"></a>2.3.3 Update</h4><ul><li>修改表名:<code>alter table 表名 rename to 新表名;</code></li><li>修改表的字符集:<code>alter table 表名 charset=字符集;</code></li><li>添加一列:<code>alter table 表名 add 列名 数据类型;</code></li><li>修改列名称属性:<code>alter table 表名 change 列名 新列名 数据类型;</code></li><li>修改列数据类型:<code>alter table 表名 motify 列名 新数据类型;</code></li><li>删除列:<code>alter table 表名 drop 列名;</code></li></ul><h4 id="2-3-4-Delete"><a href="#2-3-4-Delete" class="headerlink" title="2.3.4 Delete"></a>2.3.4 Delete</h4><ul><li>删除表：<code>drop table 表名;</code></li><li>先检查表是否存在再删除:<code>drop table if exists 表名;</code></li></ul><h2 id="Charpter3-Data-Manipulation-Language"><a href="#Charpter3-Data-Manipulation-Language" class="headerlink" title="Charpter3. Data Manipulation Language"></a>Charpter3. Data Manipulation Language</h2><h3 id="3-1-添加数据-增"><a href="#3-1-添加数据-增" class="headerlink" title="3.1 添加数据(增)"></a>3.1 添加数据(增)</h3><ul><li><p>语法:<code>insert into 表名 (列名1,列名2,...,列名n) values(值1,值2,...值n);</code></p></li><li><p>增加多个数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values<br>    -&gt; (值1,值2,...值n),<br>    -&gt; (值1*,值2*,...值n*),<br>    -&gt; ...<br>    -&gt; (值1**,值2**,...值n**)<br>;<br></code></pre></td></tr></table></figure></li><li><p>注意:</p><p>​    1.列名和表名一定要一一对应;</p><p>​    2.列名可以省略可以为空或者有默认值的字段;</p><p>​    3.可以省略列名,默认给所有列添加值,那么值不一定漏了或者对应错了;</p><p>​    4.除了数字类型,其他的类型均需要加引号(单双均可).</p></li></ul><h3 id="3-2-删除数据-删"><a href="#3-2-删除数据-删" class="headerlink" title="3.2 删除数据(删)"></a>3.2 删除数据(删)</h3><ul><li><p>语法:<code>delete from 表名 [where 条件];</code></p></li><li><p>注意:如果不加条件,会删除表中所有的记录</p></li><li><p>删除所有数据的两种方法:</p><p>​    1.<code>delete from 表名;</code> –依次删除表中所有数据,表中有多少数据就要执行多少次,效率低,同时如果有auto_imcrement字段,之前自增的记录仍在;</p><p>​    2.<code>truncate table 表名;</code> –直接删除该表,同时创建一个空的该表;效率高;</p></li></ul><h3 id="3-3-修改数据-改"><a href="#3-3-修改数据-改" class="headerlink" title="3.3 修改数据(改)"></a>3.3 修改数据(改)</h3><ul><li><p>语法:<code>update 表名 set 列名1=值1 , 列名2=值2 , ... [where 条件];</code></p></li><li><p>注意:如果不加条件,会对表中所有的数据进行更改</p></li></ul><h2 id="Charpter4-Data-Query-Language"><a href="#Charpter4-Data-Query-Language" class="headerlink" title="Charpter4. Data Query Language"></a>Charpter4. Data Query Language</h2><h3 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a>4.1 基本语法</h3><ul><li><pre><code class="mysql">select    字段列表from    表名列表where    条件列表group by    分组列表having    分组后的操作order by    排序limit    分页限定<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sas"><br>### 4.2 基础查询<br><br>1.多个字段的查询:`<span class="hljs-meta">select</span> 字段名1,字段名2..,字段名n <span class="hljs-meta">from</span> 表名;`<br><br>2.去重查询:使用<span class="hljs-meta">distinct</span> 关键字(提供的字段完全一样才去重)<br><br>eg:`<span class="hljs-meta">select</span> <span class="hljs-meta">distinct</span> 字段名1,字段名2..,字段名n <span class="hljs-meta">from</span> 表名;`<br><br>3.关于<span class="hljs-meta">NULL</span>的处理:如果有<span class="hljs-meta">NULL</span>参与四则运算,计算结果都为<span class="hljs-meta">NULL</span>；<br><br><span class="hljs-comment">* ifnull(字段名,替换值) 来代替该字段;</span>如果该字段为<span class="hljs-meta">NULL</span>,则替换为所提供的替换值;<br><br>4.计算:可以直接使用四则运算计算某些列的值<br><br>eg:如果说有test1,test2两个字段,那么我们可以<br><br>```mysql<br><span class="hljs-meta">select</span> test1 + ifnull(test2,0) <span class="hljs-meta">as</span> sum <span class="hljs-meta">from</span> testScore;<br></code></pre></td></tr></table></figure>### 4.3 条件查询</code></pre></li></ul><h4 id="4-3-1-运算符"><a href="#4-3-1-运算符" class="headerlink" title="4.3.1 运算符"></a>4.3.1 运算符</h4><ul><li><p><code>&gt;</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>=</code> <code>&lt;&gt;</code> –MySQL中使用=表示==等于,使用&lt;&gt;表示!=不等于</p></li><li><p><code>between...and</code> 值在某个区间内</p></li><li><p><code>in(set)</code> 值在某个集合内</p></li><li><p><code> is null</code> 如果值为NULL(不能直接用=来判定)</p></li><li><p><code>and</code> 和 <code>or</code> 或 <code>not</code>非</p></li><li><p><code>like</code>模糊查询:</p><p>占位符: <code>_</code>:单个任意字符;<code>%</code>多个任意字符(可以为0个)</p></li></ul><h4 id="4-3-2-Example"><a href="#4-3-2-Example" class="headerlink" title="4.3.2 Example"></a>4.3.2 Example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where age&gt;18;<br>select * from student where age&lt;&gt;18; -- 查询年龄不等于18岁的值<br>select * from student where age&gt;18 and age&lt;30;<br>select * from student where age between 18 and 30; -- 两种方法结果一样<br>select * from student where age in (18,20,26); -- 查询年龄为18或20或26岁的字段<br>select * from student where mathScore is NULL; -- 查询数学成绩为NULL的字段<br>select * from student where mathScore is NOT NULL; -- 查询数学成绩不为NULL的字段<br>select * from student where name like &#39;张%&#39;; -- 查询所有姓张的字段<br>select * from student where name like &#39;_家%&#39;; -- 查询第二个字为家的字段<br>select * from student where name like &#39;%家%&#39;; -- 查询姓名中含有家字的字段<br>select * from student where name like &#39;__&#39;; -- 查询姓名为两个字的字段<br></code></pre></td></tr></table></figure><h3 id="4-4-排序查询"><a href="#4-4-排序查询" class="headerlink" title="4.4 排序查询"></a>4.4 排序查询</h3><ul><li><p>语法：<code>order by 排序子段1 排序方式1, ... , 排序字段n 排序方式n</code></p></li><li><p>排序方式：</p><p>​    ASC：升序,默认</p><p>​    DESC：降序</p></li><li><p>注意：如果有多个排序条件，按顺序为第n条件，先判断靠前的条件；</p></li></ul><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student order by englishScore; -- 按英语成绩升序排序<br>select * from student order by englishScore DESC,mathScore DESC; -- 按英语成绩降序排列,如果英语成绩相同,按数学成绩降序排列;<br></code></pre></td></tr></table></figure><h3 id="4-5-聚合函数"><a href="#4-5-聚合函数" class="headerlink" title="4.5 聚合函数"></a>4.5 聚合函数</h3><ul><li><p>将一列数据作为一个整体,进行纵向的计算</p></li><li><p>常用聚合函数</p><p>​    1.max/min():计算最大最小值</p><p>​    2.sum():计算和</p><p>​    3.avg():计算平均值</p><p>​    4.count():计算数据的条数(一般选择主键)</p></li><li><p>注意：聚合函数的计算自动舍弃NULL值,可以使用ifnull函数来解决;</p></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select avg(mathScore) from student; -- 计算数学成绩的平均值<br>select count(id) from student; -- 计算有多少学生<br></code></pre></td></tr></table></figure><h3 id="4-6-分组查询"><a href="#4-6-分组查询" class="headerlink" title="4.6 分组查询"></a>4.6 分组查询</h3><ul><li><p>语法:<code>group by 分组依据字段</code></p></li><li><p>限定:where 和 having</p><p>​    1.where:在分组前进行限定,如果不满足条件则不参与分组,where后不能跟聚合函数;</p><p>​    2.having:在分组后进行限定,如果不满足条件则会被舍弃不会显示在查询结果中,having后可以跟聚合函数;</p></li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex,AVG(mathScore) from student group by sex; -- 依据性别分组,分别查询男生和女生的数学平均分;<br>select sex,AVG(mathScore) from student where mathScore &gt; 80 group by sex; -- 只统计数学成绩＞80分的数据<br>select sex,AVG(mathScore),count(id) as 人数 from student group by sex having 人数 &gt; 5; -- 只统计分组后人数＞5的数据<br></code></pre></td></tr></table></figure><h3 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h3><ul><li>语法:<code>limit 开始的索引,每页查询的条数;</code>(注意索引是从0开始)</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student limit 0,3; -- 第1页 前三个数据<br>select * from student limit 3,3; -- 第2页<br>select * from student limit 6,3; -- 第3页<br></code></pre></td></tr></table></figure><h2 id="Charpter5-约束"><a href="#Charpter5-约束" class="headerlink" title="Charpter5. 约束"></a>Charpter5. 约束</h2><h3 id="5-1-非空约束"><a href="#5-1-非空约束" class="headerlink" title="5.1 非空约束"></a>5.1 非空约束</h3><ul><li><p>关键字:<code>not null</code> 即值不能为NULL</p></li><li><p>具体使用:</p><p>​    1.创建字段时加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int,<br>name varchar(20) not null -- name值必须为非空<br>)<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加非空约束</p><p><code>alter table student modify name varchar(20) not null;</code></p><p>​    3.删除非空约束</p><p><code>alter table student modify name varchar(20);</code></p></li></ul><h3 id="5-2-主键约束"><a href="#5-2-主键约束" class="headerlink" title="5.2 主键约束"></a>5.2 主键约束</h3><ul><li><p>关键字:<code>Primary Key</code> 非空且唯一</p></li><li><p>具体使用:</p><p>​    1.创建字段时加约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key, -- id值为主键,非空且唯一<br>name varchar(20) not null <br>)<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加主键约束</p><p><code>alter table student motify id int primary key;</code></p><p>​    3.删除主键</p><p><code>alter table student drop primary key</code> # 注意:不能直接使用motify来删除主键,必须drop primary key;</p></li><li><p>auto_increment(自动增长):对数值类型进行值的自动增长;</p><p>实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment, -- id值为主键,非空且唯一,一般对主键使用自动增长<br>name varchar(20) not null <br>)<br></code></pre></td></tr></table></figure><p>注意:</p><p>自动增长实际上是根据上一行数据的自动增长字段+1;比如对于id=1,id=2,然后自己设置一个id=9,那么如果使用自动增长下一个id则应该为10;</p></li></ul><h3 id="5-3-唯一约束"><a href="#5-3-唯一约束" class="headerlink" title="5.3 唯一约束"></a>5.3 唯一约束</h3><ul><li><p>关键字:<code>unique</code> 即使用unique后该字段的值不能重复出现</p></li><li><p>具体使用:</p><p>​    1.创建字段时添加唯一约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment,<br>    phoneNumber varchar(40) unique -- 添加了唯一约束 每行数据的phoneNumber不能相同<br>)<br></code></pre></td></tr></table></figure><p>​    2.创建后再添加唯一约束</p><p><code>alter table student motify phoneNumber varchar(40) unique;</code></p><p>​    3.删除唯一约束</p><p><code>alter table student drop index phoneNumber;</code> # 必须使用drop index 删除索引 不能直接使用modify;</p></li><li><p>注意:唯一约束中可以存在多个NULL,每个NULL值默认为不相等;</p></li></ul><h3 id="5-4-外键约束"><a href="#5-4-外键约束" class="headerlink" title="5.4 外键约束"></a>5.4 外键约束</h3><ul><li><p>关键字:<code>foreign key</code> 让表与表之间的某些字段产生关系,确保数据的正确性;</p></li><li><p>具体使用</p><p>​    1.创建字段时添加外键</p><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>....<br>外键列<br>constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table employee(<br>id int primary key auto_increment,<br>department_id int,<br>    constraint depid foreign key (department_id) references department(id)<br>);<br>create table department(<br>id int primary key auto_increment,<br>    address varchar(20),<br>    career varchar(20)<br>);<br></code></pre></td></tr></table></figure><p>​    2.创建表后再添加外键</p><p><code>alter table 表明 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称);</code></p><p>​    3.删除外键</p><p><code>alter table 表名 drop foreign key 外键名称;</code></p></li><li><p>级联操作:通过级联操作可以控制改变一张表的数据同时改变与之关联表的数据;</p><p>​    1.分类:级联更新 On update cascade</p><p>​                级联删除 On delete cascade</p><p>​    2.使用:</p><p>​        <code>alter table 表明 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) On update cascade On delete cascade;</code></p></li></ul><h2 id="Charpter6-数据库设计与范式"><a href="#Charpter6-数据库设计与范式" class="headerlink" title="Charpter6. 数据库设计与范式"></a>Charpter6. 数据库设计与范式</h2><h3 id="6-1-多表关系"><a href="#6-1-多表关系" class="headerlink" title="6.1 多表关系"></a>6.1 多表关系</h3><h4 id="6-1-1-分类"><a href="#6-1-1-分类" class="headerlink" title="6.1.1 分类"></a>6.1.1 分类</h4><ul><li><p>一对一:eg一个人和他的身份证一一对应</p></li><li><p>一对多(多对一):eg一个班级有多个学生,一个学生只能对应一个班级;</p></li><li><p>多对多:eg一个学生可以选择很多门课程,一个课程也可以被很多个学生选择;</p></li></ul><h4 id="6-1-2-实现"><a href="#6-1-2-实现" class="headerlink" title="6.1.2 实现"></a>6.1.2 实现</h4><ul><li><p>一对多:在多的一方建立外键,指向一的那方的主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table class(<br>    id int unique primary key,<br>    address varchar(20)<br>);<br>create table student(<br>id int primary key auto_increment,<br>    class_id int,<br>    constraint classid foreign key (class_id) references class(id)<br>);<br></code></pre></td></tr></table></figure></li><li><p>多对多:多对多关系的实现需要借助第三张中间表，中间表至少包含两个字段，作为第三张表的外键分别指向两张表的主键;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>id int primary key auto_increment,<br>    name varchar(20),<br>    address varchar(35),<br>    sex varchar(5)<br>);<br>create table course(<br>id int primary key auto_increment,<br>    course_name varchar(10),<br>    introduction varchar(100)<br>);<br>create table choice_for_course(<br>stu_id int,<br>    course_id int,<br>    constraint stuid foreign key (stu_id) references student(id),<br>    constraint courseid foreign key (course_id) references course(id)<br>);<br></code></pre></td></tr></table></figure></li><li><p>一对一:可以在任意一方添加<strong>唯一</strong>外键指向另一方主键/在同一张表中使用</p></li></ul><h3 id="6-2-范式"><a href="#6-2-范式" class="headerlink" title="6.2 范式"></a>6.2 范式</h3><h4 id="6-2-1-一些基本概念"><a href="#6-2-1-一些基本概念" class="headerlink" title="6.2.1 一些基本概念"></a>6.2.1 一些基本概念</h4><ul><li><p>函数依赖：A–&gt;B 如果通过A属性(属性组)的值,可以唯一确定B属性的值,则称B依赖于A;</p><p>eg:通过学号我们可以唯一确定姓名;通过学号和课程名可以唯一确定该同学的成绩;</p></li><li><p>完全函数依赖:A–&gt;B 如果A是一个属性组,那么确定B属性值需要依赖于A属性组中所有的属性值;</p><p>eg:想要得知课程成绩必须知道学号和课程名,缺一不可;</p></li><li><p>部分函数依赖:A–&gt;B 如果A是一个属性组,那么确定B属性值只需要依赖于A属性组中部分的属性值;</p></li><li><p>传递函数依赖:A–&gt;B B–&gt;C 如果通过A属性(属性组)的值可以唯一确定B属性的值,在通过B属性(属性组)的值可以唯一确定C属性的值,则称C传递依赖于A;</p></li></ul><ul><li>码:如果在一张表中,一个属性(属性组)被其他所有属性完全依赖,则称为该属性为该表的码;</li><li>主属性:码属性中的所有属性;</li></ul><h4 id="6-2-2-数据库第一范式"><a href="#6-2-2-数据库第一范式" class="headerlink" title="6.2.2 数据库第一范式"></a>6.2.2 数据库第一范式</h4><ul><li><p>表述:每一列都是不可分割的原子项;</p><p>eg:<img src="C:/Users/76168/AppData/Roaming/Typora/typora-user-images/image-20210213232431510.png" alt="example1"></p></li></ul><p>在该表中，系可以分割为系名和系主任，违背了第一范式。修改:</p><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>99</td></tr></tbody></table><h4 id="6-2-3-数据库第二范式"><a href="#6-2-3-数据库第二范式" class="headerlink" title="6.2.3 数据库第二范式"></a>6.2.3 数据库第二范式</h4><p>首先,我们来看看第一范式汇总存在的问题:</p><p>1.有过多的数据冗余,比如张无忌,经济系,张三丰,出现次数过多;</p><p>2.在数据添加中存在问题,比如我们想新增一个系或者系主任,没有学号姓名等数据无法添加;</p><p>3.在数据删除中存在问题,比如张无忌同学毕业了,那么他的数据会被删除,导致系的信息也被删除了;</p><p>那么我们来引出数据库第二范式</p><ul><li>表述:<strong>在第一范式的基础上</strong>,非码属性必须完全依赖于码属性(在第一范式的基础上消除非主属性对主码的部分函数依赖)</li></ul><p>首先我们得确定该表的码属性,显然为学号和课程名称,非码属性为姓名,系名,系主任,分数;那么哪些非码属性不完全依赖于码属性呢,首先就是姓名,姓名不需要通过课程名确定,然后系,系主任也同理,只有分数是完全依赖于码属性;那么我们就先按这个思想分成两个表:</p><table><thead><tr><th>学号</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>大学英语</td><td>99</td></tr></tbody></table><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td></tr></tbody></table><p>第二个新表中,码属性为学号,姓名,系名,系主任都由学号唯一确定,完全依赖于码属性;</p><h4 id="6-2-4-数据库第三范式"><a href="#6-2-4-数据库第三范式" class="headerlink" title="6.2.4 数据库第三范式"></a>6.2.4 数据库第三范式</h4><p>那么满足第二范式就一定没有问题吗?我们再来看看之前的问题</p><p>比如此时我们需要新办一个系或者增加一个系主任,以及同学毕业问题,问题还未解决.</p><p>那么我们来引入数据库第三范式:</p><ul><li>表述:<strong>在数据库第二范式的基础上</strong>,任何非主属性不依赖于其他非主属性(在第二范式的基础上消除传递依赖);</li></ul><p>我们看看第二个新表中,非主属性为姓名,系名,系主任,(别忘了有可能有重名现象),我们发现,系主任这个是完全依赖于系名的,一个系只有一个系主任,那么即系主任传递依赖于学号,我们要消除这种传递依赖的情况:</p><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td></tr></tbody></table><table><thead><tr><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>经济系</td><td>张三丰</td></tr><tr><td>法律系</td><td>任我行</td></tr></tbody></table><p>这样我们就满足了数据库第三范式;</p><p>满足数据库第一第二第三范式的设计相对较合理;</p>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>摘抄</title>
    <link href="/2021/02/08/%E6%91%98%E6%8A%84/"/>
    <url>/2021/02/08/%E6%91%98%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<p>Read More</p><a id="more"></a><ul><li><p>“在艺术上，靠变故、车祸，意外实现的悲剧都不是好的悲剧。真正好的悲剧是所有事情都是合逻辑的，所有人都是正常的，甚至是善良的，事情仍然无可挽回地缓缓滑向溃败，没有赢家，没有幸存者。”</p></li><li><p>“你讨厌母亲的圆滑市侩，但她也曾经像你一样憧憬过未来，你讨厌父亲的平庸，却不知道他也曾是个怀揣梦想的男孩。人生最大的悲哀在于:拿着爸妈提供的物质，学着他们不懂的知识，见识他们没见识过的世面，体验他们没体验过的人生，到头来却嫌弃他们如此的平庸笨拙。”</p></li><li><p>“如果你现在不觉得一年前的自己是个蠢货,那么说明你这一年里没学到什么东西”</p></li><li><p>“我慢慢明白了为什么我不快乐，因为我总是期待一个结果。 看一本书期待它让我变得深刻，吃饭游泳期待它让我一斤斤瘦下来，发一条短信期待它被回复，对别人好期待被回待以好，写一个故事说一个心情期待被关注被安慰，参加一个活动期待换来充实丰富的经历。这些预设的期待如果实现了，长舒一口气，如果没有实现呢，自怨自艾。 可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花，小时候不期待结果，小时候哭笑都不打折。”</p></li><li><p>“一个人想要变得更强 就必须要看清现在的自己<br>当你还是个弱者的时候 这很容易做到<br>可是当你在某方面变成了强者<br>就会被这短暂的强大蒙蔽双眼”</p></li><li><p>“当你接触的人越多层面越高你会发现<br>越高端越有教养的人大都相互支持抱团发展因为你好了大家都好<br>越低端层次越低的人越是喜欢诋毁嫉妒拆台鄙视<br>因为我不好我也不想让你好<br>所以影响一个人的首要因素是境界及思维和一群有同样格局和思维的人一起前行才是最重要的”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo博客部署遇到的一些问题及解决办法</title>
    <link href="/2021/02/01/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2021/02/01/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Read More</p><a id="more"></a><h2 id="关于Hexo博客部署遇到的一些问题及解决办法"><a href="#关于Hexo博客部署遇到的一些问题及解决办法" class="headerlink" title="关于Hexo博客部署遇到的一些问题及解决办法"></a>关于Hexo博客部署遇到的一些问题及解决办法</h2><h3 id="Spawn-failed"><a href="#Spawn-failed" class="headerlink" title="Spawn failed"></a>Spawn failed</h3><ul><li>使用hexo d后遇到了这种情况</li></ul><p><img src="https://s3.ax1x.com/2021/02/01/yebK1O.png" alt="代码"></p><p>经过了万能的百度后找到了解决办法</p><p>这种情况出现的原因是博客之前进行了多余的本地提交，导致跟git仓库中的不同步；</p><p>在**.deploy_git\.git\logs**（.git文件夹可能被隐藏，强制进入）中的HEAD文件（用万能的VSCode文本查看器）</p><p><img src="https://s3.ax1x.com/2021/02/01/yebQje.png" alt="HEAD"></p><p>对比github仓库里的最后提交时间</p><p><img src="https://s3.ax1x.com/2021/02/01/yebMcD.png" alt="github"></p><p>发现多了一个多余的本地提交，必须先返回到原来的状态才可</p><p>解决问题代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard commitId<br></code></pre></td></tr></table></figure><p>这里的commitId是HEAD中的每一行的第二段ID,找到最后提交的那个状态返回到该状态即可解决该问题;</p><h3 id="文章目录收缩错误"><a href="#文章目录收缩错误" class="headerlink" title="文章目录收缩错误"></a>文章目录收缩错误</h3><p>这里因为忘了截图所以没有图…</p><p>大概的问题是当时我的文章(markdown格式)用的是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">h1<br>h3<br>h4<br>h3<br>h4<br></code></pre></td></tr></table></figure><p>这时目录把我的第一个h3识别成了h2,把我的第一个h4识别成了h3,导致目录收缩错误,变得奇奇怪怪的;</p><p>经过查询后发现,原因可能是这种目录的检索最好是根据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">h1<br>h2<br>h3<br>h4<br>h5<br>h6<br></code></pre></td></tr></table></figure><p>这样有层次来的,越级可能会导致识别出错(之前有时候是没问题的);当我把第一个h1改成了h2后解决了问题;</p>]]></content>
    
    
    <categories>
      
      <category>Problem</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE-从入门到入秃</title>
    <link href="/2021/01/15/JavaSE-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A7%83/"/>
    <url>/2021/01/15/JavaSE-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%A7%83/</url>
    
    <content type="html"><![CDATA[<p>JavaSE知识:面向对象,封装,继承,多态,抽象类和接口,匿名内部类,lambda表达式,泛型,包装类,异常处理机制,Collection,Map,反射,多线程,锁,IO流,NIO,函数式接口,JVM…</p><a id="more"></a><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="JavaSE-从入门到入秃（持续更新中）"><a href="#JavaSE-从入门到入秃（持续更新中）" class="headerlink" title="JavaSE-从入门到入秃（持续更新中）"></a>JavaSE-从入门到入秃（持续更新中）</h2><h3 id="Charpter-I-Introduction"><a href="#Charpter-I-Introduction" class="headerlink" title="Charpter I. Introduction"></a>Charpter I. Introduction</h3><hr><h4 id="1-1-Java具有可移植性"><a href="#1-1-Java具有可移植性" class="headerlink" title="1.1 Java具有可移植性"></a>1.1 Java具有可移植性</h4><p>Java的数据类型具有固定的大小,同时二进制数据以固定的格式进行存储和传输。</p><p>而C/C++中,int 可能是 16 位整数、 32 位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。</p><h4 id="1-2-常见Java术语"><a href="#1-2-常见Java术语" class="headerlink" title="1.2 常见Java术语"></a>1.2 常见Java术语</h4><p><img src="https://s3.ax1x.com/2021/01/26/sX21XD.png" alt="常见Java术语" title="常见Java术语"></p><h4 id="1-3-Java的一些规范"><a href="#1-3-Java的一些规范" class="headerlink" title="1.3 Java的一些规范"></a>1.3 Java的一些规范</h4><p>Java区分大小写;</p><p>Java变量/类的命名应遵循驼峰命名法;具体参见孤尽老师的《<em>阿里巴巴Java开发手册</em>》</p><p>源代码的文件名必须与公共类的名字相同;</p><p>一般不在一行中声明多个变量，逐一声明变量可以提高程序的可读性;</p><h4 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h4><p>类注释：以/** 为开始 */为结束</p><p>行注释：//或者/* */</p><p>方法注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*@param:变量描述</span><br><span class="hljs-comment">*@return:描述</span><br><span class="hljs-comment">*@throws:类描述</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h4><p>Java是强类型语言,变量必须声明类型;(JavaScript是弱类型语言,直接用var声明变量,同时具有弱类型语言的===判断全等)</p><p>基本类型:int short long byte(无c++中的long long) float double char boolean</p><p>(String不是基本类型,String是封装好的类,所以S大写!)</p><h5 id="1-整型"><a href="#1-整型" class="headerlink" title="(1)整型"></a>(1)整型</h5><p>长整型数值有L或l后缀;</p><p>十六进制ox前缀,八进制o前缀,二进制0b前缀;</p><p>Java中没有无符号整型unsigned;</p><h5 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="(2)浮点类型"></a>(2)浮点类型</h5><p>float类型有后缀f或者F,没有后缀的默认都为double类型;</p><ul><li><p>特殊的浮点类型:正无穷大,负无穷大,NaN(不是一个数字，一般是0/0或者负数的平方根会出现结果为NaN)</p></li><li><p>Java中认为所有的非数值都是不相同的,判断是不是NaN可以使用Double.isNaN方法</p></li><li><p>浮点误差的来源是浮点数值采用二进制系统表示,在二进制系统中无法精确的表示小数,如果需要精确计算需要使用BigDecimal类.</p></li></ul><h5 id="3-char类型"><a href="#3-char类型" class="headerlink" title="(3)char类型"></a>(3)char类型</h5><p>char类型的字面量值需要用单引号括起来（eg:’A’;</p><p>char类型的值可以表示为十六进制值，范围从\u0000到\Uffff;</p><p>还有一些特殊的转义序列，类似于c语言;</p><p>程序中一般不使用char类型，除非确实要使用UTF-16代码单元;</p><h5 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="(4)boolean类型"></a>(4)boolean类型</h5><ul><li><p>整型值和boolean类型值不能相互转换（而C++中可以</p><p>eg：我们熟悉的 if（x) 在c++中值0代替false，非0代替true，但是在Java中就不能通过编译;</p></li></ul><h4 id="1-6-变量"><a href="#1-6-变量" class="headerlink" title="1.6 变量"></a>1.6 变量</h4><p>声明变量后必须用赋值语句进行显式初始化，使用未初始化的变量会报错；</p><p>Java可以把声明放在代码中的任何地方;(交给JVM去找)</p><ul><li>在Java中，使用关键词final指示常量，而在c++中使用const或者#define;</li><li>可以使用static final设置一个类常量;</li></ul><h4 id="1-7-运算符"><a href="#1-7-运算符" class="headerlink" title="1.7 运算符"></a>1.7 运算符</h4><h5 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="(1)数学函数与常量"></a>(1)数学函数与常量</h5><p>在Math类中包含各种各样的数学函数,可以调用一些方法,eg:Math.sqrt(x);</p><ul><li><p>floorMod方法：确保余数≥0;</p></li><li><p>可以不用在每个方法前加Math. ，在源文件顶部加 import static java.lang.Math.*; 即可，静态导入;</p></li></ul><h5 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="(2)强制类型转换"></a>(2)强制类型转换</h5><p>在()中给出想要转换的目标类型;</p><h5 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="(3)运算符重载"></a>(3)运算符重载</h5><p>Java中不支持运算符重载,而C++可以;</p><p>唯一例外是String类里面的=和+,而这是JVM的问题,程序员本身无法实现运算符重载;</p><h4 id="1-8-字符串：String类"><a href="#1-8-字符串：String类" class="headerlink" title="1.8 字符串：String类"></a>1.8 字符串：String类</h4><h5 id="1-拼接"><a href="#1-拼接" class="headerlink" title="(1)拼接"></a>(1)拼接</h5><p>Java允许使用+号拼接两个字符串(JVM的操作);</p><p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串;</p><p>这种特性一般在print语句中,eg:System.out.println(“The answer is “ + answer);</p><h5 id="2-不可变字符串"><a href="#2-不可变字符串" class="headerlink" title="(2)不可变字符串"></a>(2)不可变字符串</h5><p>String类没有提供用于修改字符串的方法;</p><p><a href="https://blog.csdn.net/eydwyz/article/details/88861417">为什么String类字符串在Java中是不可修改的</a></p><h5 id="3-String类类似于char-指针"><a href="#3-String类类似于char-指针" class="headerlink" title="(3)String类类似于char*指针"></a>(3)String类类似于char*指针</h5><p>String类并非字符型数组(c++中是)</p><h5 id="4-检测字符串是否相等"><a href="#4-检测字符串是否相等" class="headerlink" title="(4)检测字符串是否相等"></a>(4)检测字符串是否相等</h5><ul><li><p>使用equals方法检测是否相等，不区分大小写可以使用equalsIgnoreCase方法;</p></li><li><p>一定不要使用==运算符检测两个字符串相等,==只是确定两个字符串是否放在同一个内存区域上。在C++中可以，因为C++可以重载运算符;</p></li><li><p>equals方法是Object超类定义的boolean类型方法;</p></li></ul><h5 id="5-空串与NULL串"><a href="#5-空串与NULL串" class="headerlink" title="(5)空串与NULL串"></a>(5)空串与NULL串</h5><p>空串””是长度为0的字符串，可以使用length检测;</p><p>null是特殊的值，检测使用str==null检测;</p><h5 id="6-StringBuilder-StringBuffer类"><a href="#6-StringBuilder-StringBuffer类" class="headerlink" title="(6)StringBuilder,StringBuffer类"></a>(6)StringBuilder,StringBuffer类</h5><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303">String,StringBuffer,StringBuilder类的区别</a></p><h4 id="1-9-输入输出"><a href="#1-9-输入输出" class="headerlink" title="1.9 输入输出"></a>1.9 输入输出</h4><h5 id="1-输入"><a href="#1-输入" class="headerlink" title="(1)输入"></a>(1)输入</h5><p>首先构造个Scanner对象,并与标准输入流System.in关联:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure><p>现在可以使用Scanner类的各种方法实现输入操作;</p><p>eg:nextLine方法可以输入一行,next方法可以输入一个单词;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String name = in.nextLine();<br>String firstName = in.next();<br></code></pre></td></tr></table></figure><p>Scanner类定义在java.util包中,需要加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure><ul><li>读取密码使用Console类对象</li></ul><h5 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="(2)格式化输出"></a>(2)格式化输出</h5><p>类似于c语言的printf方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.printf(<span class="hljs-string">&quot;%8.2f&quot;</span>,x);<br></code></pre></td></tr></table></figure><h5 id="3-文件输入输出"><a href="#3-文件输入输出" class="headerlink" title="(3)文件输入输出"></a>(3)文件输入输出</h5><p>读取:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner (Paths.get(<span class="hljs-string">&quot;Myfile.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>写入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;Myfile.txt&quot;</span>,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-10-大数值"><a href="#1-10-大数值" class="headerlink" title="1.10 大数值"></a>1.10 大数值</h4><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimal。</p><p>这两个类可以处理包含任意长度数字序列的数值。 </p><p>Biglnteger 类实现了任意精度的整数运算, BigDecimal 实现了任意精度的浮点数运算。</p><ul><li><p>使用静态的valueOf方法可以将普通的数值转化为大数值;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li><li><p>Java不能重载运算符,需要使用add和multiply方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger c = a.add(b);<span class="hljs-comment">//c=a+b;</span><br>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>)));<span class="hljs-comment">//d=c*(b+2);</span><br></code></pre></td></tr></table></figure></li><li><p>加add减subtract乘multiply除divide余mod相等compareTo方法</p></li></ul><h4 id="1-11-数组"><a href="#1-11-数组" class="headerlink" title="1.11 数组"></a>1.11 数组</h4><h5 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="(1)创建数组"></a>(1)创建数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><ul><li>创建一个数字数组，所有数据初始化为0，boolean类型初始化为false，对象数组类型初始化为NULL;</li></ul><h5 id="2-for-each-循环"><a href="#2-for-each-循环" class="headerlink" title="(2)for each 循环"></a>(2)for each 循环</h5><p>可以用来依次处理数组中的每个元素，无需care下标值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(variable : collection) statement<br>    <span class="hljs-comment">//先声明与数组类型相同的变量用于后续遍历</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element ： a) <br>    System.out.println(element);<br><span class="hljs-comment">//打印a数组中的所有元素并换行</span><br></code></pre></td></tr></table></figure><h4 id="1-12-可变参数"><a href="#1-12-可变参数" class="headerlink" title="1.12 可变参数"></a>1.12 可变参数</h4><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：(本质是通过可变数组传递)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(addToSum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        System.out.println(addToSum(<span class="hljs-number">21</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... Arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : Arr) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br>输出结果:<br><span class="hljs-number">9</span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><hr><h3 id="Charpter2-对象与类"><a href="#Charpter2-对象与类" class="headerlink" title="Charpter2.对象与类"></a>Charpter2.对象与类</h3><hr><h4 id="2-1-面向过程和面向对象"><a href="#2-1-面向过程和面向对象" class="headerlink" title="2.1 面向过程和面向对象"></a>2.1 面向过程和面向对象</h4><ul><li>C语言为面向过程语言,强调Algorithm+Data Structures =Programs,算法第一位,数据结构第二位.</li><li>Java为面向对象语言,作为OOP语言,将数据放在第一位,然后再考虑操作数据的算法.OOP适用于解决规模较大的问题.</li></ul><h4 id="2-2-Class"><a href="#2-2-Class" class="headerlink" title="2.2 Class"></a>2.2 Class</h4><h5 id="1-对象变量"><a href="#1-对象变量" class="headerlink" title="(1)对象变量"></a>(1)对象变量</h5><ul><li>一个对象变量并没有实际包含一个对象，而是仅仅引用一个对象。</li></ul><h5 id="2-按值调用"><a href="#2-按值调用" class="headerlink" title="(2)按值调用"></a>(2)按值调用</h5><ul><li>在Java中总是按值传递;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> price=<span class="hljs-number">300</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raisePrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>&#123;<br>    tmp+=<span class="hljs-number">200</span>;<br>&#125;<br>raisePrice(price);<br><span class="hljs-comment">//最终发现price值并没有改变，因为在Java中形参是按值传递</span><br></code></pre></td></tr></table></figure><ul><li>关于对象作为引用参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(Employee s)</span></span>&#123;<br>    s.salary+=<span class="hljs-number">500</span>;<span class="hljs-comment">//这里为了清晰没有使用封装后的setter;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里,形参为对象,传递时先拷贝其内容再引用,本质还是按值传递.</p><p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Q1K.png" alt="图解"></p><ul><li>“按值传递”的一个经典案例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Employee e1,Employee e2)</span></span>&#123;<br>    Employee tmp = e1;<br>    e1 = e2;<br>    e2 = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似可以实现e1与e2引用对象的交换，实际失败了;</p><p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Mp6.png" alt="图解"></p><p>原因:实际上交换的是两个拷贝，并没有交换e1，e2引用对象的本身。</p><ul><li>更准确的define值调用和引用调用:</li><li>值调用:在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参锁存储的内容是实参存储内容的一份拷贝。</li><li>引用调用:在参数传递的过程中，形参和实参完全是同一块内存空间。</li></ul><h4 id="2-3-封装"><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h4><h5 id="1-Concept"><a href="#1-Concept" class="headerlink" title="(1)Concept"></a>(1)Concept</h5><p>将类的某些信息隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作;</p><h5 id="2-实现"><a href="#2-实现" class="headerlink" title="(2)实现"></a>(2)实现</h5><p>getter()&amp;setter()方法</p><p>在IDEA中 Alt+Insert ,可以直接设置</p><p>也可使用Lombok的jar包 @Getter @Setter</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;输入的年龄非法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-静态域和静态方法"><a href="#2-4-静态域和静态方法" class="headerlink" title="2.4 静态域和静态方法"></a>2.4 静态域和静态方法</h4><h5 id="1-静态域"><a href="#1-静态域" class="headerlink" title="(1)静态域"></a>(1)静态域</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">()</span></span>&#123;<br>        id=nextId;<br>        nextId++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//nextId属于静态域，即使该类没有对象仍存在，可以直接调用，无需引用对象;</span><br></code></pre></td></tr></table></figure><h5 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="(2)静态常量"></a>(2)静态常量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI=<span class="hljs-number">3.14159265358979323846</span>;<br>&#125;<br><span class="hljs-comment">//使用final是因为该值不可变,使用static是因为无需对象即可调用PI，PI为静态域而非实例域;</span><br></code></pre></td></tr></table></figure><h5 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="(3)静态方法"></a>(3)静态方法</h5><ul><li>静态方法是一种不能向对象实施操作的方法;也可以认为是没有this参数的方法</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextId</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nextId;<br>&#125;<br><span class="hljs-keyword">int</span> n = Employee.nextId();<br><span class="hljs-comment">//可以通过类名调用这个方法</span><br></code></pre></td></tr></table></figure><ul><li><p>使用静态方法的两种情况：  </p><p>1.方法不需要访问对象状态，其所需参数都是通过显式参数提供(eg：Math.pow)</p><p>2.方法只需要访问类的静态域(访问静态域必须用静态方法)</p></li></ul><h4 id="2-5-对象构造"><a href="#2-5-对象构造" class="headerlink" title="2.5 对象构造"></a>2.5 对象构造</h4><h5 id="1-重载-Overload"><a href="#1-重载-Overload" class="headerlink" title="(1)重载 Overload"></a>(1)重载 Overload</h5><p>如果多个方法有相同的名字，不同的参数，便产生了重载。</p><p>在编译过程中，编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。这个过程叫做重载解析。</p><h5 id="2-无参数构造器"><a href="#2-无参数构造器" class="headerlink" title="(2)无参数构造器"></a>(2)无参数构造器</h5><ul><li>必要性：在new一个对象时就会使用无参数构造器。</li><li>如果在编写一个类时没有写构造器，那么系统会提供一个无参数的构造器。</li><li>如果类中提供了至少一个构造器，系统不会自动提供无参构造器，必须自己写，否则new的时候会报错。</li></ul><p>无参构造器形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassName</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-调用另一个构造器"><a href="#3-调用另一个构造器" class="headerlink" title="(3)调用另一个构造器"></a>(3)调用另一个构造器</h5><p>如果构造器的第一个语句形如this(…)，表明这个构造器将调用同一类的另一个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Employee #&quot;</span>+nextId,s);<span class="hljs-comment">// calls Employee(String,double)</span><br>    nextId++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-包"><a href="#2-6-包" class="headerlink" title="2.6 包"></a>2.6 包</h4><p>使用包的主要原因是确保类名的唯一性，Sun公司建议将公司的因特网域名以逆序的形式作为包名.eg:com.google</p><ul><li>包的导入：使用import语句 eg：import java.util.*;</li><li>还可以导入静态域：eg：import static java.lang.System.*;</li><li>将类放到包中:package com.google.corejava;</li></ul><hr><h3 id="Charpter3-继承"><a href="#Charpter3-继承" class="headerlink" title="Charpter3.继承"></a>Charpter3.继承</h3><hr><h4 id="3-1-类，超类和子类"><a href="#3-1-类，超类和子类" class="headerlink" title="3.1 类，超类和子类"></a>3.1 类，超类和子类</h4><h5 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="(1)定义子类"></a>(1)定义子类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>    statement;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中，我们使用extends关键词表示继承，而在C++中使用：。在Java中所有的继承都是公有继承,没有C++中的私有继承和保护继承。</p><ul><li>已存在的类称为超类，基类或者父类;</li></ul><h5 id="2-重写-覆盖-Override"><a href="#2-重写-覆盖-Override" class="headerlink" title="(2)重写/覆盖 Override"></a>(2)重写/覆盖 Override</h5><ul><li><p>在IDEA中可以直接Alt+Insert然后选择Override</p></li><li><p>使用super调用超类 eg:super.getSalary();可以调用超类的方法，也可以类似this那样调用超类的构造器;</p></li></ul><h5 id="3-继承层次"><a href="#3-继承层次" class="headerlink" title="(3)继承层次"></a>(3)继承层次</h5><p>一个祖先类可以拥有多个子孙继承链，但是Java中不支持多继承。</p><h5 id="4-“断子绝孙”-final类和方法"><a href="#4-“断子绝孙”-final类和方法" class="headerlink" title="(4)“断子绝孙”-final类和方法"></a>(4)“断子绝孙”-final类和方法</h5><ul><li>不允许被继承/扩展的类可以使用final修饰符声明，final类中的所有方法自动变为final方法</li><li>类中的特定方法也可以被final声明，被final声明的方法不能重写</li></ul><h5 id="5-受保护访问"><a href="#5-受保护访问" class="headerlink" title="(5)受保护访问"></a>(5)受保护访问</h5><p>private-仅对本类可见 public-对所有类可见</p><p>protected-对本包和所有子类可见 default默认-对本包可见</p><h5 id="6-继承规则"><a href="#6-继承规则" class="headerlink" title="(6)继承规则"></a>(6)继承规则</h5><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><h4 id="3-2-多态"><a href="#3-2-多态" class="headerlink" title="3.2 多态"></a>3.2 多态</h4><h5 id="1-理解"><a href="#1-理解" class="headerlink" title="(1)理解"></a>(1)理解</h5><ul><li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是<strong>学生</strong>也是<strong>人</strong>，即出现<strong>两种形态</strong>。                                                      </li><li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</li></ul><h5 id="2-体现"><a href="#2-体现" class="headerlink" title="(2)体现"></a>(2)体现</h5><ul><li><p>定义格式：父类类型 变量名=new 子类类型();</p></li><li><p>多态体现为父类引用变量可以指向子类对象</p></li><li><p>注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p></li></ul><h5 id="3-多态中成员的特点"><a href="#3-多态中成员的特点" class="headerlink" title="(3)多态中成员的特点"></a>(3)多态中成员的特点</h5><ul><li>多态成员变量:编译运行看左边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f.num);<span class="hljs-comment">//输出超类的num</span><br></code></pre></td></tr></table></figure><ul><li>多态成员方法:编译看左边，运行看右边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f1.show());<span class="hljs-comment">//调用重写后的方法</span><br></code></pre></td></tr></table></figure><h5 id="4-多态的转型"><a href="#4-多态的转型" class="headerlink" title="(4)多态的转型"></a>(4)多态的转型</h5><ul><li><p>多态的转型分为向上转型和向下转型两种</p></li><li><p>向上转型:多态本身就是向上转型的过程  </p></li><li><p>向下转型:一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型.一般当要使用子类特有功能时候用到;</p><p>使用格式：子类类型 变量名=（子类类型） 父类类型的变量;</p></li></ul><h4 id="3-3-抽象类"><a href="#3-3-抽象类" class="headerlink" title="3.3 抽象类"></a>3.3 抽象类</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h5><p>将具体概念的诸多个性排出，集中描述其共性，产生抽象性概念。</p><p>所有不同职业，年龄的人，共性都是人。</p><p>拥有抽象方法的类就是抽象类，抽象类要用abstract修饰声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;haha!&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//抽象方法，继承时必须重写</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        People people = <span class="hljs-keyword">new</span> people();<span class="hljs-comment">//error 抽象类不可进行实例化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-使用原则"><a href="#2-使用原则" class="headerlink" title="(2)使用原则"></a>(2)使用原则</h5><p>1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>2.抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>3.抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>4.子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p><h4 id="3-4-Object-所有类的超类"><a href="#3-4-Object-所有类的超类" class="headerlink" title="3.4 Object:所有类的超类"></a>3.4 Object:所有类的超类</h4><h5 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="(1)equals方法"></a>(1)equals方法</h5><ul><li>重写equals方法:先调用超类的equals方法判断,再增加特定的判断条件;</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (!sԤerequals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>        Manager other = (Manager) otherObject; <br>        <span class="hljs-keyword">return</span> bonus == other.bonus; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="(2)hashCode方法"></a>(2)hashCode方法</h5><ul><li>hashCode是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li></ul><h5 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="(3)toString方法"></a>(3)toString方法</h5><ul><li>Objcet超类默认带toString方法，不过可以自己重写变得更好一点;</li><li>在IDEA中可以通过Alt+Insert找到toString;</li></ul><hr><h3 id="Charpter4-接口与内部类"><a href="#Charpter4-接口与内部类" class="headerlink" title="Charpter4.接口与内部类"></a>Charpter4.接口与内部类</h3><hr><h4 id="4-1-接口（Interface"><a href="#4-1-接口（Interface" class="headerlink" title="4.1 接口（Interface)"></a>4.1 接口（Interface)</h4><h5 id="1-Concept-1"><a href="#1-Concept-1" class="headerlink" title="(1)Concept"></a>(1)Concept</h5><ul><li><p>接口在Java中是一个抽象类型,是抽象方法的集合;</p></li><li><p>一般来说，如果一个抽象类只由抽象方法和全局常量所组成，这种情况下我们定义成一个接口;接口中没有构造方法;</p></li><li><p>接口是对动作的抽象，抽象类是对本质的抽象;</p></li></ul><h5 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="(2)接口的使用"></a>(2)接口的使用</h5><ul><li><p>接口必须要有子类，一个子类可以通过实现(implements)多个接口；</p></li><li><p>接口的子类（如果不是抽象类），那么必须要重写接口中的全部抽象方法；</p></li><li><p>接口的对象可以利用子类对象的向上转型（多态）进行实例化;</p></li><li><p>对于接口，抽象方法和全局常量可以不用写public abstract或者public static final，并且接口中的访问权限只有public一种;注意子类重写方法的时候必须用public修饰;</p></li><li><p>在Java中，一个抽象类只能继承一个抽象类;而一个接口可以通过extends继承多个接口;(但接口不能继承抽象类)</p></li><li><p>接口不能通过new实例化一个对象，但是可以声明接口的变量，接口变量必须引用实现了接口的类的对象;</p></li></ul><h4 id="4-2-clone-Cloneable接口"><a href="#4-2-clone-Cloneable接口" class="headerlink" title="4.2 clone()/Cloneable接口"></a>4.2 clone()/Cloneable接口</h4><h5 id="1-拷贝和克隆"><a href="#1-拷贝和克隆" class="headerlink" title="(1)拷贝和克隆"></a>(1)拷贝和克隆</h5><p><img src="https://s3.ax1x.com/2021/01/26/sX2ufx.png" alt="拷贝vs克隆"></p><h5 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="(2)Object类的clone方法"></a>(2)Object类的clone方法</h5><ul><li><p>Object类的clone方法声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象;</p></li><li><p>Object类默认的clone方法是”浅拷贝”,并没有克隆对象中引用的其他对象;如果原对象和浅拷贝对象共享的子对象是不可变的类,那么这种共享相对安全,如String类,但是通常子对象是可变的,这样会导致这种共享是不安全的;</p><p><img src="https://s3.ax1x.com/2021/01/26/sX2l6O.png" alt="浅拷贝"></p></li></ul><h5 id="3-Cloneable接口"><a href="#3-Cloneable接口" class="headerlink" title="(3)Cloneable接口"></a>(3)Cloneable接口</h5><ul><li><p>Cloneable接口是Java提供的一组标记接口之一,通常用途是确定一个类实现一个或者一组特定的方法,标记接口不包含任何方法,唯一的作用是允许在类型查询中使用instanceof;</p></li><li><p>重写方法创建深拷贝的例子</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>        Employee cloned = (Employee) <span class="hljs-keyword">super</span>.clone();<br>        cloned.hireDay = (Date) hireDay.clone();<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-内部类"><a href="#4-3-内部类" class="headerlink" title="4.3 内部类"></a>4.3 内部类</h4><hr><h3 id="Chartper5-异常处理机制"><a href="#Chartper5-异常处理机制" class="headerlink" title="Chartper5.异常处理机制"></a>Chartper5.异常处理机制</h3><hr><h4 id="5-1-异常分类"><a href="#5-1-异常分类" class="headerlink" title="5.1 异常分类"></a>5.1 异常分类</h4><ul><li>在Java语言中，所有异常对象都是派生于Throwable类的一个实例.</li></ul><p><img src="https://s3.ax1x.com/2021/01/26/sjCSEQ.png" alt="异常分类"></p><ul><li><p>Error类描述了Java运行时系统的内部错误和资源耗尽错误,这种情况很少见;</p></li><li><p>Exception类分解为两个分支，一个分支派生于RuntimeException(由于程序本身错误),另一个分支包含其他异常,程序本身没有问题,但是由于出现像I/O错误这种的异常叫做其他异常;</p><p>eg：派生于RuntimeException的异常包括以下几种情况:错误的类型转换,数组访问越界（ArrayIndexOutOfBoundsException),访问null空指针(NullPointerException)等等;</p></li><li><p>实际上，派生于Error类或RuntimeException类的所有异常称为非受查异常,所有其他的称为受查异常,编译器将检查所有的受查异常是否提供了异常处理器;</p></li></ul><h4 id="5-2-抛出异常"><a href="#5-2-抛出异常" class="headerlink" title="5.2. 抛出异常"></a>5.2. 抛出异常</h4><ul><li><p>方法应在首部使用throws声明所有可能抛出的异常（受查异常，无需声明派生于Error类或RuntimeException类的异常），每个异常用,隔开;</p></li><li><p>创建异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFormatException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOExpection</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<span class="hljs-comment">//也可不写</span><br>&#125;<br><br>...&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileFormatException();<span class="hljs-comment">//抛出这个自己定义的异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-捕获异常"><a href="#5-3-捕获异常" class="headerlink" title="5.3 捕获异常"></a>5.3 捕获异常</h4></li></ul><h5 id="1-try-catch语句块"><a href="#1-try-catch语句块" class="headerlink" title="(1)try-catch语句块"></a>(1)try-catch语句块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    code;<br>    more code;<br>&#125;<span class="hljs-keyword">catch</span>(ExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;<span class="hljs-keyword">catch</span>(OtherExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;...<br></code></pre></td></tr></table></figure><ul><li>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其他代码，抛出的异常直接被所对应的catch捕获并执行catch中的处理器代码;</li><li>在catch子句中可以再次抛出一个异常，再之后再进行解决;</li></ul><h5 id="2-finally子句"><a href="#2-finally子句" class="headerlink" title="(2)finally子句"></a>(2)finally子句</h5><ul><li><p>不管是否有异常被捕获，finally子句中的代码都会被执行;一般在需要关闭资源的时候使用finally子句;</p></li><li><p>当finally子句中包含return语句时，将会出现一种意想不到的效果。假如利用return语句从try语句块中退出，在方法返回前，finally子句的内容将被执行，如果finally子句中也有一个return语句，这个返回值会覆盖原始的返回值;</p></li></ul><h5 id="3-分析堆栈轨迹元素"><a href="#3-分析堆栈轨迹元素" class="headerlink" title="(3)分析堆栈轨迹元素"></a>(3)分析堆栈轨迹元素</h5><ul><li>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息;</li></ul><h4 id="5-4-异常声明碰到继承关系"><a href="#5-4-异常声明碰到继承关系" class="headerlink" title="5.4 异常声明碰到继承关系"></a>5.4 异常声明碰到继承关系</h4><ul><li>当重写一个函数时，子类不能比超类声明抛出更多的异常;</li><li>在子类的构造函数中,必须声明超类所可能抛出的全部异常;</li><li>利用多态(向上转型)的思想去思考这个问题;</li></ul><hr><h3 id="Charpter6-泛型-Generic"><a href="#Charpter6-泛型-Generic" class="headerlink" title="Charpter6.泛型(Generic)"></a>Charpter6.泛型(<strong>Generic</strong>)</h3><hr><h4 id="6-1-为什么使用泛型"><a href="#6-1-为什么使用泛型" class="headerlink" title="6.1 为什么使用泛型"></a>6.1 为什么使用泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>Iterator it = coll.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>String str = (String) it.next();<br>System.out.println(str.length());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行程序时，程序报错 java.lang.ClassCastException（类型转换异常）;</p><p>因为任何类型的数据都可以强制转换成object类型数据储存在集合中，当我们取出一个对象时，就必须进行强制类型转换，这时候可能会出现类型转换异常，比如这里的5是int类型，int类型不能强制转换为String类;</p><h4 id="6-2-泛型概念"><a href="#6-2-泛型概念" class="headerlink" title="6.2 泛型概念"></a>6.2 泛型概念</h4><p>可以在类或方法中预支地使用未知的类型;</p><h4 id="6-3-泛型的定义与使用"><a href="#6-3-泛型的定义与使用" class="headerlink" title="6.3 泛型的定义与使用"></a>6.3 泛型的定义与使用</h4><h5 id="1-定义和使用泛型类"><a href="#1-定义和使用泛型类" class="headerlink" title="(1)定义和使用泛型类"></a>(1)定义和使用泛型类</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相当于把String赋值给E</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure><h5 id="2-定义和使用泛型方法"><a href="#2-定义和使用泛型方法" class="headerlink" title="(2)定义和使用泛型方法"></a>(2)定义和使用泛型方法</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethod</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode</span><span class="hljs-params">(E e)</span></span>&#123;<br>        System.out.println(e.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethodApplicaton</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ModeMethod m = <span class="hljs-keyword">new</span> ModeMethod();<br>        m.mode(<span class="hljs-number">123</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-定义和使用泛型的接口"><a href="#3-定义和使用泛型的接口" class="headerlink" title="(3)定义和使用泛型的接口"></a>(3)定义和使用泛型的接口</h5><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型接口：</p><p>01.定义类时确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>02.始终不确定泛型的类型，直到创建对象时才确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-4-泛型通配符"><a href="#6-4-泛型通配符" class="headerlink" title="6.4 泛型通配符"></a>6.4 泛型通配符</h4><h5 id="1-通配符基本使用"><a href="#1-通配符基本使用" class="headerlink" title="(1)通配符基本使用"></a>(1)通配符基本使用</h5><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以使用通配符&lt;?&gt;表示;但是一旦使用泛型的通配符后,只能使用Object类的共性方法,子类自身的方法无法使用</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Collection&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-通配符高级使用-受限泛型"><a href="#2-通配符高级使用-受限泛型" class="headerlink" title="(2) 通配符高级使用-受限泛型"></a>(2) 通配符高级使用-受限泛型</h5><ul><li><p>泛型的上限:只能接受该类型以及其子类</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? extends 上限类&gt;对象名称<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>泛型的下限:只能接受该类型以及其超类</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? <span class="hljs-keyword">super</span> 下限类&gt;对象名称<br></code></pre></td></tr></table></figure><p>eg:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Charpter7-包装类"><a href="#Charpter7-包装类" class="headerlink" title="Charpter7.包装类"></a>Charpter7.包装类</h3><hr><h4 id="7-1-包装类概述"><a href="#7-1-包装类概述" class="headerlink" title="7.1 包装类概述"></a>7.1 包装类概述</h4><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中//无需导包）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="7-2-包装类的自动装箱、自动拆箱机制"><a href="#7-2-包装类的自动装箱、自动拆箱机制" class="headerlink" title="7.2 包装类的自动装箱、自动拆箱机制"></a>7.2 包装类的自动装箱、自动拆箱机制</h4><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure><p>而Java为了方便我们使用，以及出于其他目的如性能调优，给我们提供了自动装箱、拆箱机制。这种机制简化了基本类型和包装类型的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Interger i = <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(100);</span><br>i = i +<span class="hljs-number">200</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 200;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h4 id="7-3-包装类中的缓存机制"><a href="#7-3-包装类中的缓存机制" class="headerlink" title="7.3 包装类中的缓存机制"></a>7.3 包装类中的缓存机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer num3 = <span class="hljs-number">10</span>;<br>Integer num4 = <span class="hljs-number">10</span>;<br>Integer num5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num6 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num7 = <span class="hljs-number">128</span>;<br>Integer num8 = <span class="hljs-number">128</span>;<br>System.out.println((num3==num4) +<span class="hljs-string">&quot;&quot;</span>+ num3.equals(num4));<span class="hljs-comment">//ture true</span><br>System.out.println((num5==num6) +<span class="hljs-string">&quot;&quot;</span>+ num5.equals(num6));<span class="hljs-comment">//false true</span><br>System.out.println((num7==num8) +<span class="hljs-string">&quot;&quot;</span>+ num7.equals(num8));<span class="hljs-comment">//false true</span><br></code></pre></td></tr></table></figure><p>为什么num7==num8会返回false呢,我们来看看底层缓存机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br> <br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br> <br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>当Integer类第一次被使用到，Integer的静态内部类就被加载，加载的时候会创建-128到127的Integer对象，同时创建一个数组cache来缓存这些对象。当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，也就是说不会再新建对象；当使用new关键字or使用valueOf()方法创建小于-128大于127的值对象时，就会创建新对象。</p><p>接着,Integer类重写了equals方法,让我们看看equals方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>equals方法重写后比较两个Integer对象的值,所以确定两个Integer对象的值是否相等时,应该使用equals方法而非简单的==,否则因为缓冲机制可能会带来一些问题;</p><p>此外，在8种包装类型中，有缓存区的有Character、Byte、Short、Integer、Long，而且它们的实现方式基本一样，都是-128到127的缓存范围。Boolean虽然没有缓存区，但是因为只有两个值true、false，所以Boolean在成员变量中就创建了两个相应的对象。没有缓存区的只有Float、Double，之所以没有原因很简单，即便是0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</p><p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p><h4 id="7-4-包装类使用过程中有可能引起的空指针异常"><a href="#7-4-包装类使用过程中有可能引起的空指针异常" class="headerlink" title="7.4 包装类使用过程中有可能引起的空指针异常"></a>7.4 包装类使用过程中有可能引起的空指针异常</h4><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-keyword">null</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure><p>此时会出现NullPointerException;需要注意</p><p>//Reference:<a href="https://blog.csdn.net/sinat_30973431/article/details/89332443">Java中的包装类</a></p><hr><h3 id="Charpter8-Collection"><a href="#Charpter8-Collection" class="headerlink" title="Charpter8.Collection"></a>Charpter8.Collection</h3><hr><h4 id="8-1-Introduction"><a href="#8-1-Introduction" class="headerlink" title="8.1 Introduction"></a>8.1 Introduction</h4><p><img src="https://s3.ax1x.com/2021/01/28/yCmIL8.png" alt="概述"></p><p><img src="https://s3.ax1x.com/2021/01/30/yAPzNj.png" alt="Collection"></p><p>集合是Java中的一种容器，可以用来存储多个数据。</p><ul><li><p>集合和数组的区别</p><p>(1)长度区别:数组的长度固定,集合的长度可变;</p><p>(2)内容区别:数组可以存储基本数据类型,也能存储引用类型,而集合只能存储引用类型;</p><p>(3)元素区别:数组中的元素必须是同一类型,集合可以存储不同类型的数据;</p></li><li><p>集合分两大类,单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p></li><li><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p></li></ul><h4 id="8-2-Collection接口常用方法"><a href="#8-2-Collection接口常用方法" class="headerlink" title="8.2 Collection接口常用方法"></a>8.2 Collection接口常用方法</h4><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;az&quot;</span>);<br>        col.remove(<span class="hljs-string">&quot;az&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> hasJava = col.contains(<span class="hljs-string">&quot;Java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hasJava = &quot;</span> + hasJava);<br>        Iterator&lt;String&gt; it = col.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String next = it.next();<br>            System.out.println(<span class="hljs-string">&quot;next = &quot;</span> + next);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        col.clear();<br>        <span class="hljs-keyword">boolean</span> empty = col.isEmpty();<br>        System.out.println(<span class="hljs-string">&quot;empty = &quot;</span> + empty);<br>        col.add(<span class="hljs-string">&quot;had&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;String&quot;</span>);<br>        <span class="hljs-keyword">int</span> size = col.size();<br>        System.out.println(<span class="hljs-string">&quot;size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        Object[] obj = col.toArray();<br>        <span class="hljs-keyword">for</span> (Object o : obj) &#123;<br>            System.out.println(o);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Map,List,Set接口中有一个静态方法of(),方便用于建立少量且元素数目不可变的集合(of()方法只能用于这三个接口,其子类没有)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="8-3-Iterator迭代器"><a href="#8-3-Iterator迭代器" class="headerlink" title="8.3 Iterator迭代器"></a>8.3 Iterator迭代器</h4><ul><li><p>Iterator接口主要用于迭代遍历Collection中的元素;</p></li><li><p>获取迭代器:<code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p></li><li><p>常用方法:</p><p><code>public E next()</code>:返回迭代的下一个元素。</p><p><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</p><p><code>public void remove()</code>：删除迭代器新返回的元素。</p></li><li><p>通过迭代器实现遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过迭代器清空集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            it.next();<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一些细节:</p><p>如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常;</p><p>如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException;</p><p>在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，java会抛出异常并发修改异常（ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p><p>(Reference:<a href="https://blog.csdn.net/qq_33642117/article/details/52039691">Java迭代器Iterator的详解</a></p></li></ul><h4 id="8-4-List集合"><a href="#8-4-List集合" class="headerlink" title="8.4 List集合"></a>8.4 List集合</h4><h5 id="1-List接口"><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h5><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引index的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h5 id="2-List接口中的常用方法"><a href="#2-List接口中的常用方法" class="headerlink" title="(2)List接口中的常用方法"></a>(2)List接口中的常用方法</h5><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        String s = list.get(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;list.remove(0) = &quot;</span> + list.remove(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;list.set(0,\&quot;reflect\&quot;) = &quot;</span> + list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;reflect&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-ArrayList集合"><a href="#3-ArrayList集合" class="headerlink" title="(3)ArrayList集合"></a>(3)ArrayList集合</h5><p><code>java.util.ArrayList</code>集合的底层是数组，元素增删慢，查找快，线程不安全，效率高，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><h5 id="4-LinkedList集合"><a href="#4-LinkedList集合" class="headerlink" title="(4)LinkedList集合"></a>(4)LinkedList集合</h5><p><code>java.util.LinkedList</code>集合的底层是双向链表，元素增删快，查找慢，线程不安全，效率高。</p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li></ul><h5 id="5-Vector集合"><a href="#5-Vector集合" class="headerlink" title="(5)Vector集合"></a>(5)Vector集合</h5><p><code>java.util.Vector</code>集合的底层是数组，元素增删慢，查询快，线程安全，效率低。</p><h4 id="8-5-Set接口"><a href="#8-5-Set接口" class="headerlink" title="8.5 Set接口"></a>8.5 Set接口</h4><h5 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)特点"></a>(1)特点</h5><ol><li>它是一个元素存取无序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就不一定按照11、22、33的顺序完成的,可能是22、33、11）。</li><li>它是没有索引的集合。</li><li>集合中不可以有重复的元素。</li></ol><h5 id="2-HashSet集合"><a href="#2-HashSet集合" class="headerlink" title="(2)HashSet集合"></a>(2)HashSet集合</h5><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><ul><li>hashCode:是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li></ul><h5 id="3-Set集合不允许重复的原理"><a href="#3-Set集合不允许重复的原理" class="headerlink" title="(3)Set集合不允许重复的原理"></a>(3)Set集合不允许重复的原理</h5><p>hashCode值相同<strong>且</strong>equals方法返回值为true时判断重复,不允许进行操作;</p><p>存储的包装类必须重写hashCode方法和equals方法;</p><h5 id="4-HashSet存储自定义类元素"><a href="#4-HashSet存储自定义类元素" class="headerlink" title="(4)HashSet存储自定义类元素"></a>(4)HashSet存储自定义类元素</h5><ul><li>需要重写hashCode方法和equals方法，否则不允许重复会被打破；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashSet&lt;Person&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Person person01 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>        Person person02 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        Person person03 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        set.add(person01);<br>        set.add(person02);<br>        set.add(person03);<br>        Iterator&lt;Person&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Person p = it.next();<br>            System.out.println(p);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;person01.hashCode() = &quot;</span> + person01.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person02.hashCode() = &quot;</span> + person02.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person03.hashCode() = &quot;</span> + person03.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未重写hashCode和equals方法前输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>person01.hashCode() = <span class="hljs-number">1967205423</span><br>person02.hashCode() = <span class="hljs-number">42121758</span><br>person03.hashCode() = <span class="hljs-number">20671747</span><br></code></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//先用==暴力判断</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//如果比较的对象为null或者两者属于不同的类型直接返回false</span><br>        Person person = (Person) o;<span class="hljs-comment">//向下转型</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;<br>                Objects.equals(name, person.name);<span class="hljs-comment">//第一个参数和第二个参数均相同</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重写hashCode和equals方法后输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>person01.hashCode() = <span class="hljs-number">24022538</span><br>person02.hashCode() = <span class="hljs-number">26104871</span><br>person03.hashCode() = <span class="hljs-number">26104871</span><br></code></pre></td></tr></table></figure><p>关于重写hashCode和equals方法:<a href="https://blog.csdn.net/u012557538/article/details/89861552">重写hashCode和equals方法</a></p><h5 id="5-LinkedHashSet"><a href="#5-LinkedHashSet" class="headerlink" title="(5)LinkedHashSet"></a>(5)LinkedHashSet</h5><p>LinkedHashSet的底层数据结构是HashMap和链表,可以保证元素唯一且有序，线程不安全，效率高。</p><h4 id="8-6-Collections"><a href="#8-6-Collections" class="headerlink" title="8.6 Collections"></a>8.6 Collections</h4><h5 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="(1)常用功能"></a>(1)常用功能</h5><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(list,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;liuliang&quot;</span>);<br>        Collections.shuffle(list);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br>[lisi, zhangsan, liuliang]<br>[lisi, liuliang, zhangsan]<br></code></pre></td></tr></table></figure><h5 id="2-重写Comparable接口中的compareTo方法"><a href="#2-重写Comparable接口中的compareTo方法" class="headerlink" title="(2)重写Comparable接口中的compareTo方法"></a>(2)重写Comparable接口中的compareTo方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangermazi&quot;</span>,<span class="hljs-number">23</span>));<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br><span class="hljs-comment">//        return 0;</span><br><span class="hljs-comment">//        return this.age - o.age ;//按年龄升序</span><br>        <span class="hljs-keyword">return</span> o.age - <span class="hljs-keyword">this</span>.age;<span class="hljs-comment">//按年龄降序</span><br>    &#125;<br>&#125;<br><br>升序:[Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;]<br>降序:[Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;]<br></code></pre></td></tr></table></figure><h5 id="3-Comparator比较器"><a href="#3-Comparator比较器" class="headerlink" title="(3)Comparator比较器"></a>(3)Comparator比较器</h5><ul><li><p>Comparable和Comparator的区别:</p><p>Comparable:this(自己)和别人(参数)比较,自己需要实现Comparable接口,重写比较规则的compareTo方法</p><p>Comparator:相当于找一个第三方的裁判对两者进行比较</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">12</span>));<br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge() - o1.getAge();<br>                <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>                    result = o2.getName().charAt(<span class="hljs-number">0</span>) - o1.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span>  result;<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Student&#123;name=<span class="hljs-string">&#x27;xiaoming&#x27;</span>, age=<span class="hljs-number">17</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">12</span>&#125;]<br></code></pre></td></tr></table></figure><h3 id="Charpter9-Map"><a href="#Charpter9-Map" class="headerlink" title="Charpter9.Map"></a>Charpter9.Map</h3><h4 id="9-1-Introduction"><a href="#9-1-Introduction" class="headerlink" title="9.1 Introduction"></a>9.1 Introduction</h4><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><ul><li><p>Map&lt;K,V&gt; K(Key)-代表键的类型  V(Value)-代表值的类型；</p></li><li><p>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。通过键可以找到对应的值；</p></li></ul><h4 id="9-2-Map接口中的常用方法"><a href="#9-2-Map接口中的常用方法" class="headerlink" title="9.2 Map接口中的常用方法"></a>9.2 Map接口中的常用方法</h4><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Hint:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p><h4 id="9-3-Map集合的遍历方式"><a href="#9-3-Map集合的遍历方式" class="headerlink" title="9.3 Map集合的遍历方式"></a>9.3 Map集合的遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * `public Set&lt;K&gt; keySet()`: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment"> * `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">50</span>);<br>        map.put(<span class="hljs-string">&quot;李鬼&quot;</span>,<span class="hljs-number">10086</span>);<br><br>        <span class="hljs-comment">/* 1.使用keySet方法先获取map集合中的key存到新的Set集合中</span><br><span class="hljs-comment">           2.然后使用map集合的get方法获取value</span><br><span class="hljs-comment">           3.foreach循环遍历输出即可</span><br><span class="hljs-comment">        */</span><br><span class="hljs-comment">//        Set&lt;String&gt; containKeySet = map.keySet();</span><br><span class="hljs-comment">//        for (String key : containKeySet) &#123;</span><br><span class="hljs-comment">//            Integer values = map.get(key);</span><br><span class="hljs-comment">//            System.out.println(key+values);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">/*  1.使用map集合里的entrySet方法获取map集合里的键值对到新的Set集合中</span><br><span class="hljs-comment">            2.利用entry中的getKey方法和geyValue方法获取key和value,根据所需输出</span><br><span class="hljs-comment">            Hint:也可以直接使用foreach循环输出Set集合,得到的是key=value这样的格式效果</span><br><span class="hljs-comment">         */</span><br>        <br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; maps : set) &#123;<br>            String key = maps.getKey();<br>            Integer value = maps.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;对应&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-4-LinkedHashMap"><a href="#9-4-LinkedHashMap" class="headerlink" title="9.4 LinkedHashMap"></a>9.4 LinkedHashMap</h4><p>LinkedHashMap的底层是哈希表和双向链表,双向链表用于维护键值对的顺序,所以该集合是有序的;</p><h4 id="9-5-综合练习"><a href="#9-5-综合练习" class="headerlink" title="9.5 综合练习"></a>9.5 综合练习</h4><h5 id="9-5-1-字符出现次数"><a href="#9-5-1-字符出现次数" class="headerlink" title="9.5.1 字符出现次数"></a>9.5.1 字符出现次数</h5><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li> 获取一个字符串对象</li><li> 创建一个Map集合，键代表字符，值代表次数。</li><li> 遍历字符串得到每个字符。</li><li> 判断Map中是否有该键。</li><li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li> 打印最终结果</li></ol><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character tmp:s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(tmp)==<span class="hljs-keyword">null</span>)&#123;<br>                map.put(tmp,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                Integer sum = map.get(tmp);<br>                sum++;<br>                map.put(tmp,sum);<br>            &#125;<br>        &#125;<br>        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : set) &#123;<br>            Character key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(<span class="hljs-string">&quot;出现&quot;</span>+key+<span class="hljs-string">&quot;的次数为&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-5-2-斗地主有序版"><a href="#9-5-2-斗地主有序版" class="headerlink" title="9.5.2 斗地主有序版"></a>9.5.2 斗地主有序版</h5><p><strong>需求:</strong></p><ol><li> 准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li> 洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li> 发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li> 看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:1.  准备牌：完成数字与纸牌的映射关系：</span><br><span class="hljs-comment">使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</span><br><span class="hljs-comment">         */</span><br>        List&lt;String&gt; colors = List.of(<span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        List&lt;String&gt; numbers = List.of(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        List&lt;Integer&gt; pokerIndex = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Integer,String&gt; poker = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Integer index=<span class="hljs-number">0</span>;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;大王&quot;</span>);<br>        index++;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;小王&quot;</span>);<br>        index++;<br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                pokerIndex.add(index);<br>                poker.put(index,color+number);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*  2.洗牌通过数字完成洗牌发牌</span><br><span class="hljs-comment">         */</span><br>        Collections.shuffle(pokerIndex);<br><br><span class="hljs-comment">//        System.out.println(pokerIndex);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</span><br><span class="hljs-comment">        存放的过程中要求数字大小与斗地主规则的大小对应。</span><br><span class="hljs-comment">        将代表不同纸牌的数字分配给不同的玩家与底牌。</span><br><span class="hljs-comment">         */</span><br>        ArrayList&lt;Integer&gt; player01 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player02 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player03 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; temppoker = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Integer count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : pokerIndex) &#123;<br>            <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">50</span>)&#123;<br>                temppoker.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                player01.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<br>                player02.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">2</span>)&#123;<br>                player03.add(num);<br>            &#125;<br>            count++;<br>        &#125;<br>        Collections.sort(player01);<br>        Collections.sort(player02);<br>        Collections.sort(player03);<br>        Collections.sort(temppoker);<br><br><span class="hljs-comment">//        System.out.println(player01);</span><br><span class="hljs-comment">//        System.out.println(player02);</span><br><span class="hljs-comment">//        System.out.println(player03);</span><br><span class="hljs-comment">//        System.out.println(temppoker);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        4.  看牌：通过Map集合找到对应字符展示。</span><br><span class="hljs-comment">通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</span><br><span class="hljs-comment">         */</span><br>        search(<span class="hljs-string">&quot;周润发&quot;</span>,player01,poker);<br>        search(<span class="hljs-string">&quot;刘德华&quot;</span>,player02,poker);<br>        search(<span class="hljs-string">&quot;古天乐&quot;</span>,player03,poker);<br>        search(<span class="hljs-string">&quot;底牌&quot;</span>,temppoker,poker);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(String name,ArrayList list,Map poker)</span> </span>&#123;<br>        List&lt;Object&gt; listed = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            Object o1 = poker.get(o);<br>            listed.add(o1);<br>        &#125;<br>        System.out.print(name+<span class="hljs-string">&quot;:&quot;</span>);<br>        Iterator&lt;Object&gt; it = listed.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object next = it.next();<br>            System.out.print(next+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br>输出：<br>周润发:大王 ♦<span class="hljs-number">2</span> ♠<span class="hljs-number">2</span> ♠K ♣Q ♠Q ♣<span class="hljs-number">9</span> ♥<span class="hljs-number">8</span> ♠<span class="hljs-number">8</span> ♣<span class="hljs-number">7</span> ♥<span class="hljs-number">7</span> ♦<span class="hljs-number">6</span> ♥<span class="hljs-number">6</span> ♠<span class="hljs-number">6</span> ♠<span class="hljs-number">5</span> ♣<span class="hljs-number">4</span> ♥<span class="hljs-number">4</span> ♠<span class="hljs-number">4</span> <br>刘德华:♥<span class="hljs-number">2</span> ♣A ♠A ♦K ♣K ♣J ♥J ♠J ♦<span class="hljs-number">10</span> ♥<span class="hljs-number">10</span> ♠<span class="hljs-number">10</span> ♦<span class="hljs-number">9</span> ♥<span class="hljs-number">9</span> ♠<span class="hljs-number">9</span> ♣<span class="hljs-number">6</span> ♣<span class="hljs-number">5</span> ♥<span class="hljs-number">5</span> ♥<span class="hljs-number">3</span> <br>古天乐:小王 ♣<span class="hljs-number">2</span> ♦A ♥A ♥K ♦Q ♥Q ♦J ♣<span class="hljs-number">10</span> ♦<span class="hljs-number">8</span> ♣<span class="hljs-number">8</span> ♦<span class="hljs-number">7</span> ♠<span class="hljs-number">7</span> ♦<span class="hljs-number">5</span> ♦<span class="hljs-number">4</span> ♦<span class="hljs-number">3</span> ♣<span class="hljs-number">3</span> ♠<span class="hljs-number">3</span> <br>底牌:♠<span class="hljs-number">2</span> ♥Q ♥<span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure><h3 id="Charpter10-多线程"><a href="#Charpter10-多线程" class="headerlink" title="Charpter10.多线程"></a>Charpter10.多线程</h3><h4 id="10-1-并发与并行"><a href="#10-1-并发与并行" class="headerlink" title="10.1 并发与并行"></a>10.1 并发与并行</h4><ul><li><p><strong>并发</strong>:指两个或多个事件在同一个时间段内发生;</p></li><li><p><strong>并行</strong>:指两个或多个事件在同一个时间点发生;</p></li></ul><h4 id="10-2-线程与进程"><a href="#10-2-线程与进程" class="headerlink" title="10.2 线程与进程"></a>10.2 线程与进程</h4><ul><li><p><strong>进程</strong>:是指一个内存中运行的应用程序,一个应用程序可以同时进行多个进程,进程是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建,运行到消亡的过程;</p></li><li><p><strong>线程</strong>:是进程中的一个执行单元,负责当前进程中程序的执行;一个进程中可以有单线程或者多线程;</p></li><li><p><strong>线程调度</strong>:</p><p>(1)分时调度:所有线程轮流获得CPU的使用权,平均分配每个线程占用CPU的时间;</p><p>(2)抢占调度:优先让优先级高的线程使用CPU,如果线程的优先级相同,那么会随机选择一个使用CPU;<strong>Java就是使用抢占调度的方式</strong></p></li></ul><h4 id="10-3-线程类"><a href="#10-3-线程类" class="headerlink" title="10.3 线程类"></a>10.3 线程类</h4><p><code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread thread = <span class="hljs-keyword">new</span> TestThread();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+<span class="hljs-string">&quot;This is my thread!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常用API:</strong></p><ul><li><p><code>public Thread</code>:分配一个新线程对象。</p></li><li><p><code>public Thread(String name) </code>:分配一个指定名字的新的线程对象。</p></li><li><p><code>public Thread(Runnable target) </code>:分配一个带有指定目标新的线程对象</p></li><li><p><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。 </p></li><li><p><code>public String getName() </code>:获取当前线程名称。 </p></li><li><p><code>public void start() </code>:导致此线程开始执行; Java虚拟机调用此线程的run方法</p></li><li><p><code>public void run() </code>:此线程要执行的任务在此处定义代码。 </p></li><li><p><code>public static void sleep(long millis) </code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。//需要用try-catch语句可能抛出printStackTrace异常</p></li><li><p><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p></li></ul><h4 id="10-4-Runnable接口"><a href="#10-4-Runnable接口" class="headerlink" title="10.4 Runnable接口"></a>10.4 Runnable接口</h4><ul><li><p>通过实现Runnable接口来开启多线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.定义Runnable接口的实现类,重写run()方法;</span><br><span class="hljs-comment">2.创建Runnable实现类的实例对象,并以此实例对象作为Thread的参数来创建Thread对象</span><br><span class="hljs-comment">3.启用Thread对象的start()方法来开启多线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>       thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;这是第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过实现Runnable接口开启多线程的优势:</p><p>1.可以避免java单继承的局限性(继承了Thread就不能继承其他类)</p><p>2.使代码可以被多个线程共享,实现代码和线程独立</p><p>3.线程池只能放入实现Runnable或Callable类线程,不能直接放入继承Thread的类</p></li></ul><h4 id="10-5-通过匿名内部类实现创建线程"><a href="#10-5-通过匿名内部类实现创建线程" class="headerlink" title="10.5 通过匿名内部类实现创建线程"></a>10.5 通过匿名内部类实现创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;这是匿名内部类创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="10-6-引出线程安全问题"><a href="#10-6-引出线程安全问题" class="headerlink" title="10.6 引出线程安全问题"></a>10.6 引出线程安全问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    引出问题:在电影票卖票有多个售票窗口卖票,且这多个售票窗口共享需要兜售的票资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>        Thread thread01 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread02 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread03 = <span class="hljs-keyword">new</span> Thread(run);<br>        thread01.start();<br>        thread02.start();<br>        thread03.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">20</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">18</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">19</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">16</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">14</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">12</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">10</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">8</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">6</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">4</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">2</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">1</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">0</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第-<span class="hljs-number">1</span>张票<br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 在这里出现了卖重复的票和卖0/-1这种不存在的票，几个线程共享使用数据导致票数不同步，这种问题称为线程不安全。</p><h4 id="10-7-线程同步"><a href="#10-7-线程同步" class="headerlink" title="10.7 线程同步"></a>10.7 线程同步</h4><p>为了解决线程安全问题，Java中提供了同步机制(synchronized)来解决;</p><h5 id="10-7-1-同步代码块"><a href="#10-7-1-同步代码块" class="headerlink" title="10.7.1 同步代码块"></a>10.7.1 同步代码块</h5><ul><li><code>synchronized</code>关键字可以用于方法的某个区块中,表示对这个区块的资源实行互斥访问;</li></ul><p>创建格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同步锁:可以是任意类型(Object)的对象,注意多个线程对象要使用同一把同步锁;在开启多线程时，仅允许一个线程拿到同步锁，谁拿到同步锁即获得CPU的使用权,其他的线程得等该线程完成代码块释放锁后拿到锁才能执行;</li></ul><p>针对上面线程安全问题的优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="10-7-2-同步方法"><a href="#10-7-2-同步方法" class="headerlink" title="10.7.2 同步方法"></a>10.7.2 同步方法</h5><ul><li>可以使用<code>synchronized</code>修饰方法使方法成为同步方法;</li></ul><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> methodName&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面线程安全问题的优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                 System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同步方法本质也使用了同步锁,对于非静态方法,同步锁就是this;对于静态方法,同步锁就是当前方法所在类的字节码对象(类名.class)</li></ul><h5 id="10-7-3-Lock锁"><a href="#10-7-3-Lock锁" class="headerlink" title="10.7.3 Lock锁"></a>10.7.3 Lock锁</h5><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁操作;优化了加锁和释放锁的方式;</p><ul><li><code>public void lock();</code>加同步锁;</li><li><code>public void unlock();</code>释放同步锁;</li></ul><p><code>ReentrantLock</code>是一个互斥锁，也是一个<strong>可重入锁</strong>（Reentrant就是再次进入的意思）。<code>ReentrantLock</code>锁在同一个时间点只能被一个线程锁持有，但是它可以被单个线程多次获取，每获取一次<code>AQS</code>的<code>state</code>就加1，每释放一次<code>state</code>就减1。</p><p>针对上面线程安全问题的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意如果使用try-catch代码块,一定要把unlock()过程放到finally里,防止程序抛出了异常而一直不释放锁;</li></ul><h4 id="10-8-线程状态"><a href="#10-8-线程状态" class="headerlink" title="10.8 线程状态"></a>10.8 线程状态</h4><p>在线程的生命周期中,会呈现不同的线程状态;</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>New</td><td>线程刚被创建，但还并未启动，还没调用start方法</td></tr><tr><td>Runnable(可运行)</td><td>线程在JVM中运行的状态</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个同步锁，而该锁已被其他对象占有，则该线程进入Blocked状态;等该线程获取到锁时，转变为Runnable状态;</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行唤醒动作时,该线程进入Waiting状态.进入该状态不能主动唤醒,必须等待另一个线程调用notify方法;（当我们调用Thread.sleep(time);方法时,线程进入睡眠状态也就是TimedWaiting状态，等待时间到后自动唤醒;或者使用带参数的wait方法也可;）</td></tr><tr><td>TimedWaiting(计时等待)</td><td>类似于waiting状态,但是传入了一个参数,在一直没有另一个线程唤醒时,到了超时参数后会自动唤醒;</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出或者是因为没有捕获的异常终止了run方法而导致线程被终止</td></tr></tbody></table><h4 id="10-9-等待唤醒机制"><a href="#10-9-等待唤醒机制" class="headerlink" title="10.9 等待唤醒机制"></a>10.9 等待唤醒机制</h4><ul><li><p>常用方法:</p><p><code>Object.wait()</code>:使线程不再执行操作,进入waitset,等待notify使其回到readyset;</p><p><code>Object.notify()</code>:使所选取对象的一个线程释放;</p><p><code>Object.notifyAll()</code>:使所选取对象的所有线程释放;</p></li></ul><p>包子铺卖包子问题代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    包子铺卖包子问题:</span><br><span class="hljs-comment">        1.创建包子类,内有包子的皮和馅料实例,还有包子的状态(有或无);</span><br><span class="hljs-comment">        2.创建包子铺类,当包子的状态为无时就被唤醒做包子,做完后将包子状态改为有,唤醒买家;当包子的状态为有时就休眠;</span><br><span class="hljs-comment">        3.创建买家类,当包子的状态为有时就被唤醒买包子吃,吃完后将包子状态改为无,唤醒包子铺;当包子的状态为无时就休眠;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>        BaoZiPu baoZiPu = <span class="hljs-keyword">new</span> BaoZiPu(bz);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(bz);<br>        Thread baoziputhread = <span class="hljs-keyword">new</span> Thread(baoZiPu);<br>        Thread consumerthread = <span class="hljs-keyword">new</span> Thread(consumer);<br>        baoziputhread.start();<br>        consumerthread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String pi;<br>    <span class="hljs-keyword">public</span> String xian;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> state = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;店家正在做包子,请等待!&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;肉&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;厚皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;韭菜&quot;</span>;<br>                    &#125;<br>                    flag++;<br>                    bz.state = <span class="hljs-keyword">true</span>;<br>                    bz.notify();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bz = bz;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;我买了这个&quot;</span> + bz.pi + bz.xian + <span class="hljs-string">&quot;包子,一秒钟吃完!&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">1000</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        bz.state = <span class="hljs-keyword">false</span>;<br>                        System.out.println(<span class="hljs-string">&quot;吃完了,针不戳!&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>                        bz.notify();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            bz.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个厚皮韭菜包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>......<br></code></pre></td></tr></table></figure><h4 id="10-10-线程池"><a href="#10-10-线程池" class="headerlink" title="10.10 线程池"></a>10.10 线程池</h4><ul><li><strong>概念：</strong>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
