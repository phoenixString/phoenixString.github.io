

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Shimmery">
  <meta name="keywords" content="Java后端开发">
  <title>JavaSE-从入门到入秃 - Shimmery&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Shimmery's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/back02.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaSE-从入门到入秃">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-21 16:20" pubdate>
        2021年2月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      328
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaSE-从入门到入秃</h1>
            
            <div class="markdown-body">
              <p>JavaSE知识:面向对象,封装,继承,多态,抽象类和接口,匿名内部类,lambda表达式,泛型,包装类,异常处理机制,Collection,Map,反射,多线程,锁,IO流,NIO,函数式接口,JVM…</p>
<a id="more"></a>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="JavaSE-从入门到入秃"><a href="#JavaSE-从入门到入秃" class="headerlink" title="JavaSE-从入门到入秃"></a>JavaSE-从入门到入秃</h1><h2 id="Charpter1-Introduction"><a href="#Charpter1-Introduction" class="headerlink" title="Charpter1.Introduction"></a>Charpter1.Introduction</h2><h3 id="1-1-Java具有可移植性"><a href="#1-1-Java具有可移植性" class="headerlink" title="1.1 Java具有可移植性"></a>1.1 Java具有可移植性</h3><p>Java的数据类型具有固定的大小,同时二进制数据以固定的格式进行存储和传输。</p>
<p>而C/C++中,int 可能是 16 位整数、 32 位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。</p>
<h3 id="1-2-常见Java术语"><a href="#1-2-常见Java术语" class="headerlink" title="1.2 常见Java术语"></a>1.2 常见Java术语</h3><p><img src="https://s3.ax1x.com/2021/01/26/sX21XD.png" srcset="/img/loading.gif" alt="常见Java术语" title="常见Java术语"></p>
<h3 id="1-3-Java的一些规范"><a href="#1-3-Java的一些规范" class="headerlink" title="1.3 Java的一些规范"></a>1.3 Java的一些规范</h3><p>Java区分大小写;</p>
<p>Java变量/类的命名应遵循驼峰命名法;具体参见孤尽老师的《<em>阿里巴巴Java开发手册</em>》</p>
<p>源代码的文件名必须与公共类的名字相同;</p>
<p>一般不在一行中声明多个变量，逐一声明变量可以提高程序的可读性;</p>
<h3 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h3><p>类注释：以/** 为开始 */为结束</p>
<p>行注释：//或者/* */</p>
<p>方法注释:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*@param:变量描述</span><br><span class="hljs-comment">*@return:描述</span><br><span class="hljs-comment">*@throws:类描述</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h3><p>Java是强类型语言,变量必须声明类型;(JavaScript是弱类型语言,直接用var声明变量,同时具有弱类型语言的===判断全等)</p>
<p>基本类型:int short long byte(无c++中的long long) float double char boolean</p>
<p>(String不是基本类型,String是封装好的类,所以S大写!)</p>
<h4 id="1-整型"><a href="#1-整型" class="headerlink" title="(1)整型"></a>(1)整型</h4><p>长整型数值有L或l后缀;</p>
<p>十六进制ox前缀,八进制o前缀,二进制0b前缀;</p>
<p>Java中没有无符号整型unsigned;</p>
<h4 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="(2)浮点类型"></a>(2)浮点类型</h4><p>float类型有后缀f或者F,没有后缀的默认都为double类型;</p>
<ul>
<li><p>特殊的浮点类型:正无穷大,负无穷大,NaN(不是一个数字，一般是0/0或者负数的平方根会出现结果为NaN)</p>
</li>
<li><p>Java中认为所有的非数值都是不相同的,判断是不是NaN可以使用Double.isNaN方法</p>
</li>
<li><p>浮点误差的来源是浮点数值采用二进制系统表示,在二进制系统中无法精确的表示小数,如果需要精确计算需要使用BigDecimal类.</p>
</li>
</ul>
<h4 id="3-char类型"><a href="#3-char类型" class="headerlink" title="(3)char类型"></a>(3)char类型</h4><p>char类型的字面量值需要用单引号括起来（eg:’A’;</p>
<p>char类型的值可以表示为十六进制值，范围从\u0000到\Uffff;</p>
<p>还有一些特殊的转义序列，类似于c语言;</p>
<p>程序中一般不使用char类型，除非确实要使用UTF-16代码单元;</p>
<h4 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="(4)boolean类型"></a>(4)boolean类型</h4><ul>
<li><p>整型值和boolean类型值不能相互转换（而C++中可以</p>
<p>eg：我们熟悉的 if（x) 在c++中值0代替false，非0代替true，但是在Java中就不能通过编译;</p>
</li>
</ul>
<h3 id="1-6-变量"><a href="#1-6-变量" class="headerlink" title="1.6 变量"></a>1.6 变量</h3><p>声明变量后必须用赋值语句进行显式初始化，使用未初始化的变量会报错；</p>
<p>Java可以把声明放在代码中的任何地方;(交给JVM去找)</p>
<ul>
<li>在Java中，使用关键词final指示常量，而在c++中使用const或者#define;</li>
<li>可以使用static final设置一个类常量;</li>
</ul>
<h3 id="1-7-运算符"><a href="#1-7-运算符" class="headerlink" title="1.7 运算符"></a>1.7 运算符</h3><h4 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="(1)数学函数与常量"></a>(1)数学函数与常量</h4><p>在Math类中包含各种各样的数学函数,可以调用一些方法,eg:Math.sqrt(x);</p>
<ul>
<li><p>floorMod方法：确保余数≥0;</p>
</li>
<li><p>可以不用在每个方法前加Math. ，在源文件顶部加 import static java.lang.Math.*; 即可，静态导入;</p>
</li>
</ul>
<h4 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="(2)强制类型转换"></a>(2)强制类型转换</h4><p>在()中给出想要转换的目标类型;</p>
<h4 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="(3)运算符重载"></a>(3)运算符重载</h4><p>Java中不支持运算符重载,而C++可以;</p>
<p>唯一例外是String类里面的=和+,而这是JVM的问题,程序员本身无法实现运算符重载;</p>
<h3 id="1-8-字符串：String类"><a href="#1-8-字符串：String类" class="headerlink" title="1.8 字符串：String类"></a>1.8 字符串：String类</h3><h4 id="1-拼接"><a href="#1-拼接" class="headerlink" title="(1)拼接"></a>(1)拼接</h4><p>Java允许使用+号拼接两个字符串(JVM的操作);</p>
<p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串;</p>
<p>这种特性一般在print语句中,eg:System.out.println(“The answer is “ + answer);</p>
<h4 id="2-不可变字符串"><a href="#2-不可变字符串" class="headerlink" title="(2)不可变字符串"></a>(2)不可变字符串</h4><p>String类没有提供用于修改字符串的方法;</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eydwyz/article/details/88861417">为什么String类字符串在Java中是不可修改的</a></p>
<h4 id="3-String类类似于char-指针"><a href="#3-String类类似于char-指针" class="headerlink" title="(3)String类类似于char*指针"></a>(3)String类类似于char*指针</h4><p>String类并非字符型数组(c++中是)</p>
<h4 id="4-检测字符串是否相等"><a href="#4-检测字符串是否相等" class="headerlink" title="(4)检测字符串是否相等"></a>(4)检测字符串是否相等</h4><ul>
<li><p>使用equals方法检测是否相等，不区分大小写可以使用equalsIgnoreCase方法;</p>
</li>
<li><p>一定不要使用==运算符检测两个字符串相等,==只是确定两个字符串是否放在同一个内存区域上。在C++中可以，因为C++可以重载运算符;</p>
</li>
<li><p>equals方法是Object超类定义的boolean类型方法;</p>
</li>
</ul>
<h4 id="5-空串与NULL串"><a href="#5-空串与NULL串" class="headerlink" title="(5)空串与NULL串"></a>(5)空串与NULL串</h4><p>空串””是长度为0的字符串，可以使用length检测;</p>
<p>null是特殊的值，检测使用str==null检测;</p>
<h4 id="6-StringBuilder-StringBuffer类"><a href="#6-StringBuilder-StringBuffer类" class="headerlink" title="(6)StringBuilder,StringBuffer类"></a>(6)StringBuilder,StringBuffer类</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303">String,StringBuffer,StringBuilder类的区别</a></p>
<h3 id="1-9-输入输出"><a href="#1-9-输入输出" class="headerlink" title="1.9 输入输出"></a>1.9 输入输出</h3><h4 id="1-输入"><a href="#1-输入" class="headerlink" title="(1)输入"></a>(1)输入</h4><p>首先构造个Scanner对象,并与标准输入流System.in关联:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>
<p>现在可以使用Scanner类的各种方法实现输入操作;</p>
<p>eg:nextLine方法可以输入一行,next方法可以输入一个单词;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String name = in.nextLine();<br>String firstName = in.next();<br></code></pre></td></tr></table></figure>
<p>Scanner类定义在java.util包中,需要加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure>
<ul>
<li>读取密码使用Console类对象</li>
</ul>
<h4 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="(2)格式化输出"></a>(2)格式化输出</h4><p>类似于c语言的printf方法;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.printf(<span class="hljs-string">&quot;%8.2f&quot;</span>,x);<br></code></pre></td></tr></table></figure>
<h4 id="3-文件输入输出"><a href="#3-文件输入输出" class="headerlink" title="(3)文件输入输出"></a>(3)文件输入输出</h4><p>读取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner (Paths.get(<span class="hljs-string">&quot;Myfile.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>写入文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;Myfile.txt&quot;</span>,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="1-10-大数值"><a href="#1-10-大数值" class="headerlink" title="1.10 大数值"></a>1.10 大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimal。</p>
<p>这两个类可以处理包含任意长度数字序列的数值。 </p>
<p>Biglnteger 类实现了任意精度的整数运算, BigDecimal 实现了任意精度的浮点数运算。</p>
<ul>
<li><p>使用静态的valueOf方法可以将普通的数值转化为大数值;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>Java不能重载运算符,需要使用add和multiply方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger c = a.add(b);<span class="hljs-comment">//c=a+b;</span><br>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>)));<span class="hljs-comment">//d=c*(b+2);</span><br></code></pre></td></tr></table></figure></li>
<li><p>加add减subtract乘multiply除divide余mod相等compareTo方法</p>
</li>
</ul>
<h3 id="1-11-数组"><a href="#1-11-数组" class="headerlink" title="1.11 数组"></a>1.11 数组</h3><h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="(1)创建数组"></a>(1)创建数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li>创建一个数字数组，所有数据初始化为0，boolean类型初始化为false，对象数组类型初始化为NULL;</li>
</ul>
<h4 id="2-for-each-循环"><a href="#2-for-each-循环" class="headerlink" title="(2)for each 循环"></a>(2)for each 循环</h4><p>可以用来依次处理数组中的每个元素，无需care下标值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(variable : collection) statement<br>    <span class="hljs-comment">//先声明与数组类型相同的变量用于后续遍历</span><br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element ： a) <br>    System.out.println(element);<br><span class="hljs-comment">//打印a数组中的所有元素并换行</span><br></code></pre></td></tr></table></figure>
<h3 id="1-12-可变参数"><a href="#1-12-可变参数" class="headerlink" title="1.12 可变参数"></a>1.12 可变参数</h3><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：(本质是通过可变数组传递)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(addToSum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        System.out.println(addToSum(<span class="hljs-number">21</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... Arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : Arr) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br>输出结果:<br><span class="hljs-number">9</span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<hr>
<h2 id="Charpter2-Object-with-Class"><a href="#Charpter2-Object-with-Class" class="headerlink" title="Charpter2.Object with Class"></a>Charpter2.Object with Class</h2><h3 id="2-1-面向过程和面向对象"><a href="#2-1-面向过程和面向对象" class="headerlink" title="2.1 面向过程和面向对象"></a>2.1 面向过程和面向对象</h3><ul>
<li>C语言为面向过程语言,强调Algorithm+Data Structures =Programs,算法第一位,数据结构第二位.</li>
<li>Java为面向对象语言,作为OOP语言,将数据放在第一位,然后再考虑操作数据的算法.OOP适用于解决规模较大的问题.</li>
</ul>
<h3 id="2-2-Class"><a href="#2-2-Class" class="headerlink" title="2.2 Class"></a>2.2 Class</h3><h4 id="1-对象变量"><a href="#1-对象变量" class="headerlink" title="(1)对象变量"></a>(1)对象变量</h4><ul>
<li>一个对象变量并没有实际包含一个对象，而是仅仅引用一个对象。</li>
</ul>
<h4 id="2-按值调用"><a href="#2-按值调用" class="headerlink" title="(2)按值调用"></a>(2)按值调用</h4><ul>
<li>在Java中总是按值传递;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> price=<span class="hljs-number">300</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raisePrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>&#123;<br>    tmp+=<span class="hljs-number">200</span>;<br>&#125;<br>raisePrice(price);<br><span class="hljs-comment">//最终发现price值并没有改变，因为在Java中形参是按值传递</span><br></code></pre></td></tr></table></figure>
<ul>
<li>关于对象作为引用参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(Employee s)</span></span>&#123;<br>    s.salary+=<span class="hljs-number">500</span>;<span class="hljs-comment">//这里为了清晰没有使用封装后的setter;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这里,形参为对象,传递时先拷贝其内容再引用,本质还是按值传递.</p>
<p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Q1K.png" srcset="/img/loading.gif" alt="图解"></p>
<ul>
<li>“按值传递”的一个经典案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Employee e1,Employee e2)</span></span>&#123;<br>    Employee tmp = e1;<br>    e1 = e2;<br>    e2 = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看似可以实现e1与e2引用对象的交换，实际失败了;</p>
<p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Mp6.png" srcset="/img/loading.gif" alt="图解"></p>
<p>原因:实际上交换的是两个拷贝，并没有交换e1，e2引用对象的本身。</p>
<ul>
<li>更准确的define值调用和引用调用:</li>
<li>值调用:在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参锁存储的内容是实参存储内容的一份拷贝。</li>
<li>引用调用:在参数传递的过程中，形参和实参完全是同一块内存空间。</li>
</ul>
<h3 id="2-3-封装"><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h3><h4 id="1-Concept"><a href="#1-Concept" class="headerlink" title="(1)Concept"></a>(1)Concept</h4><p>将类的某些信息隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作;</p>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="(2)实现"></a>(2)实现</h4><p>getter()&amp;setter()方法</p>
<p>在IDEA中 Alt+Insert ,可以直接设置</p>
<p>也可使用Lombok的jar包 @Getter @Setter</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;输入的年龄非法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-静态域和静态方法"><a href="#2-4-静态域和静态方法" class="headerlink" title="2.4 静态域和静态方法"></a>2.4 静态域和静态方法</h3><h4 id="1-静态域"><a href="#1-静态域" class="headerlink" title="(1)静态域"></a>(1)静态域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">()</span></span>&#123;<br>        id=nextId;<br>        nextId++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//nextId属于静态域，即使该类没有对象仍存在，可以直接调用，无需引用对象;</span><br></code></pre></td></tr></table></figure>
<h4 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="(2)静态常量"></a>(2)静态常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI=<span class="hljs-number">3.14159265358979323846</span>;<br>&#125;<br><span class="hljs-comment">//使用final是因为该值不可变,使用static是因为无需对象即可调用PI，PI为静态域而非实例域;</span><br></code></pre></td></tr></table></figure>
<h4 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="(3)静态方法"></a>(3)静态方法</h4><ul>
<li>静态方法是一种不能向对象实施操作的方法;也可以认为是没有this参数的方法</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextId</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nextId;<br>&#125;<br><span class="hljs-keyword">int</span> n = Employee.nextId();<br><span class="hljs-comment">//可以通过类名调用这个方法</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>使用静态方法的两种情况：  </p>
<p>1.方法不需要访问对象状态，其所需参数都是通过显式参数提供(eg：Math.pow)</p>
<p>2.方法只需要访问类的静态域(访问静态域必须用静态方法)</p>
</li>
</ul>
<h3 id="2-5-对象构造"><a href="#2-5-对象构造" class="headerlink" title="2.5 对象构造"></a>2.5 对象构造</h3><h4 id="1-重载-Overload"><a href="#1-重载-Overload" class="headerlink" title="(1)重载 Overload"></a>(1)重载 Overload</h4><p>如果多个方法有相同的名字，不同的参数，便产生了重载。</p>
<p>在编译过程中，编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。这个过程叫做重载解析。</p>
<h4 id="2-无参数构造器"><a href="#2-无参数构造器" class="headerlink" title="(2)无参数构造器"></a>(2)无参数构造器</h4><ul>
<li>必要性：在new一个对象时就会使用无参数构造器。</li>
<li>如果在编写一个类时没有写构造器，那么系统会提供一个无参数的构造器。</li>
<li>如果类中提供了至少一个构造器，系统不会自动提供无参构造器，必须自己写，否则new的时候会报错。</li>
</ul>
<p>无参构造器形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassName</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-调用另一个构造器"><a href="#3-调用另一个构造器" class="headerlink" title="(3)调用另一个构造器"></a>(3)调用另一个构造器</h4><p>如果构造器的第一个语句形如this(…)，表明这个构造器将调用同一类的另一个构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Employee #&quot;</span>+nextId,s);<span class="hljs-comment">// calls Employee(String,double)</span><br>    nextId++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-6-Package"><a href="#2-6-Package" class="headerlink" title="2.6 Package"></a>2.6 Package</h3><p>使用包的主要原因是确保类名的唯一性，Sun公司建议将公司的因特网域名以逆序的形式作为包名.eg:com.google</p>
<ul>
<li>包的导入：使用import语句 eg：import java.util.*;</li>
<li>还可以导入静态域：eg：import static java.lang.System.*;</li>
<li>将类放到包中:package com.google.corejava;</li>
</ul>
<hr>
<h2 id="Charpter3-Extends"><a href="#Charpter3-Extends" class="headerlink" title="Charpter3.Extends"></a>Charpter3.Extends</h2><h3 id="3-1-类，超类和子类"><a href="#3-1-类，超类和子类" class="headerlink" title="3.1 类，超类和子类"></a>3.1 类，超类和子类</h3><h4 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="(1)定义子类"></a>(1)定义子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>    statement;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Java中，我们使用extends关键词表示继承，而在C++中使用：。在Java中所有的继承都是公有继承,没有C++中的私有继承和保护继承。</p>
<ul>
<li>已存在的类称为超类，基类或者父类;</li>
</ul>
<h4 id="2-重写-覆盖-Override"><a href="#2-重写-覆盖-Override" class="headerlink" title="(2)重写/覆盖 Override"></a>(2)重写/覆盖 Override</h4><ul>
<li><p>在IDEA中可以直接Alt+Insert然后选择Override</p>
</li>
<li><p>使用super调用超类 eg:super.getSalary();可以调用超类的方法，也可以类似this那样调用超类的构造器;</p>
</li>
</ul>
<h4 id="3-继承层次"><a href="#3-继承层次" class="headerlink" title="(3)继承层次"></a>(3)继承层次</h4><p>一个祖先类可以拥有多个子孙继承链，但是Java中不支持多继承。</p>
<h4 id="4-“断子绝孙”-final类和方法"><a href="#4-“断子绝孙”-final类和方法" class="headerlink" title="(4)“断子绝孙”-final类和方法"></a>(4)“断子绝孙”-final类和方法</h4><ul>
<li>不允许被继承/扩展的类可以使用final修饰符声明，final类中的所有方法自动变为final方法</li>
<li>类中的特定方法也可以被final声明，被final声明的方法不能重写</li>
</ul>
<h4 id="5-受保护访问"><a href="#5-受保护访问" class="headerlink" title="(5)受保护访问"></a>(5)受保护访问</h4><p>private-仅对本类可见 public-对所有类可见</p>
<p>protected-对本包和所有子类可见 default默认-对本包可见</p>
<h4 id="6-继承规则"><a href="#6-继承规则" class="headerlink" title="(6)继承规则"></a>(6)继承规则</h4><ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h3 id="3-2-多态"><a href="#3-2-多态" class="headerlink" title="3.2 多态"></a>3.2 多态</h3><h4 id="1-理解"><a href="#1-理解" class="headerlink" title="(1)理解"></a>(1)理解</h4><ul>
<li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是<strong>学生</strong>也是<strong>人</strong>，即出现<strong>两种形态</strong>。                                                      </li>
<li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</li>
</ul>
<h4 id="2-体现"><a href="#2-体现" class="headerlink" title="(2)体现"></a>(2)体现</h4><ul>
<li><p>定义格式：父类类型 变量名=new 子类类型();</p>
</li>
<li><p>多态体现为父类引用变量可以指向子类对象</p>
</li>
<li><p>注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>
</li>
</ul>
<h4 id="3-多态中成员的特点"><a href="#3-多态中成员的特点" class="headerlink" title="(3)多态中成员的特点"></a>(3)多态中成员的特点</h4><ul>
<li>多态成员变量:编译运行看左边</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f.num);<span class="hljs-comment">//输出超类的num</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多态成员方法:编译看左边，运行看右边</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f1.show());<span class="hljs-comment">//调用重写后的方法</span><br></code></pre></td></tr></table></figure>
<h4 id="4-多态的转型"><a href="#4-多态的转型" class="headerlink" title="(4)多态的转型"></a>(4)多态的转型</h4><ul>
<li><p>多态的转型分为向上转型和向下转型两种</p>
</li>
<li><p>向上转型:多态本身就是向上转型的过程  </p>
</li>
<li><p>向下转型:一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型.一般当要使用子类特有功能时候用到;</p>
<p>使用格式：子类类型 变量名=（子类类型） 父类类型的变量;</p>
</li>
</ul>
<h3 id="3-3-抽象类"><a href="#3-3-抽象类" class="headerlink" title="3.3 抽象类"></a>3.3 抽象类</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h4><p>将具体概念的诸多个性排出，集中描述其共性，产生抽象性概念。</p>
<p>所有不同职业，年龄的人，共性都是人。</p>
<p>拥有抽象方法的类就是抽象类，抽象类要用abstract修饰声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;haha!&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//抽象方法，继承时必须重写</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        People people = <span class="hljs-keyword">new</span> people();<span class="hljs-comment">//error 抽象类不可进行实例化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-使用原则"><a href="#2-使用原则" class="headerlink" title="(2)使用原则"></a>(2)使用原则</h4><p>1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>2.抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>3.抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>4.子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p>
<h3 id="3-4-Object-所有类的超类"><a href="#3-4-Object-所有类的超类" class="headerlink" title="3.4 Object:所有类的超类"></a>3.4 Object:所有类的超类</h3><h4 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="(1)equals方法"></a>(1)equals方法</h4><ul>
<li>重写equals方法:先调用超类的equals方法判断,再增加特定的判断条件;</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (!sԤerequals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>        Manager other = (Manager) otherObject; <br>        <span class="hljs-keyword">return</span> bonus == other.bonus; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="(2)hashCode方法"></a>(2)hashCode方法</h4><ul>
<li>hashCode是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li>
</ul>
<h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="(3)toString方法"></a>(3)toString方法</h4><ul>
<li>Objcet超类默认带toString方法，不过可以自己重写变得更好一点;</li>
<li>在IDEA中可以通过Alt+Insert找到toString;</li>
</ul>
<hr>
<h2 id="Charpter4-Interface"><a href="#Charpter4-Interface" class="headerlink" title="Charpter4.Interface"></a>Charpter4.Interface</h2><h3 id="4-1-接口（Interface"><a href="#4-1-接口（Interface" class="headerlink" title="4.1 接口（Interface)"></a>4.1 接口（Interface)</h3><h4 id="1-Concept-1"><a href="#1-Concept-1" class="headerlink" title="(1)Concept"></a>(1)Concept</h4><ul>
<li><p>接口在Java中是一个抽象类型,是抽象方法的集合;</p>
</li>
<li><p>一般来说，如果一个抽象类只由抽象方法和全局常量所组成，这种情况下我们定义成一个接口;接口中没有构造方法;</p>
</li>
<li><p>接口是对动作的抽象，抽象类是对本质的抽象;</p>
</li>
</ul>
<h4 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="(2)接口的使用"></a>(2)接口的使用</h4><ul>
<li><p>接口必须要有子类，一个子类可以通过实现(implements)多个接口；</p>
</li>
<li><p>接口的子类（如果不是抽象类），那么必须要重写接口中的全部抽象方法；</p>
</li>
<li><p>接口的对象可以利用子类对象的向上转型（多态）进行实例化;</p>
</li>
<li><p>对于接口，抽象方法和全局常量可以不用写public abstract或者public static final，并且接口中的访问权限只有public一种;注意子类重写方法的时候必须用public修饰;</p>
</li>
<li><p>在Java中，一个抽象类只能继承一个抽象类;而一个接口可以通过extends继承多个接口;(但接口不能继承抽象类)</p>
</li>
<li><p>接口不能通过new实例化一个对象，但是可以声明接口的变量，接口变量必须引用实现了接口的类的对象;</p>
</li>
</ul>
<h3 id="4-2-clone-Cloneable接口"><a href="#4-2-clone-Cloneable接口" class="headerlink" title="4.2 clone()/Cloneable接口"></a>4.2 clone()/Cloneable接口</h3><h4 id="1-拷贝和克隆"><a href="#1-拷贝和克隆" class="headerlink" title="(1)拷贝和克隆"></a>(1)拷贝和克隆</h4><p><img src="https://s3.ax1x.com/2021/01/26/sX2ufx.png" srcset="/img/loading.gif" alt="拷贝vs克隆"></p>
<h4 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="(2)Object类的clone方法"></a>(2)Object类的clone方法</h4><ul>
<li><p>Object类的clone方法声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象;</p>
</li>
<li><p>Object类默认的clone方法是”浅拷贝”,并没有克隆对象中引用的其他对象;如果原对象和浅拷贝对象共享的子对象是不可变的类,那么这种共享相对安全,如String类,但是通常子对象是可变的,这样会导致这种共享是不安全的;</p>
<p><img src="https://s3.ax1x.com/2021/01/26/sX2l6O.png" srcset="/img/loading.gif" alt="浅拷贝"></p>
</li>
</ul>
<h4 id="3-Cloneable接口"><a href="#3-Cloneable接口" class="headerlink" title="(3)Cloneable接口"></a>(3)Cloneable接口</h4><ul>
<li><p>Cloneable接口是Java提供的一组标记接口之一,通常用途是确定一个类实现一个或者一组特定的方法,标记接口不包含任何方法,唯一的作用是允许在类型查询中使用instanceof;</p>
</li>
<li><p>重写方法创建深拷贝的例子</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>        Employee cloned = (Employee) <span class="hljs-keyword">super</span>.clone();<br>        cloned.hireDay = (Date) hireDay.clone();<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-内部类"><a href="#4-3-内部类" class="headerlink" title="4.3 内部类"></a>4.3 内部类</h3><hr>
<h2 id="Chartper5-Exception"><a href="#Chartper5-Exception" class="headerlink" title="Chartper5.Exception"></a>Chartper5.Exception</h2><h3 id="5-1-异常分类"><a href="#5-1-异常分类" class="headerlink" title="5.1 异常分类"></a>5.1 异常分类</h3><ul>
<li>在Java语言中，所有异常对象都是派生于Throwable类的一个实例.</li>
</ul>
<p><img src="https://s3.ax1x.com/2021/01/26/sjCSEQ.png" srcset="/img/loading.gif" alt="异常分类"></p>
<ul>
<li><p>Error类描述了Java运行时系统的内部错误和资源耗尽错误,这种情况很少见;</p>
</li>
<li><p>Exception类分解为两个分支，一个分支派生于RuntimeException(由于程序本身错误),另一个分支包含其他异常,程序本身没有问题,但是由于出现像I/O错误这种的异常叫做其他异常;</p>
<p>eg：派生于RuntimeException的异常包括以下几种情况:错误的类型转换,数组访问越界（ArrayIndexOutOfBoundsException),访问null空指针(NullPointerException)等等;</p>
</li>
<li><p>实际上，派生于Error类或RuntimeException类的所有异常称为非受查异常,所有其他的称为受查异常,编译器将检查所有的受查异常是否提供了异常处理器;</p>
</li>
</ul>
<h3 id="5-2-抛出异常"><a href="#5-2-抛出异常" class="headerlink" title="5.2. 抛出异常"></a>5.2. 抛出异常</h3><ul>
<li><p>方法应在首部使用throws声明所有可能抛出的异常（受查异常，无需声明派生于Error类或RuntimeException类的异常），每个异常用,隔开;</p>
</li>
<li><p>创建异常类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFormatException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOExpection</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<span class="hljs-comment">//也可不写</span><br>&#125;<br><br>...&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileFormatException();<span class="hljs-comment">//抛出这个自己定义的异常</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-3-捕获异常"><a href="#5-3-捕获异常" class="headerlink" title="5.3 捕获异常"></a>5.3 捕获异常</h3></li>
</ul>
<h4 id="1-try-catch语句块"><a href="#1-try-catch语句块" class="headerlink" title="(1)try-catch语句块"></a>(1)try-catch语句块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    code;<br>    more code;<br>&#125;<span class="hljs-keyword">catch</span>(ExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;<span class="hljs-keyword">catch</span>(OtherExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;...<br></code></pre></td></tr></table></figure>
<ul>
<li>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其他代码，抛出的异常直接被所对应的catch捕获并执行catch中的处理器代码;</li>
<li>在catch子句中可以再次抛出一个异常，再之后再进行解决;</li>
</ul>
<h4 id="2-finally子句"><a href="#2-finally子句" class="headerlink" title="(2)finally子句"></a>(2)finally子句</h4><ul>
<li><p>不管是否有异常被捕获，finally子句中的代码都会被执行;一般在需要关闭资源的时候使用finally子句;</p>
</li>
<li><p>当finally子句中包含return语句时，将会出现一种意想不到的效果。假如利用return语句从try语句块中退出，在方法返回前，finally子句的内容将被执行，如果finally子句中也有一个return语句，这个返回值会覆盖原始的返回值;</p>
</li>
</ul>
<h4 id="3-分析堆栈轨迹元素"><a href="#3-分析堆栈轨迹元素" class="headerlink" title="(3)分析堆栈轨迹元素"></a>(3)分析堆栈轨迹元素</h4><ul>
<li>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息;</li>
</ul>
<h3 id="5-4-异常声明碰到继承关系"><a href="#5-4-异常声明碰到继承关系" class="headerlink" title="5.4 异常声明碰到继承关系"></a>5.4 异常声明碰到继承关系</h3><ul>
<li>当重写一个函数时，子类不能比超类声明抛出更多的异常;</li>
<li>在子类的构造函数中,必须声明超类所可能抛出的全部异常;</li>
<li>利用多态(向上转型)的思想去思考这个问题;</li>
</ul>
<hr>
<h2 id="Charpter6-Generic"><a href="#Charpter6-Generic" class="headerlink" title="Charpter6.Generic"></a>Charpter6.Generic</h2><h3 id="6-1-为什么使用泛型"><a href="#6-1-为什么使用泛型" class="headerlink" title="6.1 为什么使用泛型"></a>6.1 为什么使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>		coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>		coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>		coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>		Iterator it = coll.iterator();<br>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>			<span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>			String str = (String) it.next();<br>			System.out.println(str.length());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行程序时，程序报错 java.lang.ClassCastException（类型转换异常）;</p>
<p>因为任何类型的数据都可以强制转换成object类型数据储存在集合中，当我们取出一个对象时，就必须进行强制类型转换，这时候可能会出现类型转换异常，比如这里的5是int类型，int类型不能强制转换为String类;</p>
<h3 id="6-2-泛型概念"><a href="#6-2-泛型概念" class="headerlink" title="6.2 泛型概念"></a>6.2 泛型概念</h3><p>可以在类或方法中预支地使用未知的类型;</p>
<h3 id="6-3-泛型的定义与使用"><a href="#6-3-泛型的定义与使用" class="headerlink" title="6.3 泛型的定义与使用"></a>6.3 泛型的定义与使用</h3><h4 id="1-定义和使用泛型类"><a href="#1-定义和使用泛型类" class="headerlink" title="(1)定义和使用泛型类"></a>(1)定义和使用泛型类</h4><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相当于把String赋值给E</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure>
<h4 id="2-定义和使用泛型方法"><a href="#2-定义和使用泛型方法" class="headerlink" title="(2)定义和使用泛型方法"></a>(2)定义和使用泛型方法</h4><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethod</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode</span><span class="hljs-params">(E e)</span></span>&#123;<br>        System.out.println(e.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethodApplicaton</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ModeMethod m = <span class="hljs-keyword">new</span> ModeMethod();<br>        m.mode(<span class="hljs-number">123</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-定义和使用泛型的接口"><a href="#3-定义和使用泛型的接口" class="headerlink" title="(3)定义和使用泛型的接口"></a>(3)定义和使用泛型的接口</h4><p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型接口：</p>
<p>01.定义类时确定泛型的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>02.始终不确定泛型的类型，直到创建对象时才确定泛型的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-4-泛型通配符"><a href="#6-4-泛型通配符" class="headerlink" title="6.4 泛型通配符"></a>6.4 泛型通配符</h3><h4 id="1-通配符基本使用"><a href="#1-通配符基本使用" class="headerlink" title="(1)通配符基本使用"></a>(1)通配符基本使用</h4><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以使用通配符&lt;?&gt;表示;但是一旦使用泛型的通配符后,只能使用Object类的共性方法,子类自身的方法无法使用</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Collection&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-通配符高级使用-受限泛型"><a href="#2-通配符高级使用-受限泛型" class="headerlink" title="(2) 通配符高级使用-受限泛型"></a>(2) 通配符高级使用-受限泛型</h4><ul>
<li><p>泛型的上限:只能接受该类型以及其子类</p>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? extends 上限类&gt;对象名称<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>泛型的下限:只能接受该类型以及其超类</p>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? <span class="hljs-keyword">super</span> 下限类&gt;对象名称<br></code></pre></td></tr></table></figure>
<p>eg:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="Charpter7-Wrapper-Class"><a href="#Charpter7-Wrapper-Class" class="headerlink" title="Charpter7.Wrapper Class"></a>Charpter7.Wrapper Class</h2><h3 id="7-1-包装类概述"><a href="#7-1-包装类概述" class="headerlink" title="7.1 包装类概述"></a>7.1 包装类概述</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中//无需导包）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h3 id="7-2-包装类的自动装箱、自动拆箱机制"><a href="#7-2-包装类的自动装箱、自动拆箱机制" class="headerlink" title="7.2 包装类的自动装箱、自动拆箱机制"></a>7.2 包装类的自动装箱、自动拆箱机制</h3><p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure>
<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure>
<p>而Java为了方便我们使用，以及出于其他目的如性能调优，给我们提供了自动装箱、拆箱机制。这种机制简化了基本类型和包装类型的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Interger i = <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(100);</span><br>i = i +<span class="hljs-number">200</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 200;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure>
<h3 id="7-3-包装类中的缓存机制"><a href="#7-3-包装类中的缓存机制" class="headerlink" title="7.3 包装类中的缓存机制"></a>7.3 包装类中的缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer num3 = <span class="hljs-number">10</span>;<br>Integer num4 = <span class="hljs-number">10</span>;<br>Integer num5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num6 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num7 = <span class="hljs-number">128</span>;<br>Integer num8 = <span class="hljs-number">128</span>;<br>System.out.println((num3==num4) +<span class="hljs-string">&quot;	&quot;</span>+ num3.equals(num4));<span class="hljs-comment">//ture true</span><br>System.out.println((num5==num6) +<span class="hljs-string">&quot;	&quot;</span>+ num5.equals(num6));<span class="hljs-comment">//false true</span><br>System.out.println((num7==num8) +<span class="hljs-string">&quot;	&quot;</span>+ num7.equals(num8));<span class="hljs-comment">//false true</span><br></code></pre></td></tr></table></figure>
<p>为什么num7==num8会返回false呢,我们来看看底层缓存机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br> <br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br> <br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>当Integer类第一次被使用到，Integer的静态内部类就被加载，加载的时候会创建-128到127的Integer对象，同时创建一个数组cache来缓存这些对象。当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，也就是说不会再新建对象；当使用new关键字or使用valueOf()方法创建小于-128大于127的值对象时，就会创建新对象。</p>
<p>接着,Integer类重写了equals方法,让我们看看equals方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>equals方法重写后比较两个Integer对象的值,所以确定两个Integer对象的值是否相等时,应该使用equals方法而非简单的==,否则因为缓冲机制可能会带来一些问题;</p>
<p>此外，在8种包装类型中，有缓存区的有Character、Byte、Short、Integer、Long，而且它们的实现方式基本一样，都是-128到127的缓存范围。Boolean虽然没有缓存区，但是因为只有两个值true、false，所以Boolean在成员变量中就创建了两个相应的对象。没有缓存区的只有Float、Double，之所以没有原因很简单，即便是0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</p>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h3 id="7-4-包装类使用过程中有可能引起的空指针异常"><a href="#7-4-包装类使用过程中有可能引起的空指针异常" class="headerlink" title="7.4 包装类使用过程中有可能引起的空指针异常"></a>7.4 包装类使用过程中有可能引起的空指针异常</h3><p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-keyword">null</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure>
<p>此时会出现NullPointerException;需要注意</p>
<p>//Reference:<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_30973431/article/details/89332443">Java中的包装类</a></p>
<hr>
<h2 id="Charpter8-Collection"><a href="#Charpter8-Collection" class="headerlink" title="Charpter8.Collection"></a>Charpter8.Collection</h2><h3 id="8-1-Introduction"><a href="#8-1-Introduction" class="headerlink" title="8.1 Introduction"></a>8.1 Introduction</h3><p><img src="https://s3.ax1x.com/2021/01/28/yCmIL8.png" srcset="/img/loading.gif" alt="概述"></p>
<p><img src="https://s3.ax1x.com/2021/01/30/yAPzNj.png" srcset="/img/loading.gif" alt="Collection"></p>
<p>集合是Java中的一种容器，可以用来存储多个数据。</p>
<ul>
<li><p>集合和数组的区别</p>
<p>(1)长度区别:数组的长度固定,集合的长度可变;</p>
<p>(2)内容区别:数组可以存储基本数据类型,也能存储引用类型,而集合只能存储引用类型;</p>
<p>(3)元素区别:数组中的元素必须是同一类型,集合可以存储不同类型的数据;</p>
</li>
<li><p>集合分两大类,单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p>
</li>
<li><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p>
</li>
</ul>
<h3 id="8-2-Collection接口常用方法"><a href="#8-2-Collection接口常用方法" class="headerlink" title="8.2 Collection接口常用方法"></a>8.2 Collection接口常用方法</h3><ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;az&quot;</span>);<br>        col.remove(<span class="hljs-string">&quot;az&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> hasJava = col.contains(<span class="hljs-string">&quot;Java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hasJava = &quot;</span> + hasJava);<br>        Iterator&lt;String&gt; it = col.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String next = it.next();<br>            System.out.println(<span class="hljs-string">&quot;next = &quot;</span> + next);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        col.clear();<br>        <span class="hljs-keyword">boolean</span> empty = col.isEmpty();<br>        System.out.println(<span class="hljs-string">&quot;empty = &quot;</span> + empty);<br>        col.add(<span class="hljs-string">&quot;had&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;String&quot;</span>);<br>        <span class="hljs-keyword">int</span> size = col.size();<br>        System.out.println(<span class="hljs-string">&quot;size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        Object[] obj = col.toArray();<br>        <span class="hljs-keyword">for</span> (Object o : obj) &#123;<br>            System.out.println(o);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Map,List,Set接口中有一个静态方法of(),方便用于建立少量且元素数目不可变的集合(of()方法只能用于这三个接口,其子类没有)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="8-3-Iterator迭代器"><a href="#8-3-Iterator迭代器" class="headerlink" title="8.3 Iterator迭代器"></a>8.3 Iterator迭代器</h3><ul>
<li><p>Iterator接口主要用于迭代遍历Collection中的元素;</p>
</li>
<li><p>获取迭代器:<code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p>
</li>
<li><p>常用方法:</p>
<p><code>public E next()</code>:返回迭代的下一个元素。</p>
<p><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</p>
<p><code>public void remove()</code>：删除迭代器新返回的元素。</p>
</li>
<li><p>通过迭代器实现遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过迭代器清空集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            it.next();<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>一些细节:</p>
<p>如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常;</p>
<p>如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException;</p>
<p>在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，java会抛出异常并发修改异常（ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p>
<p>(Reference:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33642117/article/details/52039691">Java迭代器Iterator的详解</a></p>
</li>
</ul>
<h3 id="8-4-List集合"><a href="#8-4-List集合" class="headerlink" title="8.4 List集合"></a>8.4 List集合</h3><h4 id="1-List接口"><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h4><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引index的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<h4 id="2-List接口中的常用方法"><a href="#2-List接口中的常用方法" class="headerlink" title="(2)List接口中的常用方法"></a>(2)List接口中的常用方法</h4><ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        String s = list.get(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;list.remove(0) = &quot;</span> + list.remove(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;list.set(0,\&quot;reflect\&quot;) = &quot;</span> + list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;reflect&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-ArrayList集合"><a href="#3-ArrayList集合" class="headerlink" title="(3)ArrayList集合"></a>(3)ArrayList集合</h4><p><code>java.util.ArrayList</code>集合的底层是数组，元素增删慢，查找快，线程不安全，效率高，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<h4 id="4-LinkedList集合"><a href="#4-LinkedList集合" class="headerlink" title="(4)LinkedList集合"></a>(4)LinkedList集合</h4><p><code>java.util.LinkedList</code>集合的底层是双向链表，元素增删快，查找慢，线程不安全，效率高。</p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
</ul>
<h4 id="5-Vector集合"><a href="#5-Vector集合" class="headerlink" title="(5)Vector集合"></a>(5)Vector集合</h4><p><code>java.util.Vector</code>集合的底层是数组，元素增删慢，查询快，线程安全，效率低。</p>
<h3 id="8-5-Set接口"><a href="#8-5-Set接口" class="headerlink" title="8.5 Set接口"></a>8.5 Set接口</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)特点"></a>(1)特点</h4><ol>
<li>它是一个元素存取无序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就不一定按照11、22、33的顺序完成的,可能是22、33、11）。</li>
<li>它是没有索引的集合。</li>
<li>集合中不可以有重复的元素。</li>
</ol>
<h4 id="2-HashSet集合"><a href="#2-HashSet集合" class="headerlink" title="(2)HashSet集合"></a>(2)HashSet集合</h4><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<ul>
<li>hashCode:是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li>
</ul>
<h4 id="3-Set集合不允许重复的原理"><a href="#3-Set集合不允许重复的原理" class="headerlink" title="(3)Set集合不允许重复的原理"></a>(3)Set集合不允许重复的原理</h4><p>hashCode值相同<strong>且</strong>equals方法返回值为true时判断重复,不允许进行操作;</p>
<p>存储的包装类必须重写hashCode方法和equals方法;</p>
<h4 id="4-HashSet存储自定义类元素"><a href="#4-HashSet存储自定义类元素" class="headerlink" title="(4)HashSet存储自定义类元素"></a>(4)HashSet存储自定义类元素</h4><ul>
<li>需要重写hashCode方法和equals方法，否则不允许重复会被打破；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashSet&lt;Person&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Person person01 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>        Person person02 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        Person person03 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        set.add(person01);<br>        set.add(person02);<br>        set.add(person03);<br>        Iterator&lt;Person&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Person p = it.next();<br>            System.out.println(p);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;person01.hashCode() = &quot;</span> + person01.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person02.hashCode() = &quot;</span> + person02.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person03.hashCode() = &quot;</span> + person03.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>未重写hashCode和equals方法前输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>person01.hashCode() = <span class="hljs-number">1967205423</span><br>person02.hashCode() = <span class="hljs-number">42121758</span><br>person03.hashCode() = <span class="hljs-number">20671747</span><br></code></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//先用==暴力判断</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//如果比较的对象为null或者两者属于不同的类型直接返回false</span><br>        Person person = (Person) o;<span class="hljs-comment">//向下转型</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;<br>                Objects.equals(name, person.name);<span class="hljs-comment">//第一个参数和第二个参数均相同</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>重写hashCode和equals方法后输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>person01.hashCode() = <span class="hljs-number">24022538</span><br>person02.hashCode() = <span class="hljs-number">26104871</span><br>person03.hashCode() = <span class="hljs-number">26104871</span><br></code></pre></td></tr></table></figure>
<p>关于重写hashCode和equals方法:<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012557538/article/details/89861552">重写hashCode和equals方法</a></p>
<h4 id="5-LinkedHashSet"><a href="#5-LinkedHashSet" class="headerlink" title="(5)LinkedHashSet"></a>(5)LinkedHashSet</h4><p>LinkedHashSet的底层数据结构是HashMap和链表,可以保证元素唯一且有序，线程不安全，效率高。</p>
<h3 id="8-6-Collections"><a href="#8-6-Collections" class="headerlink" title="8.6 Collections"></a>8.6 Collections</h3><h4 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="(1)常用功能"></a>(1)常用功能</h4><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</p>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(list,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;liuliang&quot;</span>);<br>        Collections.shuffle(list);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br>[lisi, zhangsan, liuliang]<br>[lisi, liuliang, zhangsan]<br></code></pre></td></tr></table></figure>
<h4 id="2-重写Comparable接口中的compareTo方法"><a href="#2-重写Comparable接口中的compareTo方法" class="headerlink" title="(2)重写Comparable接口中的compareTo方法"></a>(2)重写Comparable接口中的compareTo方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangermazi&quot;</span>,<span class="hljs-number">23</span>));<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br><span class="hljs-comment">//        return 0;</span><br><span class="hljs-comment">//        return this.age - o.age ;//按年龄升序</span><br>        <span class="hljs-keyword">return</span> o.age - <span class="hljs-keyword">this</span>.age;<span class="hljs-comment">//按年龄降序</span><br>    &#125;<br>&#125;<br><br>升序:[Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;]<br>降序:[Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;]<br></code></pre></td></tr></table></figure>
<h4 id="3-Comparator比较器"><a href="#3-Comparator比较器" class="headerlink" title="(3)Comparator比较器"></a>(3)Comparator比较器</h4><ul>
<li><p>Comparable和Comparator的区别:</p>
<p>Comparable:this(自己)和别人(参数)比较,自己需要实现Comparable接口,重写比较规则的compareTo方法</p>
<p>Comparator:相当于找一个第三方的裁判对两者进行比较</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">12</span>));<br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge() - o1.getAge();<br>                <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>                    result = o2.getName().charAt(<span class="hljs-number">0</span>) - o1.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span>  result;<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Student&#123;name=<span class="hljs-string">&#x27;xiaoming&#x27;</span>, age=<span class="hljs-number">17</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">12</span>&#125;]<br></code></pre></td></tr></table></figure>
<h2 id="Charpter9-Map"><a href="#Charpter9-Map" class="headerlink" title="Charpter9.Map"></a>Charpter9.Map</h2><h3 id="9-1-Introduction"><a href="#9-1-Introduction" class="headerlink" title="9.1 Introduction"></a>9.1 Introduction</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<ul>
<li><p>Map&lt;K,V&gt; K(Key)-代表键的类型  V(Value)-代表值的类型；</p>
</li>
<li><p>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。通过键可以找到对应的值；</p>
</li>
</ul>
<h3 id="9-2-Map接口中的常用方法"><a href="#9-2-Map接口中的常用方法" class="headerlink" title="9.2 Map接口中的常用方法"></a>9.2 Map接口中的常用方法</h3><ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Hint:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
<h3 id="9-3-Map集合的遍历方式"><a href="#9-3-Map集合的遍历方式" class="headerlink" title="9.3 Map集合的遍历方式"></a>9.3 Map集合的遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * `public Set&lt;K&gt; keySet()`: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment"> * `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">50</span>);<br>        map.put(<span class="hljs-string">&quot;李鬼&quot;</span>,<span class="hljs-number">10086</span>);<br><br>        <span class="hljs-comment">/* 1.使用keySet方法先获取map集合中的key存到新的Set集合中</span><br><span class="hljs-comment">           2.然后使用map集合的get方法获取value</span><br><span class="hljs-comment">           3.foreach循环遍历输出即可</span><br><span class="hljs-comment">        */</span><br><span class="hljs-comment">//        Set&lt;String&gt; containKeySet = map.keySet();</span><br><span class="hljs-comment">//        for (String key : containKeySet) &#123;</span><br><span class="hljs-comment">//            Integer values = map.get(key);</span><br><span class="hljs-comment">//            System.out.println(key+values);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">/*  1.使用map集合里的entrySet方法获取map集合里的键值对到新的Set集合中</span><br><span class="hljs-comment">            2.利用entry中的getKey方法和geyValue方法获取key和value,根据所需输出</span><br><span class="hljs-comment">            Hint:也可以直接使用foreach循环输出Set集合,得到的是key=value这样的格式效果</span><br><span class="hljs-comment">         */</span><br>        <br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; maps : set) &#123;<br>            String key = maps.getKey();<br>            Integer value = maps.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;对应&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="9-4-LinkedHashMap"><a href="#9-4-LinkedHashMap" class="headerlink" title="9.4 LinkedHashMap"></a>9.4 LinkedHashMap</h3><p>LinkedHashMap的底层是哈希表和双向链表,双向链表用于维护键值对的顺序,所以该集合是有序的;</p>
<h3 id="9-5-综合练习"><a href="#9-5-综合练习" class="headerlink" title="9.5 综合练习"></a>9.5 综合练习</h3><h4 id="9-5-1-字符出现次数"><a href="#9-5-1-字符出现次数" class="headerlink" title="9.5.1 字符出现次数"></a>9.5.1 字符出现次数</h4><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li> 获取一个字符串对象</li>
<li> 创建一个Map集合，键代表字符，值代表次数。</li>
<li> 遍历字符串得到每个字符。</li>
<li> 判断Map中是否有该键。</li>
<li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li> 打印最终结果</li>
</ol>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character tmp:s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(tmp)==<span class="hljs-keyword">null</span>)&#123;<br>                map.put(tmp,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                Integer sum = map.get(tmp);<br>                sum++;<br>                map.put(tmp,sum);<br>            &#125;<br>        &#125;<br>        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : set) &#123;<br>            Character key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(<span class="hljs-string">&quot;出现&quot;</span>+key+<span class="hljs-string">&quot;的次数为&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="9-5-2-斗地主有序版"><a href="#9-5-2-斗地主有序版" class="headerlink" title="9.5.2 斗地主有序版"></a>9.5.2 斗地主有序版</h4><p><strong>需求:</strong></p>
<ol>
<li> 准备牌：</li>
</ol>
<p>完成数字与纸牌的映射关系：</p>
<p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li> 洗牌：</li>
</ol>
<p>通过数字完成洗牌发牌</p>
<ol start="3">
<li> 发牌：</li>
</ol>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li> 看牌：</li>
</ol>
<p>通过Map集合找到对应字符展示。</p>
<p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:1.  准备牌：完成数字与纸牌的映射关系：</span><br><span class="hljs-comment">使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</span><br><span class="hljs-comment">         */</span><br>        List&lt;String&gt; colors = List.of(<span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        List&lt;String&gt; numbers = List.of(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        List&lt;Integer&gt; pokerIndex = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Integer,String&gt; poker = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Integer index=<span class="hljs-number">0</span>;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;大王&quot;</span>);<br>        index++;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;小王&quot;</span>);<br>        index++;<br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                pokerIndex.add(index);<br>                poker.put(index,color+number);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*  2.洗牌通过数字完成洗牌发牌</span><br><span class="hljs-comment">         */</span><br>        Collections.shuffle(pokerIndex);<br><br><span class="hljs-comment">//        System.out.println(pokerIndex);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</span><br><span class="hljs-comment">        存放的过程中要求数字大小与斗地主规则的大小对应。</span><br><span class="hljs-comment">        将代表不同纸牌的数字分配给不同的玩家与底牌。</span><br><span class="hljs-comment">         */</span><br>        ArrayList&lt;Integer&gt; player01 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player02 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player03 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; temppoker = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Integer count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : pokerIndex) &#123;<br>            <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">50</span>)&#123;<br>                temppoker.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                player01.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<br>                player02.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">2</span>)&#123;<br>                player03.add(num);<br>            &#125;<br>            count++;<br>        &#125;<br>        Collections.sort(player01);<br>        Collections.sort(player02);<br>        Collections.sort(player03);<br>        Collections.sort(temppoker);<br><br><span class="hljs-comment">//        System.out.println(player01);</span><br><span class="hljs-comment">//        System.out.println(player02);</span><br><span class="hljs-comment">//        System.out.println(player03);</span><br><span class="hljs-comment">//        System.out.println(temppoker);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        4.  看牌：通过Map集合找到对应字符展示。</span><br><span class="hljs-comment">通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</span><br><span class="hljs-comment">         */</span><br>        search(<span class="hljs-string">&quot;周润发&quot;</span>,player01,poker);<br>        search(<span class="hljs-string">&quot;刘德华&quot;</span>,player02,poker);<br>        search(<span class="hljs-string">&quot;古天乐&quot;</span>,player03,poker);<br>        search(<span class="hljs-string">&quot;底牌&quot;</span>,temppoker,poker);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(String name,ArrayList list,Map poker)</span> </span>&#123;<br>        List&lt;Object&gt; listed = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            Object o1 = poker.get(o);<br>            listed.add(o1);<br>        &#125;<br>        System.out.print(name+<span class="hljs-string">&quot;:&quot;</span>);<br>        Iterator&lt;Object&gt; it = listed.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object next = it.next();<br>            System.out.print(next+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br>输出：<br>周润发:大王 ♦<span class="hljs-number">2</span> ♠<span class="hljs-number">2</span> ♠K ♣Q ♠Q ♣<span class="hljs-number">9</span> ♥<span class="hljs-number">8</span> ♠<span class="hljs-number">8</span> ♣<span class="hljs-number">7</span> ♥<span class="hljs-number">7</span> ♦<span class="hljs-number">6</span> ♥<span class="hljs-number">6</span> ♠<span class="hljs-number">6</span> ♠<span class="hljs-number">5</span> ♣<span class="hljs-number">4</span> ♥<span class="hljs-number">4</span> ♠<span class="hljs-number">4</span> <br>刘德华:♥<span class="hljs-number">2</span> ♣A ♠A ♦K ♣K ♣J ♥J ♠J ♦<span class="hljs-number">10</span> ♥<span class="hljs-number">10</span> ♠<span class="hljs-number">10</span> ♦<span class="hljs-number">9</span> ♥<span class="hljs-number">9</span> ♠<span class="hljs-number">9</span> ♣<span class="hljs-number">6</span> ♣<span class="hljs-number">5</span> ♥<span class="hljs-number">5</span> ♥<span class="hljs-number">3</span> <br>古天乐:小王 ♣<span class="hljs-number">2</span> ♦A ♥A ♥K ♦Q ♥Q ♦J ♣<span class="hljs-number">10</span> ♦<span class="hljs-number">8</span> ♣<span class="hljs-number">8</span> ♦<span class="hljs-number">7</span> ♠<span class="hljs-number">7</span> ♦<span class="hljs-number">5</span> ♦<span class="hljs-number">4</span> ♦<span class="hljs-number">3</span> ♣<span class="hljs-number">3</span> ♠<span class="hljs-number">3</span> <br>底牌:♠<span class="hljs-number">2</span> ♥Q ♥<span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure>
<h2 id="Charpter10-MultiThreading"><a href="#Charpter10-MultiThreading" class="headerlink" title="Charpter10.MultiThreading"></a>Charpter10.MultiThreading</h2><h3 id="10-1-并发与并行"><a href="#10-1-并发与并行" class="headerlink" title="10.1 并发与并行"></a>10.1 并发与并行</h3><ul>
<li><p><strong>并发</strong>:指两个或多个事件在同一个时间段内发生;</p>
</li>
<li><p><strong>并行</strong>:指两个或多个事件在同一个时间点发生;</p>
</li>
</ul>
<h3 id="10-2-线程与进程"><a href="#10-2-线程与进程" class="headerlink" title="10.2 线程与进程"></a>10.2 线程与进程</h3><ul>
<li><p><strong>进程</strong>:是指一个内存中运行的应用程序,一个应用程序可以同时进行多个进程,进程是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建,运行到消亡的过程;</p>
</li>
<li><p><strong>线程</strong>:是进程中的一个执行单元,负责当前进程中程序的执行;一个进程中可以有单线程或者多线程;</p>
</li>
<li><p><strong>线程调度</strong>:</p>
<p>(1)分时调度:所有线程轮流获得CPU的使用权,平均分配每个线程占用CPU的时间;</p>
<p>(2)抢占调度:优先让优先级高的线程使用CPU,如果线程的优先级相同,那么会随机选择一个使用CPU;<strong>Java就是使用抢占调度的方式</strong></p>
</li>
</ul>
<h3 id="10-3-线程类"><a href="#10-3-线程类" class="headerlink" title="10.3 线程类"></a>10.3 线程类</h3><p><code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread thread = <span class="hljs-keyword">new</span> TestThread();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+<span class="hljs-string">&quot;This is my thread!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常用API:</strong></p>
<ul>
<li><p><code>public Thread</code>:分配一个新线程对象。</p>
</li>
<li><p><code>public Thread(String name) </code>:分配一个指定名字的新的线程对象。</p>
</li>
<li><p><code>public Thread(Runnable target) </code>:分配一个带有指定目标新的线程对象</p>
</li>
<li><p><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。 </p>
</li>
<li><p><code>public String getName() </code>:获取当前线程名称。 </p>
</li>
<li><p><code>public void start() </code>:导致此线程开始执行; Java虚拟机调用此线程的run方法</p>
</li>
<li><p><code>public void run() </code>:此线程要执行的任务在此处定义代码。 </p>
</li>
<li><p><code>public static void sleep(long millis) </code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。//需要用try-catch语句可能抛出printStackTrace异常</p>
</li>
<li><p><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p>
</li>
</ul>
<h3 id="10-4-Runnable接口"><a href="#10-4-Runnable接口" class="headerlink" title="10.4 Runnable接口"></a>10.4 Runnable接口</h3><ul>
<li><p>通过实现Runnable接口来开启多线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	1.定义Runnable接口的实现类,重写run()方法;</span><br><span class="hljs-comment">	2.创建Runnable实现类的实例对象,并以此实例对象作为Thread的参数来创建Thread对象</span><br><span class="hljs-comment">	3.启用Thread对象的start()方法来开启多线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>       thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;这是第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过实现Runnable接口开启多线程的优势:</p>
<p>1.可以避免java单继承的局限性(继承了Thread就不能继承其他类)</p>
<p>2.使代码可以被多个线程共享,实现代码和线程独立</p>
<p>3.线程池只能放入实现Runnable或Callable类线程,不能直接放入继承Thread的类</p>
</li>
</ul>
<h3 id="10-5-通过匿名内部类实现创建线程"><a href="#10-5-通过匿名内部类实现创建线程" class="headerlink" title="10.5 通过匿名内部类实现创建线程"></a>10.5 通过匿名内部类实现创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;这是匿名内部类创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="10-6-引出线程安全问题"><a href="#10-6-引出线程安全问题" class="headerlink" title="10.6 引出线程安全问题"></a>10.6 引出线程安全问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    引出问题:在电影票卖票有多个售票窗口卖票,且这多个售票窗口共享需要兜售的票资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>        Thread thread01 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread02 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread03 = <span class="hljs-keyword">new</span> Thread(run);<br>        thread01.start();<br>        thread02.start();<br>        thread03.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">20</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">18</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">19</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">16</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">14</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">12</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">10</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">8</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">6</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">4</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">2</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">1</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">0</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第-<span class="hljs-number">1</span>张票<br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p> 在这里出现了卖重复的票和卖0/-1这种不存在的票，几个线程共享使用数据导致票数不同步，这种问题称为线程不安全。</p>
<h3 id="10-7-线程同步"><a href="#10-7-线程同步" class="headerlink" title="10.7 线程同步"></a>10.7 线程同步</h3><p>为了解决线程安全问题，Java中提供了同步机制(synchronized)来解决;</p>
<h4 id="10-7-1-同步代码块"><a href="#10-7-1-同步代码块" class="headerlink" title="10.7.1 同步代码块"></a>10.7.1 同步代码块</h4><ul>
<li><code>synchronized</code>关键字可以用于方法的某个区块中,表示对这个区块的资源实行互斥访问;</li>
</ul>
<p>创建格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>同步锁:可以是任意类型(Object)的对象,注意多个线程对象要使用同一把同步锁;在开启多线程时，仅允许一个线程拿到同步锁，谁拿到同步锁即获得CPU的使用权,其他的线程得等该线程完成代码块释放锁后拿到锁才能执行;</li>
</ul>
<p>针对上面线程安全问题的优化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="10-7-2-同步方法"><a href="#10-7-2-同步方法" class="headerlink" title="10.7.2 同步方法"></a>10.7.2 同步方法</h4><ul>
<li>可以使用<code>synchronized</code>修饰方法使方法成为同步方法;</li>
</ul>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> methodName&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure>
<p>针对上面线程安全问题的优化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                 System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>同步方法本质也使用了同步锁,对于非静态方法,同步锁就是this;对于静态方法,同步锁就是当前方法所在类的字节码对象(类名.class)</li>
</ul>
<h4 id="10-7-3-Lock锁"><a href="#10-7-3-Lock锁" class="headerlink" title="10.7.3 Lock锁"></a>10.7.3 Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁操作;优化了加锁和释放锁的方式;</p>
<ul>
<li><code>public void lock();</code>加同步锁;</li>
<li><code>public void unlock();</code>释放同步锁;</li>
</ul>
<p><code>ReentrantLock</code>是一个互斥锁，也是一个<strong>可重入锁</strong>（Reentrant就是再次进入的意思）。<code>ReentrantLock</code>锁在同一个时间点只能被一个线程锁持有，但是它可以被单个线程多次获取，每获取一次<code>AQS</code>的<code>state</code>就加1，每释放一次<code>state</code>就减1。</p>
<p>针对上面线程安全问题的优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>注意如果使用try-catch代码块,一定要把unlock()过程放到finally里,防止程序抛出了异常而一直不释放锁;</li>
</ul>
<h3 id="10-8-线程状态"><a href="#10-8-线程状态" class="headerlink" title="10.8 线程状态"></a>10.8 线程状态</h3><p>在线程的生命周期中,会呈现不同的线程状态;</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New</td>
<td>线程刚被创建，但还并未启动，还没调用start方法</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程在JVM中运行的状态</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个同步锁，而该锁已被其他对象占有，则该线程进入Blocked状态;等该线程获取到锁时，转变为Runnable状态;</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行唤醒动作时,该线程进入Waiting状态.进入该状态不能主动唤醒,必须等待另一个线程调用notify方法;（当我们调用Thread.sleep(time);方法时,线程进入睡眠状态也就是TimedWaiting状态，等待时间到后自动唤醒;或者使用带参数的wait方法也可;）</td>
</tr>
<tr>
<td>TimedWaiting(计时等待)</td>
<td>类似于waiting状态,但是传入了一个参数,在一直没有另一个线程唤醒时,到了超时参数后会自动唤醒;</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出或者是因为没有捕获的异常终止了run方法而导致线程被终止</td>
</tr>
</tbody></table>
<h3 id="10-9-等待唤醒机制"><a href="#10-9-等待唤醒机制" class="headerlink" title="10.9 等待唤醒机制"></a>10.9 等待唤醒机制</h3><ul>
<li><p>常用方法:</p>
<p><code>Object.wait()</code>:使线程不再执行操作,进入waitset,等待notify使其回到readyset;</p>
<p><code>Object.notify()</code>:使所选取对象的一个线程释放;</p>
<p><code>Object.notifyAll()</code>:使所选取对象的所有线程释放;</p>
</li>
</ul>
<p>包子铺卖包子问题代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    包子铺卖包子问题:</span><br><span class="hljs-comment">        1.创建包子类,内有包子的皮和馅料实例,还有包子的状态(有或无);</span><br><span class="hljs-comment">        2.创建包子铺类,当包子的状态为无时就被唤醒做包子,做完后将包子状态改为有,唤醒买家;当包子的状态为有时就休眠;</span><br><span class="hljs-comment">        3.创建买家类,当包子的状态为有时就被唤醒买包子吃,吃完后将包子状态改为无,唤醒包子铺;当包子的状态为无时就休眠;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>        BaoZiPu baoZiPu = <span class="hljs-keyword">new</span> BaoZiPu(bz);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(bz);<br>        Thread baoziputhread = <span class="hljs-keyword">new</span> Thread(baoZiPu);<br>        Thread consumerthread = <span class="hljs-keyword">new</span> Thread(consumer);<br>        baoziputhread.start();<br>        consumerthread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String pi;<br>    <span class="hljs-keyword">public</span> String xian;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> state = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;店家正在做包子,请等待!&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;肉&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;厚皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;韭菜&quot;</span>;<br>                    &#125;<br>                    flag++;<br>                    bz.state = <span class="hljs-keyword">true</span>;<br>                    bz.notify();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bz = bz;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;我买了这个&quot;</span> + bz.pi + bz.xian + <span class="hljs-string">&quot;包子,一秒钟吃完!&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">1000</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        bz.state = <span class="hljs-keyword">false</span>;<br>                        System.out.println(<span class="hljs-string">&quot;吃完了,针不戳!&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>                        bz.notify();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            bz.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个厚皮韭菜包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>......<br></code></pre></td></tr></table></figure>
<h3 id="10-10-线程池"><a href="#10-10-线程池" class="headerlink" title="10.10 线程池"></a>10.10 线程池</h3><ul>
<li><strong>概念：</strong>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li>
</ul>
<h2 id="Charpter11-File"><a href="#Charpter11-File" class="headerlink" title="Charpter11.File"></a>Charpter11.File</h2><h3 id="11-1-Introduction"><a href="#11-1-Introduction" class="headerlink" title="11.1 Introduction"></a>11.1 Introduction</h3><p><code>java.io.File</code>类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h3 id="11-2-构造方法"><a href="#11-2-构造方法" class="headerlink" title="11.2 构造方法"></a>11.2 构造方法</h3><ul>
<li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li>
<li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	使用public File(String pathname) </span><br><span class="hljs-comment">*/</span><br>		String pathname = <span class="hljs-string">&quot;D:\\a.txt&quot;</span>;<br>        File file = <span class="hljs-keyword">new</span> File(pathname);<br>        System.out.println(<span class="hljs-string">&quot;file = &quot;</span> + file);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	使用public File(String parent, String child) </span><br><span class="hljs-comment">*/</span><br>        String parent = <span class="hljs-string">&quot;D:\\&quot;</span>;<br>        String child = <span class="hljs-string">&quot;c.txt&quot;</span>;<br>        File file2 = <span class="hljs-keyword">new</span> File(parent,child);<br>        System.out.println(file2);<br>        child = <span class="hljs-string">&quot;d.txt&quot;</span>;<br>        file2 = <span class="hljs-keyword">new</span> File(parent,child);<br>        System.out.println(file2);<br></code></pre></td></tr></table></figure>
<ul>
<li>Hint:无论File类对象保存的路径是否存在,都不影响File对象的创建;</li>
</ul>
<h3 id="11-3-分隔符问题"><a href="#11-3-分隔符问题" class="headerlink" title="11.3 分隔符问题"></a>11.3 分隔符问题</h3><ul>
<li><p>在File类中,有四个静态变量：</p>
<p><code>static String pathSeparator</code> 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。<br><code>static char pathSeparatorChar</code> 与系统有关的路径分隔符。</p>
<p><code>static String separator</code> 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。<br><code>static char separatorChar</code> 与系统有关的默认名称分隔符。</p>
</li>
<li><p>```<br>static String pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。<br>static char pathSeparatorChar 与系统有关的路径分隔符。</p>
<p>static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。<br>static char separatorChar 与系统有关的默认名称分隔符。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>* 在Windows操作系统中,路径分隔符pathSeparator为分号<span class="hljs-string">&quot;;&quot;</span>,在Linux操作系统中,路径分隔符为冒号<span class="hljs-string">&quot;:&quot;</span><br><br>* 在Windows操作系统中,默认名称分隔符separator为反斜杠<span class="hljs-string">&quot;\\&quot;</span>,在Linux操作系统中,路径分隔符为正斜杠<span class="hljs-string">&quot;/&quot;</span><br><br>* 因为带\的为转义字符,所以理论上的\应写成两个\才能表示;比如`C:\windows\a.txt`在代码中就应该写成`C:\\windows\\a.txt`<br><br>### <span class="hljs-number">11.4</span> 绝对路径和相对路径<br><br>* 老生常谈的问题<br><span class="hljs-operator">  * </span>**绝对路径**：从盘符开始的路径，这是一个完整的路径。<br><span class="hljs-operator">  * </span>**相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。<br><br>### <span class="hljs-number">11.5</span> File类常用的方法<br><br>* `public String get<span class="hljs-constructor">AbsolutePath()</span> ` ：返回此File的绝对路径名字符串。<br><br>* ` public String get<span class="hljs-constructor">Path()</span> ` ：将此File转换为路径名字符串。 <br><br>* `public String get<span class="hljs-constructor">Name()</span>`  ：返回由此File表示的文件或目录的名称。  <br><br>* `public long length<span class="hljs-literal">()</span>`  ：返回由此File表示的文件的字节大小 。<br><br>  (如果File对象表示的是目录的话,在JDK8返回值为<span class="hljs-number">0</span>，在JDK11返回值为<span class="hljs-number">4096</span>)<br><br>```java<br>        String pathname = <span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo\\a.txt&quot;</span>;<br>        File file1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">pathname</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">AbsoluteFile()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">Path()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.get<span class="hljs-constructor">Name()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file1.length<span class="hljs-literal">()</span>);<br><br>        File file2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;a.txt&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file2.get<span class="hljs-constructor">AbsoluteFile()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file2.get<span class="hljs-constructor">Path()</span>);<br><br>        File file3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file3.length<span class="hljs-literal">()</span>);<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        输出结果:</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        a.txt</span><br><span class="hljs-comment">        6</span><br><span class="hljs-comment">        E:\Test code\Java\IODemo\a.txt</span><br><span class="hljs-comment">        a.txt</span><br><span class="hljs-comment">        0</span><br><span class="hljs-comment">        */</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</p>
</li>
<li><p><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</p>
</li>
<li><p><code>public boolean isFile()</code> ：此File表示的是否为文件。</p>
</li>
<li><p><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </p>
<blockquote>
<p>注意:<br>1.此方法只能创建文件,不能创建文件夹<br>2.创建文件的路径必须存在,否则会抛出异常</p>
</blockquote>
</li>
<li><p><code>public boolean delete()</code> ：删除由此File表示的文件或目录。如果此File表示目录，则目录必须为空才能删除。delete方法是直接在硬盘删除文件/文件夹,不走回收站。</p>
</li>
<li><p><code>public boolean mkdir()</code> ：创建由此File表示的目录。mkdir = make directory；</p>
</li>
<li><p><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。（可以创建多级文件夹）</p>
</li>
</ul>
<ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
</ul>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    File file = <span class="hljs-keyword">new</span> File(E:\\Test code\\Java);<br>    String[] dic = file.list();<br>    <span class="hljs-keyword">for</span>(String name : dic)&#123;<br>        System.out.println(name);<br>    &#125;<br>    File[] files = file.listFiles();<br>    <span class="hljs-keyword">for</span> (File file0 : files) &#123;<br>            System.out.println(file0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>递归打印多级目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDir</span><span class="hljs-params">(File dir)</span></span>&#123;<br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span>( File file : dir )&#123;<br>            <span class="hljs-keyword">if</span>(file.isFile())&#123;<br>			System.out.println(<span class="hljs-string">&quot;文件名:&quot;</span>+file.getAbsolutePath())&#125;;<br>        	&#125;<span class="hljs-keyword">else</span>&#123;<br>            	System.out.println(<span class="hljs-string">&quot;目录:&quot;</span>+file.getAbsolutePath());<br>            	<span class="hljs-comment">//如果是目录的话继续递归</span><br>            	printDir(file);<br>        	&#125;<br>   		 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="Charpter12-IOStream"><a href="#Charpter12-IOStream" class="headerlink" title="Charpter12. IOStream"></a>Charpter12. IOStream</h2><h3 id="12-1-Classfication"><a href="#12-1-Classfication" class="headerlink" title="12.1 Classfication"></a>12.1 Classfication</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。一般来说，涉及中文输入输出使用字符流;</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<strong>InputStream</strong></td>
<td align="center">字节输出流<strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<strong>Reader</strong></td>
<td align="center">字符输出流<strong>Writer</strong></td>
</tr>
</tbody></table>
<h3 id="12-2-字节流"><a href="#12-2-字节流" class="headerlink" title="12.2 字节流"></a>12.2 字节流</h3><h4 id="12-2-1-一切皆为字节"><a href="#12-2-1-一切皆为字节" class="headerlink" title="12.2.1 一切皆为字节"></a>12.2.1 一切皆为字节</h4><p>一切文件数据（无论是文本，图片还是视频等）在存储时都是以二进制数据的形式保存，都是一个一个的字节，在传输时候也是如此。所以字节流可以传输任意文件数据。底层传输的始终是二进制的数据。</p>
<h4 id="12-2-2-OutputStream"><a href="#12-2-2-OutputStream" class="headerlink" title="12.2.2 OutputStream"></a>12.2.2 OutputStream</h4><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<h4 id="12-2-3-FileOutputStream"><a href="#12-2-3-FileOutputStream" class="headerlink" title="12.2.3 FileOutputStream"></a>12.2.3 FileOutputStream</h4><ul>
<li><code>FileOutputStream</code>是<code>java.io.OutputStream</code>类的子类,用于文件输出流,将数据写出到文件中;</li>
<li><strong>构造方法</strong>:<ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>写出字节数据</strong>:会抛出IOException</p>
<blockquote>
<p>一次写多个字节:<br>如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表<br>如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK)</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;*<br>	public abstract void write(int b) ：将指定的字节输出流。<br>*&#x2F;<br>		FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        fos.write(97);<br>        fos.write(85);<br>        fos.close();<br>&#x2F;&#x2F; 结果:aU<br>&#x2F;*<br>	public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。  <br>*&#x2F;<br>		FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &#123;97,98,99,100,52,85&#125;;<br>        fos.write(bytes);<br>        fos.close();<br>&#x2F;&#x2F; 结果：abcd4U<br>&#x2F;*<br>	可以写入中文,使用String类的getBytes方法将其转换为byte[];<br>*&#x2F;<br>        FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Test code\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &quot;这是一个示例&quot;.getBytes();<br>        fos.write(bytes);<br>        fos.close();<br>&#x2F;*<br>	public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  这里的off指的是打算输出的byte数组的所需的第一个索引,len为输出的长度;<br>*&#x2F;<br>        FileOutputStream fos &#x3D; new FileOutputStream(&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;);<br>        byte[] bytes &#x3D; &#123;97,98,99,100,52,85&#125;;<br>        fos.write(bytes,2,3);<br>        fos.close();<br>&#x2F;&#x2F; 结果:cd4<br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>数据的续写与覆盖</strong></p>
<p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了</p>
</li>
<li><p><strong>数据的换行</strong></p>
<ul>
<li><p>回车符<code>\r</code>和换行符<code>\n</code> ：</p>
<p>​    回车符：回到一行的开头（return）。</p>
<p>​    换行符：下一行（newline）。</p>
</li>
<li><p>系统中的换行：</p>
<p>​    Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</p>
<p>​    Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</p>
<p>​    Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\Testcode\\Java\\IODemo\\b.txt&quot;</span>,<span class="hljs-keyword">false</span>);<br><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;这是一个示例\r\n&quot;</span>.getBytes();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++) &#123;<br>    fos.write(bytes);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-2-4-InputStream"><a href="#12-2-4-InputStream" class="headerlink" title="12.2.4 InputStream"></a>12.2.4 InputStream</h4><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<h4 id="12-2-5-FileInputStream"><a href="#12-2-5-FileInputStream" class="headerlink" title="12.2.5 FileInputStream"></a>12.2.5 FileInputStream</h4><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<ul>
<li><p><strong>构造方法</strong>:</p>
<ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
</li>
<li><p><strong>读取字节数据</strong>:</p>
<ul>
<li><p><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 读取完后指针自动向后移动一位,返回值为其读取到的值,若读取到文件末尾则返回-1;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\Testcode\\Java\\IODemo\\a.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)temp); <span class="hljs-comment">//注意这里需要强转,不然输出的是转码后的int类型数据.</span><br>        &#125;<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//输出结果与a.txt存的内容一样:2w6e26</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<blockquote>
<p>明确两件事情:<br> 1.方法的参数byte[]的作用?</p>
<pre><code> 起到缓冲作用,存储每次读取到的多个字节
 数组的长度一把定义为1024(1kb)或者1024的整数倍</code></pre>
<p> 2.方法的返回值int是什么?</p>
<pre><code> 每次读取的有效字节个数</code></pre>
</blockquote>
<ul>
<li><p>String类的构造方法</p>
<ul>
<li><p>String(byte[] bytes) :把字节 数组转换为字符串</p>
</li>
<li><p>String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数</p>
<blockquote>
<p>为什么使用该方法?我们定义byte[]数组的时候长度定义为1024字节,如果读取的数据＜1024字节则会有很多0补齐数组,而我们需要的只是读取出的数据,所以以0为开始索引,以读取的返回值为length来构造String类对象;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\Test code\\Java\\IODemo\\b.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,temp));<span class="hljs-comment">//使用String类的构造方法将byte[]类型的数组转换为String类的字符串</span><br>        &#125;<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:这是一个示例 这是一个示例</span><br></code></pre></td></tr></table></figure>
<h4 id="12-2-6-案例：图片复制"><a href="#12-2-6-案例：图片复制" class="headerlink" title="12.2.6 案例：图片复制"></a>12.2.6 案例：图片复制</h4></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close(); <span class="hljs-comment">//注意先开后关,后开先关;</span><br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了1694毫秒</span><br><span class="hljs-comment">//没有优化 直接一个字节一个字节读取,接下来我们用byte[]接受再测试下效率:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了4毫秒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\a.jpg&quot;</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\a.jpg&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10240</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(bytes,<span class="hljs-number">0</span>,length);<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;复制图片经历了&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>        fos.close();<br>        fis.close();<br>    &#125;<br><span class="hljs-comment">//结果:复制图片经历了1毫秒</span><br></code></pre></td></tr></table></figure>
<h3 id="12-3-字符流"><a href="#12-3-字符流" class="headerlink" title="12.3 字符流"></a>12.3 字符流</h3><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。使用字节流读取中文文件，一个中文在GBK中占用2个字节而在UTF-8中占用3个字节。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h4 id="12-3-1-Reader"><a href="#12-3-1-Reader" class="headerlink" title="12.3.1 Reader"></a>12.3.1 Reader</h4><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h4 id="12-3-2-FileReader"><a href="#12-3-2-FileReader" class="headerlink" title="12.3.2 FileReader"></a>12.3.2 FileReader</h4><p><code>java.io.FileReader </code>类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li><p><strong>构造方法</strong>：</p>
<ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li>
</ul>
</li>
<li><p><strong>读取字符数据</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	比较FileReader与FileInputStream的区别</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((length = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)length);<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">while</span>((length = fr.read())!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)length);<br>        &#125;<br>        fis.close();<br>        fr.close();<br>    &#125;<br><br><span class="hljs-comment">/*输出结果:   è¿æ¯ä¸ä¸ªç¤ºä¾</span><br><span class="hljs-comment">       	 	这是一个示例</span><br><span class="hljs-comment">	足以佐证字符流输出的优势</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 优化：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        &#125;<br>    	fr.close();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-3-3-Writer"><a href="#12-3-3-Writer" class="headerlink" title="12.3.3 Writer"></a>12.3.3 Writer</h4></li>
</ul>
<p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<h4 id="12-3-4-FileWriter"><a href="#12-3-4-FileWriter" class="headerlink" title="12.3.4 FileWriter"></a>12.3.4 FileWriter</h4><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li><strong>构造方法</strong>:<ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>写出字符</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">            void write(int c) 写入单个字符。</span><br><span class="hljs-comment">         */</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;c.txt&quot;</span>);<br>        fw.write(<span class="hljs-number">97</span>);<br>        fw.write(<span class="hljs-number">98</span>);<br>        fw.write(<span class="hljs-number">50</span>);<br>        fw.flush();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            void write(String str) 写入字符串。</span><br><span class="hljs-comment">         */</span><br>        fw.write(<span class="hljs-string">&quot;写入字符串...&quot;</span>);<br>        fw.flush();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">char</span>[] cbuf = &#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>&#125;;<br>        fw.write(cbuf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        fw.close();<br>    &#125;<br><span class="hljs-comment">// 文件结果:ab2写入字符串...bc</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>close与flush的区别</strong></p>
<ul>
<li><code>flush</code> :刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
</li>
<li><p>FileWriter与FileOutputStream的重要区别是FileWriter写入后必须刷新缓冲区才能将数据写入文件中，而FileOutputStream则无需手动刷新;</p>
</li>
<li><p>续写与换行操作同FileOutputStream;</p>
</li>
</ul>
<h3 id="12-4-How-to-deal-with-IOException"><a href="#12-4-How-to-deal-with-IOException" class="headerlink" title="12.4 How to deal with IOException"></a>12.4 How to deal with IOException</h3><ul>
<li><p><strong>JDK7前的处理</strong>：<code>try-catch-finally</code>代码块来处理异常部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>    FileReader fr = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//需要提升fr的作用域,否则在finally中将无法找到这个变量,而我们之后要使用fr变量,所以必须初始化为NULL;</span><br>    <span class="hljs-keyword">try</span>&#123;<br>    	fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>   		<span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>    	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    	<span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>        	System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>    	&#125;<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//先判断fr是否为null，防止引发空指针异常;</span><br>            <span class="hljs-keyword">if</span> (fr != <span class="hljs-keyword">null</span>) &#123;<br>                fr.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;     <br>    &#125;    	<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>JDK7的处理方法</strong></p>
<p>在JDK7中,出现了优化的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (创建流对象语句，如果多个,使用<span class="hljs-string">&#x27;;&#x27;</span>隔开) &#123;<br>	<span class="hljs-comment">// 读写数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>	e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span>( FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>); )&#123;<br>       		<span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        	<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        	<span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            	System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        	&#125;<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>JDK9的处理方法</strong></p>
<p>在JDK9中 <code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。</p>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>B b = <span class="hljs-keyword">new</span> B();<br><span class="hljs-keyword">try</span>(a;b)&#123;<br>    statement<br>&#125;<span class="hljs-keyword">catch</span>(E e)&#123;<br>    statement<br>&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>( fr )&#123;<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((length = fr.read(chars))!=-<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,length));<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="12-5-Properties"><a href="#12-5-Properties" class="headerlink" title="12.5 Properties"></a>12.5 Properties</h3></li>
</ul>
<p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一<code>Properties</code>对象。</p>
<ul>
<li><p><strong>常用方法</strong>:</p>
<ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li>
<li><code>public void load(Reader reader)</code>： 从字符输入流中读取键值对。一般用于读取含有中文的键值对。 </li>
</ul>
</li>
<li><p><strong>使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Properties p = <span class="hljs-keyword">new</span> Properties();<br>        p.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>));<br>        Set&lt;String&gt; keys = p.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            System.out.println(key+<span class="hljs-string">&quot;的key为&quot;</span>+p.getProperty(key));<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 输出: lisi的key为234</span><br><span class="hljs-comment">        zhangsan的key为123</span><br><span class="hljs-comment">        wangwu的key为345</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/* 附:a.txt内容:</span><br><span class="hljs-comment">                # 注释注释</span><br><span class="hljs-comment">                zhangsan=123</span><br><span class="hljs-comment">                lisi 234</span><br><span class="hljs-comment">                wangwu 345</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意:<br> 1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)<br> 2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取<br> 3.存储键值对的文件中,键与值默认都是字符串,不用再加引号</p>
</blockquote>
</li>
<li><p><strong>存储</strong>:</p>
<p>可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</p>
<ul>
<li><p>void store(OutputStream out, String comments)</p>
</li>
<li><p>void store(Writer writer, String comments)</p>
<p>参数:</p>
<pre><code>OutputStream out:字节输出流,不能写入中文
Writer writer:字符输出流,可以写中文
String comments:注释,用来解释说明保存的文件是做什么用的
        不能使用中文,会产生乱码,默认是Unicode编码
        一般使用&quot;&quot;空字符串</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="12-6-缓冲流"><a href="#12-6-缓冲流" class="headerlink" title="12.6 缓冲流"></a>12.6 缓冲流</h3><h4 id="12-6-1-Introdution"><a href="#12-6-1-Introdution" class="headerlink" title="12.6.1 Introdution"></a>12.6.1 Introdution</h4><ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h4 id="12-6-2-字节缓冲流"><a href="#12-6-2-字节缓冲流" class="headerlink" title="12.6.2 字节缓冲流"></a>12.6.2 字节缓冲流</h4><ul>
<li><p><strong>构造方法</strong>：</p>
<ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流。 默认缓存区大小是8192个字节即8KB。 </li>
<li><code>public BufferedInputStream(InputStream in, int size) </code>:创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。默认缓存区大小是8192个字节即8KB。 </li>
<li><code>public BufferedOutputStream(OutputStream out, int size)</code>: 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</li>
</ul>
</li>
<li><p><strong>具体使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d.txt&quot;</span>));<br>    bos.write(<span class="hljs-string">&quot;好家伙&quot;</span>.getBytes());<br>    bos.close();<br>  <br>    BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>));<br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((length = bis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,length));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意使用BufferedOutputStream类的方法时输出数据后需要flush(),否则数据仅在缓冲区中,并没有实际输入到数据中去;</p>
</blockquote>
</li>
</ul>
<h4 id="12-6-3-字符缓冲流"><a href="#12-6-3-字符缓冲流" class="headerlink" title="12.6.3 字符缓冲流"></a>12.6.3 字符缓冲流</h4><ul>
<li><p><strong>构造方法</strong>：</p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
</li>
<li><p><strong>特有方法</strong>：</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li>
</ul>
</li>
<li><p><strong>具体使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * BufferedReader：`public String readLine()`: 读一行文字。</span><br><span class="hljs-comment">     * BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。</span><br><span class="hljs-comment">     */</span><br>    BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++) &#123;<br>        bw.write(<span class="hljs-string">&quot;你猜&quot;</span>);<br>        bw.newLine();<br>    &#125;<br>    bw.flush();<br>    bw.close();<br>  <br>    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    String temp;<br>    <span class="hljs-keyword">while</span>((temp = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>        System.out.println(temp);<br>    &#125;<br>    br.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>public String readLine()</code>的返回值为所读取到的String类型的字符串,当读取最后一行结束后返回为null；</p>
</blockquote>
</li>
</ul>
<h4 id="12-6-4-文本排序"><a href="#12-6-4-文本排序" class="headerlink" title="12.6.4 文本排序"></a>12.6.4 文本排序</h4><p>请将文本信息恢复顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。<br>8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。<br>4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。<br>2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。<br>1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>9.今当远离，临表涕零，不知所言。<br>6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。<br>7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。<br></code></pre></td></tr></table></figure>
<p><strong>代码实现</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:将f.txt中的文本进行排序,按每行前面的123456排序;</span><br><span class="hljs-comment">        分析:</span><br><span class="hljs-comment">            1.想要进行排序就要依次读取文本中的各行,使用BufferedReader中的readLine()方法读取</span><br><span class="hljs-comment">            2.读取完了之后我们要进行存储,既然要排序,可以在存储中完成排序,即使用HashMap集合,将每行文本分割成序号和内容即可</span><br><span class="hljs-comment">            3.由于HashMap集合是一个有序的集合，自动按key进行排序，我们只需将HashMap集合再次写出到新的文本中使用BufferedWriter中的write()和newLine()方法即可;</span><br><span class="hljs-comment">     */</span><br>    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;f.txt&quot;</span>));<br>    String temp;<br>    HashMap&lt;String,String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">while</span>((temp = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>        String[] split = temp.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        hashMap.put(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);<br>    &#125;<br>    BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;target.txt&quot;</span>));<br>    Set&lt;String&gt; keys = hashMap.keySet();<br>    <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>        String value = hashMap.get(key);<br>        bw.write(key+<span class="hljs-string">&quot;.&quot;</span>+value);<br>        bw.newLine();<br>    &#125;<br>    bw.close();<br>    br.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="12-7-转换流"><a href="#12-7-转换流" class="headerlink" title="12.7 转换流"></a>12.7 转换流</h3><h4 id="12-7-1-字符编码与字符集问题"><a href="#12-7-1-字符编码与字符集问题" class="headerlink" title="12.7.1 字符编码与字符集问题"></a>12.7.1 字符编码与字符集问题</h4><ul>
<li><p><strong>字符编码:</strong></p>
<p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
</li>
<li><p><strong>字符集</strong>:</p>
<ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-7-2-编码引出的问题"><a href="#12-7-2-编码引出的问题" class="headerlink" title="12.7.2 编码引出的问题"></a>12.7.2 编码引出的问题</h4><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;GBK.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> read;<br>        <span class="hljs-keyword">while</span> ((read = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-keyword">char</span>)read);<br>        &#125;<br>        fileReader.close();<br>    &#125;<br>&#125;<br>输出结果：<br>���<br></code></pre></td></tr></table></figure>
<p>那么如何读取GBK编码的文件呢？ </p>
<h4 id="12-7-3-InputStreamReader类"><a href="#12-7-3-InputStreamReader类" class="headerlink" title="12.7.3 InputStreamReader类"></a>12.7.3 InputStreamReader类</h4><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<ul>
<li><p><strong>构造方法</strong>：</p>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
</li>
<li><p><strong>指定编码读取</strong>:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//        `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;d.txt&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] charss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> tempp =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((tempp = fr.read(charss)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(charss));<br>        &#125;<br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((temp = isr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(chars,<span class="hljs-number">0</span>,temp));<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 结果:</span><br>                �üһ                                                                       <br>                �üһ                                                                       <br>                好家伙<br></code></pre></td></tr></table></figure>
<h4 id="12-7-4-OutputStreamWriter类"><a href="#12-7-4-OutputStreamWriter类" class="headerlink" title="12.7.4 OutputStreamWriter类"></a>12.7.4 OutputStreamWriter类</h4><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<ul>
<li><strong>构造方法</strong>：<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>指定编码写出</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    	<span class="hljs-comment">// 定义文件路径</span><br>      String FileName = <span class="hljs-string">&quot;E:\\out.txt&quot;</span>;<br>    	<span class="hljs-comment">// 创建流对象,默认UTF-8编码</span><br>      OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName));<br>      <span class="hljs-comment">// 写出数据</span><br>    	osw.write(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 保存为6个字节</span><br>      osw.close();<br>    	<br><span class="hljs-comment">// 定义文件路径</span><br>String FileName2 = <span class="hljs-string">&quot;E:\\out2.txt&quot;</span>;<br>   	<span class="hljs-comment">// 创建流对象,指定GBK编码</span><br>      OutputStreamWriter osw2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(FileName2),<span class="hljs-string">&quot;GBK&quot;</span>);<br>      <span class="hljs-comment">// 写出数据</span><br>    	osw2.write(<span class="hljs-string">&quot;你好&quot;</span>);<span class="hljs-comment">// 保存为4个字节</span><br>      osw2.close();<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-7-5-转换文件编码"><a href="#12-7-5-转换文件编码" class="headerlink" title="12.7.5 转换文件编码"></a>12.7.5 转换文件编码</h4></li>
</ul>
<p><strong>需求</strong>:将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<p><strong>代码实现</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       需求:将GBK编码的文本文件d.txt，转换为UTF-8编码的文本文件dutf.txt。</span><br><span class="hljs-comment">       分析:</span><br><span class="hljs-comment">            1.首先创建InputStreamReader对象，指定字符编码为GBK,使用read()方法读取其内容</span><br><span class="hljs-comment">            2.创建OutputStreamWriter对象,指定字符编码为UTF-8,使用write()方法将1中读取到的内容写进新的txt文本中;</span><br><span class="hljs-comment">            3.释放流对象;</span><br><span class="hljs-comment">     */</span><br>    InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br>    OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;dutf.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">while</span>((temp = isr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>        osw.write(chars,<span class="hljs-number">0</span>,temp);<br>    &#125;<br>    osw.close();<br>    isr.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="12-8-序列化"><a href="#12-8-序列化" class="headerlink" title="12.8 序列化"></a>12.8 序列化</h3><h4 id="12-8-1-Introduction"><a href="#12-8-1-Introduction" class="headerlink" title="12.8.1 Introduction"></a>12.8.1 Introduction</h4><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>
<h4 id="12-8-2-ObjectOutputStream类"><a href="#12-8-2-ObjectOutputStream类" class="headerlink" title="12.8.2 ObjectOutputStream类"></a>12.8.2 ObjectOutputStream类</h4><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<ul>
<li><p><strong>构造方法</strong>:</p>
<p><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</p>
</li>
<li><p><strong>序列化操作</strong>:</p>
<blockquote>
<p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
</blockquote>
</li>
<li><p><strong>写出对象方法</strong>:</p>
<p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        oos.close();<br>    &#125;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String sex)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>        &#125;<br>        String name;<br>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> age;<br>        String sex;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-8-3-ObjectInputStream类"><a href="#12-8-3-ObjectInputStream类" class="headerlink" title="12.8.3 ObjectInputStream类"></a>12.8.3 ObjectInputStream类</h4><p>ObjectInputStream为反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<ul>
<li><p><strong>构造方法</strong>：</p>
<ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
</li>
<li><p><strong>读取对象方法</strong>：</p>
<p><code>public final Object readObject ()</code> : 读取一个对象。注意返回值为Object类型的对象,使用时还要向下转型;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        oos.close();<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;g.txt&quot;</span>));<br>        Person per= (Person) ois.readObject();<br>        System.out.println(per);<br>        Person per2= (Person) ois.readObject();<br>        System.out.println(per2);<br>        ois.close();<br>    &#125;<br><span class="hljs-comment">// 结果：</span><br>        Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br>        Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;woman&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</p>
</li>
<li><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常</p>
<blockquote>
<p>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法 </li>
</ul>
</blockquote>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<p>为了解决这个问题,我们可以在定义类的时候自己定义死serialVersionUID,实现代码: <code> private static final long serialVersionUID = 1L;</code></p>
</li>
</ul>
<h4 id="12-8-4-序列化集合"><a href="#12-8-4-序列化集合" class="headerlink" title="12.8.4 序列化集合"></a>12.8.4 序列化集合</h4><p><strong>代码实现</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;woman&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;man&quot;</span>));<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;list.txt&quot;</span>));<br>        oos.writeObject(list);<br>        ArrayList&lt;Person&gt; list1 = (ArrayList&lt;Person&gt;) ois.readObject();<br>        <span class="hljs-keyword">for</span> (Person p : list1) &#123;<br>            System.out.println(p);<br>        &#125;<br>        ois.close();<br>        oos.close();<br>    &#125;<br><span class="hljs-comment">//结果:</span><br>Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;woman&#x27;</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">0</span>, sex=<span class="hljs-string">&#x27;man&#x27;</span>&#125;<br><span class="hljs-comment">//age因为使用了transient修饰符所以没有被序列化</span><br></code></pre></td></tr></table></figure>
<h3 id="12-9-打印流"><a href="#12-9-打印流" class="headerlink" title="12.9 打印流"></a>12.9 打印流</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<ul>
<li><p><strong>构造方法</strong>:</p>
<ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
</li>
<li><p><strong>改变打印流向</strong>:</p>
<p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。我们可以通过setOut方法改变打印流向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-comment">// 调用系统的打印流,控制台直接输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>      <br>		<span class="hljs-comment">// 创建打印流,指定文件的名称</span><br>        PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;ps.txt&quot;</span>);<br>      	<br>      	<span class="hljs-comment">// 设置系统的打印流流向,输出到ps.txt</span><br>        System.setOut(ps);<br>      	<span class="hljs-comment">// 调用系统的打印流,ps.txt中输出97</span><br>        System.out.println(<span class="hljs-number">97</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/14/MySQL%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">MySQL笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
