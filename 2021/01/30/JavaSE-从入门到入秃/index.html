

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Shimmery">
  <meta name="keywords" content="Java后端开发">
  <title>JavaSE-从入门到入秃 - Shimmery&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Shimmery's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/back02.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaSE-从入门到入秃">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-30 23:05" pubdate>
        2021年1月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      200
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaSE-从入门到入秃</h1>
            
            <div class="markdown-body">
              <p>JavaSE知识:面向对象,封装,继承,多态,抽象类和接口,泛型,包装类,异常,Collection,Map,反射,多线程…</p>
<a id="more"></a>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="JavaSE-从入门到入秃（持续更新中）"><a href="#JavaSE-从入门到入秃（持续更新中）" class="headerlink" title="JavaSE-从入门到入秃（持续更新中）"></a>JavaSE-从入门到入秃（持续更新中）</h2><h3 id="Charpter-I-Introduction"><a href="#Charpter-I-Introduction" class="headerlink" title="Charpter I. Introduction"></a>Charpter I. Introduction</h3><hr>
<h4 id="1-1-Java具有可移植性"><a href="#1-1-Java具有可移植性" class="headerlink" title="1.1 Java具有可移植性"></a>1.1 Java具有可移植性</h4><p>Java的数据类型具有固定的大小,同时二进制数据以固定的格式进行存储和传输。</p>
<p>而C/C++中,int 可能是 16 位整数、 32 位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。</p>
<h4 id="1-2-常见Java术语"><a href="#1-2-常见Java术语" class="headerlink" title="1.2 常见Java术语"></a>1.2 常见Java术语</h4><p><img src="https://s3.ax1x.com/2021/01/26/sX21XD.png" srcset="/img/loading.gif" alt="常见Java术语" title="常见Java术语"></p>
<h4 id="1-3-Java的一些规范"><a href="#1-3-Java的一些规范" class="headerlink" title="1.3 Java的一些规范"></a>1.3 Java的一些规范</h4><p>Java区分大小写;</p>
<p>Java变量/类的命名应遵循驼峰命名法;具体参见孤尽老师的《<em>阿里巴巴Java开发手册</em>》</p>
<p>源代码的文件名必须与公共类的名字相同;</p>
<p>一般不在一行中声明多个变量，逐一声明变量可以提高程序的可读性;</p>
<h4 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h4><p>类注释：以/** 为开始 */为结束</p>
<p>行注释：//或者/* */</p>
<p>方法注释:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*@param:变量描述</span><br><span class="hljs-comment">*@return:描述</span><br><span class="hljs-comment">*@throws:类描述</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h4 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h4><p>Java是强类型语言,变量必须声明类型;(JavaScript是弱类型语言,直接用var声明变量,同时具有弱类型语言的===判断全等)</p>
<p>基本类型:int short long byte(无c++中的long long) float double char boolean</p>
<p>(String不是基本类型,String是封装好的类,所以S大写!)</p>
<h5 id="1-整型"><a href="#1-整型" class="headerlink" title="(1)整型"></a>(1)整型</h5><p>长整型数值有L或l后缀;</p>
<p>十六进制ox前缀,八进制o前缀,二进制0b前缀;</p>
<p>Java中没有无符号整型unsigned;</p>
<h5 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="(2)浮点类型"></a>(2)浮点类型</h5><p>float类型有后缀f或者F,没有后缀的默认都为double类型;</p>
<ul>
<li><p>特殊的浮点类型:正无穷大,负无穷大,NaN(不是一个数字，一般是0/0或者负数的平方根会出现结果为NaN)</p>
</li>
<li><p>Java中认为所有的非数值都是不相同的,判断是不是NaN可以使用Double.isNaN方法</p>
</li>
<li><p>浮点误差的来源是浮点数值采用二进制系统表示,在二进制系统中无法精确的表示小数,如果需要精确计算需要使用BigDecimal类.</p>
</li>
</ul>
<h5 id="3-char类型"><a href="#3-char类型" class="headerlink" title="(3)char类型"></a>(3)char类型</h5><p>char类型的字面量值需要用单引号括起来（eg:’A’;</p>
<p>char类型的值可以表示为十六进制值，范围从\u0000到\Uffff;</p>
<p>还有一些特殊的转义序列，类似于c语言;</p>
<p>程序中一般不使用char类型，除非确实要使用UTF-16代码单元;</p>
<h5 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="(4)boolean类型"></a>(4)boolean类型</h5><ul>
<li><p>整型值和boolean类型值不能相互转换（而C++中可以</p>
<p>eg：我们熟悉的 if（x) 在c++中值0代替false，非0代替true，但是在Java中就不能通过编译;</p>
</li>
</ul>
<h4 id="1-6-变量"><a href="#1-6-变量" class="headerlink" title="1.6 变量"></a>1.6 变量</h4><p>声明变量后必须用赋值语句进行显式初始化，使用未初始化的变量会报错；</p>
<p>Java可以把声明放在代码中的任何地方;(交给JVM去找)</p>
<ul>
<li>在Java中，使用关键词final指示常量，而在c++中使用const或者#define;</li>
<li>可以使用static final设置一个类常量;</li>
</ul>
<h4 id="1-7-运算符"><a href="#1-7-运算符" class="headerlink" title="1.7 运算符"></a>1.7 运算符</h4><h5 id="1-数学函数与常量"><a href="#1-数学函数与常量" class="headerlink" title="(1)数学函数与常量"></a>(1)数学函数与常量</h5><p>在Math类中包含各种各样的数学函数,可以调用一些方法,eg:Math.sqrt(x);</p>
<ul>
<li><p>floorMod方法：确保余数≥0;</p>
</li>
<li><p>可以不用在每个方法前加Math. ，在源文件顶部加 import static java.lang.Math.*; 即可，静态导入;</p>
</li>
</ul>
<h5 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="(2)强制类型转换"></a>(2)强制类型转换</h5><p>在()中给出想要转换的目标类型;</p>
<h5 id="3-运算符重载"><a href="#3-运算符重载" class="headerlink" title="(3)运算符重载"></a>(3)运算符重载</h5><p>Java中不支持运算符重载,而C++可以;</p>
<p>唯一例外是String类里面的=和+,而这是JVM的问题,程序员本身无法实现运算符重载;</p>
<h4 id="1-8-字符串：String类"><a href="#1-8-字符串：String类" class="headerlink" title="1.8 字符串：String类"></a>1.8 字符串：String类</h4><h5 id="1-拼接"><a href="#1-拼接" class="headerlink" title="(1)拼接"></a>(1)拼接</h5><p>Java允许使用+号拼接两个字符串(JVM的操作);</p>
<p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串;</p>
<p>这种特性一般在print语句中,eg:System.out.println(“The answer is “ + answer);</p>
<h5 id="2-不可变字符串"><a href="#2-不可变字符串" class="headerlink" title="(2)不可变字符串"></a>(2)不可变字符串</h5><p>String类没有提供用于修改字符串的方法;</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eydwyz/article/details/88861417">为什么String类字符串在Java中是不可修改的</a></p>
<h5 id="3-String类类似于char-指针"><a href="#3-String类类似于char-指针" class="headerlink" title="(3)String类类似于char*指针"></a>(3)String类类似于char*指针</h5><p>String类并非字符型数组(c++中是)</p>
<h5 id="4-检测字符串是否相等"><a href="#4-检测字符串是否相等" class="headerlink" title="(4)检测字符串是否相等"></a>(4)检测字符串是否相等</h5><ul>
<li><p>使用equals方法检测是否相等，不区分大小写可以使用equalsIgnoreCase方法;</p>
</li>
<li><p>一定不要使用==运算符检测两个字符串相等,==只是确定两个字符串是否放在同一个内存区域上。在C++中可以，因为C++可以重载运算符;</p>
</li>
<li><p>equals方法是Object超类定义的boolean类型方法;</p>
</li>
</ul>
<h5 id="5-空串与NULL串"><a href="#5-空串与NULL串" class="headerlink" title="(5)空串与NULL串"></a>(5)空串与NULL串</h5><p>空串””是长度为0的字符串，可以使用length检测;</p>
<p>null是特殊的值，检测使用str==null检测;</p>
<h5 id="6-StringBuilder-StringBuffer类"><a href="#6-StringBuilder-StringBuffer类" class="headerlink" title="(6)StringBuilder,StringBuffer类"></a>(6)StringBuilder,StringBuffer类</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303">String,StringBuffer,StringBuilder类的区别</a></p>
<h4 id="1-9-输入输出"><a href="#1-9-输入输出" class="headerlink" title="1.9 输入输出"></a>1.9 输入输出</h4><h5 id="1-输入"><a href="#1-输入" class="headerlink" title="(1)输入"></a>(1)输入</h5><p>首先构造个Scanner对象,并与标准输入流System.in关联:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>
<p>现在可以使用Scanner类的各种方法实现输入操作;</p>
<p>eg:nextLine方法可以输入一行,next方法可以输入一个单词;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String name = in.nextLine();<br>String firstName = in.next();<br></code></pre></td></tr></table></figure>
<p>Scanner类定义在java.util包中,需要加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure>
<ul>
<li>读取密码使用Console类对象</li>
</ul>
<h5 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="(2)格式化输出"></a>(2)格式化输出</h5><p>类似于c语言的printf方法;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.printf(<span class="hljs-string">&quot;%8.2f&quot;</span>,x);<br></code></pre></td></tr></table></figure>
<h5 id="3-文件输入输出"><a href="#3-文件输入输出" class="headerlink" title="(3)文件输入输出"></a>(3)文件输入输出</h5><p>读取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner (Paths.get(<span class="hljs-string">&quot;Myfile.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>写入文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;Myfile.txt&quot;</span>,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="1-10-大数值"><a href="#1-10-大数值" class="headerlink" title="1.10 大数值"></a>1.10 大数值</h4><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimal。</p>
<p>这两个类可以处理包含任意长度数字序列的数值。 </p>
<p>Biglnteger 类实现了任意精度的整数运算, BigDecimal 实现了任意精度的浮点数运算。</p>
<ul>
<li><p>使用静态的valueOf方法可以将普通的数值转化为大数值;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>Java不能重载运算符,需要使用add和multiply方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger c = a.add(b);<span class="hljs-comment">//c=a+b;</span><br>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>)));<span class="hljs-comment">//d=c*(b+2);</span><br></code></pre></td></tr></table></figure></li>
<li><p>加add减subtract乘multiply除divide余mod相等compareTo方法</p>
</li>
</ul>
<h4 id="1-11-数组"><a href="#1-11-数组" class="headerlink" title="1.11 数组"></a>1.11 数组</h4><h5 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="(1)创建数组"></a>(1)创建数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li>创建一个数字数组，所有数据初始化为0，boolean类型初始化为false，对象数组类型初始化为NULL;</li>
</ul>
<h5 id="2-for-each-循环"><a href="#2-for-each-循环" class="headerlink" title="(2)for each 循环"></a>(2)for each 循环</h5><p>可以用来依次处理数组中的每个元素，无需care下标值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(variable : collection) statement<br>    <span class="hljs-comment">//先声明与数组类型相同的变量用于后续遍历</span><br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element ： a) <br>    System.out.println(element);<br><span class="hljs-comment">//打印a数组中的所有元素并换行</span><br></code></pre></td></tr></table></figure>
<h4 id="1-12-可变参数"><a href="#1-12-可变参数" class="headerlink" title="1.12 可变参数"></a>1.12 可变参数</h4><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：(本质是通过可变数组传递)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(addToSum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>        System.out.println(addToSum(<span class="hljs-number">21</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... Arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : Arr) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br>输出结果:<br><span class="hljs-number">9</span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<hr>
<h3 id="Charpter2-对象与类"><a href="#Charpter2-对象与类" class="headerlink" title="Charpter2.对象与类"></a>Charpter2.对象与类</h3><hr>
<h4 id="2-1-面向过程和面向对象"><a href="#2-1-面向过程和面向对象" class="headerlink" title="2.1 面向过程和面向对象"></a>2.1 面向过程和面向对象</h4><ul>
<li>C语言为面向过程语言,强调Algorithm+Data Structures =Programs,算法第一位,数据结构第二位.</li>
<li>Java为面向对象语言,作为OOP语言,将数据放在第一位,然后再考虑操作数据的算法.OOP适用于解决规模较大的问题.</li>
</ul>
<h4 id="2-2-Class"><a href="#2-2-Class" class="headerlink" title="2.2 Class"></a>2.2 Class</h4><h5 id="1-对象变量"><a href="#1-对象变量" class="headerlink" title="(1)对象变量"></a>(1)对象变量</h5><ul>
<li>一个对象变量并没有实际包含一个对象，而是仅仅引用一个对象。</li>
</ul>
<h5 id="2-按值调用"><a href="#2-按值调用" class="headerlink" title="(2)按值调用"></a>(2)按值调用</h5><ul>
<li>在Java中总是按值传递;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> price=<span class="hljs-number">300</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raisePrice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span></span>&#123;<br>    tmp+=<span class="hljs-number">200</span>;<br>&#125;<br>raisePrice(price);<br><span class="hljs-comment">//最终发现price值并没有改变，因为在Java中形参是按值传递</span><br></code></pre></td></tr></table></figure>
<ul>
<li>关于对象作为引用参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(Employee s)</span></span>&#123;<br>    s.salary+=<span class="hljs-number">500</span>;<span class="hljs-comment">//这里为了清晰没有使用封装后的setter;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这里,形参为对象,传递时先拷贝其内容再引用,本质还是按值传递.</p>
<p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Q1K.png" srcset="/img/loading.gif" alt="图解"></p>
<ul>
<li>“按值传递”的一个经典案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Employee e1,Employee e2)</span></span>&#123;<br>    Employee tmp = e1;<br>    e1 = e2;<br>    e2 = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看似可以实现e1与e2引用对象的交换，实际失败了;</p>
<p>图解:<img src="https://s3.ax1x.com/2021/01/26/sX2Mp6.png" srcset="/img/loading.gif" alt="图解"></p>
<p>原因:实际上交换的是两个拷贝，并没有交换e1，e2引用对象的本身。</p>
<ul>
<li>更准确的define值调用和引用调用:</li>
<li>值调用:在参数传递过程中，形参和实参占用了两个完全不同的内存空间。形参锁存储的内容是实参存储内容的一份拷贝。</li>
<li>引用调用:在参数传递的过程中，形参和实参完全是同一块内存空间。</li>
</ul>
<h4 id="2-3-封装"><a href="#2-3-封装" class="headerlink" title="2.3 封装"></a>2.3 封装</h4><h5 id="1-Concept"><a href="#1-Concept" class="headerlink" title="(1)Concept"></a>(1)Concept</h5><p>将类的某些信息隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作;</p>
<h5 id="2-实现"><a href="#2-实现" class="headerlink" title="(2)实现"></a>(2)实现</h5><p>getter()&amp;setter()方法</p>
<p>在IDEA中 Alt+Insert ,可以直接设置</p>
<p>也可使用Lombok的jar包 @Getter @Setter</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">0</span>;<br>        System.out.println(<span class="hljs-string">&quot;输入的年龄非法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-静态域和静态方法"><a href="#2-4-静态域和静态方法" class="headerlink" title="2.4 静态域和静态方法"></a>2.4 静态域和静态方法</h4><h5 id="1-静态域"><a href="#1-静态域" class="headerlink" title="(1)静态域"></a>(1)静态域</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">()</span></span>&#123;<br>        id=nextId;<br>        nextId++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//nextId属于静态域，即使该类没有对象仍存在，可以直接调用，无需引用对象;</span><br></code></pre></td></tr></table></figure>
<h5 id="2-静态常量"><a href="#2-静态常量" class="headerlink" title="(2)静态常量"></a>(2)静态常量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI=<span class="hljs-number">3.14159265358979323846</span>;<br>&#125;<br><span class="hljs-comment">//使用final是因为该值不可变,使用static是因为无需对象即可调用PI，PI为静态域而非实例域;</span><br></code></pre></td></tr></table></figure>
<h5 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="(3)静态方法"></a>(3)静态方法</h5><ul>
<li>静态方法是一种不能向对象实施操作的方法;也可以认为是没有this参数的方法</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextId</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nextId;<br>&#125;<br><span class="hljs-keyword">int</span> n = Employee.nextId();<br><span class="hljs-comment">//可以通过类名调用这个方法</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>使用静态方法的两种情况：  </p>
<p>1.方法不需要访问对象状态，其所需参数都是通过显式参数提供(eg：Math.pow)</p>
<p>2.方法只需要访问类的静态域(访问静态域必须用静态方法)</p>
</li>
</ul>
<h4 id="2-5-对象构造"><a href="#2-5-对象构造" class="headerlink" title="2.5 对象构造"></a>2.5 对象构造</h4><h5 id="1-重载-Overload"><a href="#1-重载-Overload" class="headerlink" title="(1)重载 Overload"></a>(1)重载 Overload</h5><p>如果多个方法有相同的名字，不同的参数，便产生了重载。</p>
<p>在编译过程中，编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。这个过程叫做重载解析。</p>
<h5 id="2-无参数构造器"><a href="#2-无参数构造器" class="headerlink" title="(2)无参数构造器"></a>(2)无参数构造器</h5><ul>
<li>必要性：在new一个对象时就会使用无参数构造器。</li>
<li>如果在编写一个类时没有写构造器，那么系统会提供一个无参数的构造器。</li>
<li>如果类中提供了至少一个构造器，系统不会自动提供无参构造器，必须自己写，否则new的时候会报错。</li>
</ul>
<p>无参构造器形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassName</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-调用另一个构造器"><a href="#3-调用另一个构造器" class="headerlink" title="(3)调用另一个构造器"></a>(3)调用另一个构造器</h5><p>如果构造器的第一个语句形如this(…)，表明这个构造器将调用同一类的另一个构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Employee #&quot;</span>+nextId,s);<span class="hljs-comment">// calls Employee(String,double)</span><br>    nextId++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-6-包"><a href="#2-6-包" class="headerlink" title="2.6 包"></a>2.6 包</h4><p>使用包的主要原因是确保类名的唯一性，Sun公司建议将公司的因特网域名以逆序的形式作为包名.eg:com.google</p>
<ul>
<li>包的导入：使用import语句 eg：import java.util.*;</li>
<li>还可以导入静态域：eg：import static java.lang.System.*;</li>
<li>将类放到包中:package com.google.corejava;</li>
</ul>
<hr>
<h3 id="Charpter3-继承"><a href="#Charpter3-继承" class="headerlink" title="Charpter3.继承"></a>Charpter3.继承</h3><hr>
<h4 id="3-1-类，超类和子类"><a href="#3-1-类，超类和子类" class="headerlink" title="3.1 类，超类和子类"></a>3.1 类，超类和子类</h4><h5 id="1-定义子类"><a href="#1-定义子类" class="headerlink" title="(1)定义子类"></a>(1)定义子类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>    statement;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Java中，我们使用extends关键词表示继承，而在C++中使用：。在Java中所有的继承都是公有继承,没有C++中的私有继承和保护继承。</p>
<ul>
<li>已存在的类称为超类，基类或者父类;</li>
</ul>
<h5 id="2-重写-覆盖-Override"><a href="#2-重写-覆盖-Override" class="headerlink" title="(2)重写/覆盖 Override"></a>(2)重写/覆盖 Override</h5><ul>
<li><p>在IDEA中可以直接Alt+Insert然后选择Override</p>
</li>
<li><p>使用super调用超类 eg:super.getSalary();可以调用超类的方法，也可以类似this那样调用超类的构造器;</p>
</li>
</ul>
<h5 id="3-继承层次"><a href="#3-继承层次" class="headerlink" title="(3)继承层次"></a>(3)继承层次</h5><p>一个祖先类可以拥有多个子孙继承链，但是Java中不支持多继承。</p>
<h5 id="4-“断子绝孙”-final类和方法"><a href="#4-“断子绝孙”-final类和方法" class="headerlink" title="(4)“断子绝孙”-final类和方法"></a>(4)“断子绝孙”-final类和方法</h5><ul>
<li>不允许被继承/扩展的类可以使用final修饰符声明，final类中的所有方法自动变为final方法</li>
<li>类中的特定方法也可以被final声明，被final声明的方法不能重写</li>
</ul>
<h5 id="5-受保护访问"><a href="#5-受保护访问" class="headerlink" title="(5)受保护访问"></a>(5)受保护访问</h5><p>private-仅对本类可见 public-对所有类可见</p>
<p>protected-对本包和所有子类可见 default默认-对本包可见</p>
<h5 id="6-继承规则"><a href="#6-继承规则" class="headerlink" title="(6)继承规则"></a>(6)继承规则</h5><ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h4 id="3-2-多态"><a href="#3-2-多态" class="headerlink" title="3.2 多态"></a>3.2 多态</h4><h5 id="1-理解"><a href="#1-理解" class="headerlink" title="(1)理解"></a>(1)理解</h5><ul>
<li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是<strong>学生</strong>也是<strong>人</strong>，即出现<strong>两种形态</strong>。                                                      </li>
<li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</li>
</ul>
<h5 id="2-体现"><a href="#2-体现" class="headerlink" title="(2)体现"></a>(2)体现</h5><ul>
<li><p>定义格式：父类类型 变量名=new 子类类型();</p>
</li>
<li><p>多态体现为父类引用变量可以指向子类对象</p>
</li>
<li><p>注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</p>
</li>
</ul>
<h5 id="3-多态中成员的特点"><a href="#3-多态中成员的特点" class="headerlink" title="(3)多态中成员的特点"></a>(3)多态中成员的特点</h5><ul>
<li>多态成员变量:编译运行看左边</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f.num);<span class="hljs-comment">//输出超类的num</span><br></code></pre></td></tr></table></figure>
<ul>
<li>多态成员方法:编译看左边，运行看右边</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Fu f=<span class="hljs-keyword">new</span> Zi();<br>System.out.println(f1.show());<span class="hljs-comment">//调用重写后的方法</span><br></code></pre></td></tr></table></figure>
<h5 id="4-多态的转型"><a href="#4-多态的转型" class="headerlink" title="(4)多态的转型"></a>(4)多态的转型</h5><ul>
<li><p>多态的转型分为向上转型和向下转型两种</p>
</li>
<li><p>向上转型:多态本身就是向上转型的过程  </p>
</li>
<li><p>向下转型:一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型.一般当要使用子类特有功能时候用到;</p>
<p>使用格式：子类类型 变量名=（子类类型） 父类类型的变量;</p>
</li>
</ul>
<h4 id="3-3-抽象类"><a href="#3-3-抽象类" class="headerlink" title="3.3 抽象类"></a>3.3 抽象类</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h5><p>将具体概念的诸多个性排出，集中描述其共性，产生抽象性概念。</p>
<p>所有不同职业，年龄的人，共性都是人。</p>
<p>拥有抽象方法的类就是抽象类，抽象类要用abstract修饰声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;haha!&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//抽象方法，继承时必须重写</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        People people = <span class="hljs-keyword">new</span> people();<span class="hljs-comment">//error 抽象类不可进行实例化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-使用原则"><a href="#2-使用原则" class="headerlink" title="(2)使用原则"></a>(2)使用原则</h5><p>1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>2.抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>3.抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>4.子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p>
<h4 id="3-4-Object-所有类的超类"><a href="#3-4-Object-所有类的超类" class="headerlink" title="3.4 Object:所有类的超类"></a>3.4 Object:所有类的超类</h4><h5 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="(1)equals方法"></a>(1)equals方法</h5><ul>
<li>重写equals方法:先调用超类的equals方法判断,再增加特定的判断条件;</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (!sԤerequals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>        Manager other = (Manager) otherObject; <br>        <span class="hljs-keyword">return</span> bonus == other.bonus; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="(2)hashCode方法"></a>(2)hashCode方法</h5><ul>
<li>hashCode是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li>
</ul>
<h5 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="(3)toString方法"></a>(3)toString方法</h5><ul>
<li>Objcet超类默认带toString方法，不过可以自己重写变得更好一点;</li>
<li>在IDEA中可以通过Alt+Insert找到toString;</li>
</ul>
<hr>
<h3 id="Charpter4-接口与内部类"><a href="#Charpter4-接口与内部类" class="headerlink" title="Charpter4.接口与内部类"></a>Charpter4.接口与内部类</h3><hr>
<h4 id="4-1-接口（Interface"><a href="#4-1-接口（Interface" class="headerlink" title="4.1 接口（Interface)"></a>4.1 接口（Interface)</h4><h5 id="1-Concept-1"><a href="#1-Concept-1" class="headerlink" title="(1)Concept"></a>(1)Concept</h5><ul>
<li><p>接口在Java中是一个抽象类型,是抽象方法的集合;</p>
</li>
<li><p>一般来说，如果一个抽象类只由抽象方法和全局常量所组成，这种情况下我们定义成一个接口;接口中没有构造方法;</p>
</li>
<li><p>接口是对动作的抽象，抽象类是对本质的抽象;</p>
</li>
</ul>
<h5 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="(2)接口的使用"></a>(2)接口的使用</h5><ul>
<li><p>接口必须要有子类，一个子类可以通过实现(implements)多个接口；</p>
</li>
<li><p>接口的子类（如果不是抽象类），那么必须要重写接口中的全部抽象方法；</p>
</li>
<li><p>接口的对象可以利用子类对象的向上转型（多态）进行实例化;</p>
</li>
<li><p>对于接口，抽象方法和全局常量可以不用写public abstract或者public static final，并且接口中的访问权限只有public一种;注意子类重写方法的时候必须用public修饰;</p>
</li>
<li><p>在Java中，一个抽象类只能继承一个抽象类;而一个接口可以通过extends继承多个接口;(但接口不能继承抽象类)</p>
</li>
<li><p>接口不能通过new实例化一个对象，但是可以声明接口的变量，接口变量必须引用实现了接口的类的对象;</p>
</li>
</ul>
<h4 id="4-2-clone-Cloneable接口"><a href="#4-2-clone-Cloneable接口" class="headerlink" title="4.2 clone()/Cloneable接口"></a>4.2 clone()/Cloneable接口</h4><h5 id="1-拷贝和克隆"><a href="#1-拷贝和克隆" class="headerlink" title="(1)拷贝和克隆"></a>(1)拷贝和克隆</h5><p><img src="https://s3.ax1x.com/2021/01/26/sX2ufx.png" srcset="/img/loading.gif" alt="拷贝vs克隆"></p>
<h5 id="2-Object类的clone方法"><a href="#2-Object类的clone方法" class="headerlink" title="(2)Object类的clone方法"></a>(2)Object类的clone方法</h5><ul>
<li><p>Object类的clone方法声明为protected，子类只能调用受保护的clone方法来克隆它自己的对象;</p>
</li>
<li><p>Object类默认的clone方法是”浅拷贝”,并没有克隆对象中引用的其他对象;如果原对象和浅拷贝对象共享的子对象是不可变的类,那么这种共享相对安全,如String类,但是通常子对象是可变的,这样会导致这种共享是不安全的;</p>
<p><img src="https://s3.ax1x.com/2021/01/26/sX2l6O.png" srcset="/img/loading.gif" alt="浅拷贝"></p>
</li>
</ul>
<h5 id="3-Cloneable接口"><a href="#3-Cloneable接口" class="headerlink" title="(3)Cloneable接口"></a>(3)Cloneable接口</h5><ul>
<li><p>Cloneable接口是Java提供的一组标记接口之一,通常用途是确定一个类实现一个或者一组特定的方法,标记接口不包含任何方法,唯一的作用是允许在类型查询中使用instanceof;</p>
</li>
<li><p>重写方法创建深拷贝的例子</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>&#123;<br>        Employee cloned = (Employee) <span class="hljs-keyword">super</span>.clone();<br>        cloned.hireDay = (Date) hireDay.clone();<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-3-内部类"><a href="#4-3-内部类" class="headerlink" title="4.3 内部类"></a>4.3 内部类</h4><hr>
<h3 id="Chartper5-异常处理机制"><a href="#Chartper5-异常处理机制" class="headerlink" title="Chartper5.异常处理机制"></a>Chartper5.异常处理机制</h3><hr>
<h4 id="5-1-异常分类"><a href="#5-1-异常分类" class="headerlink" title="5.1 异常分类"></a>5.1 异常分类</h4><ul>
<li>在Java语言中，所有异常对象都是派生于Throwable类的一个实例.</li>
</ul>
<p><img src="https://s3.ax1x.com/2021/01/26/sjCSEQ.png" srcset="/img/loading.gif" alt="异常分类"></p>
<ul>
<li><p>Error类描述了Java运行时系统的内部错误和资源耗尽错误,这种情况很少见;</p>
</li>
<li><p>Exception类分解为两个分支，一个分支派生于RuntimeException(由于程序本身错误),另一个分支包含其他异常,程序本身没有问题,但是由于出现像I/O错误这种的异常叫做其他异常;</p>
<p>eg：派生于RuntimeException的异常包括以下几种情况:错误的类型转换,数组访问越界（ArrayIndexOutOfBoundsException),访问null空指针(NullPointerException)等等;</p>
</li>
<li><p>实际上，派生于Error类或RuntimeException类的所有异常称为非受查异常,所有其他的称为受查异常,编译器将检查所有的受查异常是否提供了异常处理器;</p>
</li>
</ul>
<h4 id="5-2-抛出异常"><a href="#5-2-抛出异常" class="headerlink" title="5.2. 抛出异常"></a>5.2. 抛出异常</h4><ul>
<li><p>方法应在首部使用throws声明所有可能抛出的异常（受查异常，无需声明派生于Error类或RuntimeException类的异常），每个异常用,隔开;</p>
</li>
<li><p>创建异常类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFormatException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOExpection</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileFormatException</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<span class="hljs-comment">//也可不写</span><br>&#125;<br><br>...&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileFormatException();<span class="hljs-comment">//抛出这个自己定义的异常</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-3-捕获异常"><a href="#5-3-捕获异常" class="headerlink" title="5.3 捕获异常"></a>5.3 捕获异常</h4></li>
</ul>
<h5 id="1-try-catch语句块"><a href="#1-try-catch语句块" class="headerlink" title="(1)try-catch语句块"></a>(1)try-catch语句块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    code;<br>    more code;<br>&#125;<span class="hljs-keyword">catch</span>(ExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;<span class="hljs-keyword">catch</span>(OtherExceptionType e)&#123;<br>    handler <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> type<br>&#125;...<br></code></pre></td></tr></table></figure>
<ul>
<li>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其他代码，抛出的异常直接被所对应的catch捕获并执行catch中的处理器代码;</li>
<li>在catch子句中可以再次抛出一个异常，再之后再进行解决;</li>
</ul>
<h5 id="2-finally子句"><a href="#2-finally子句" class="headerlink" title="(2)finally子句"></a>(2)finally子句</h5><ul>
<li><p>不管是否有异常被捕获，finally子句中的代码都会被执行;一般在需要关闭资源的时候使用finally子句;</p>
</li>
<li><p>当finally子句中包含return语句时，将会出现一种意想不到的效果。假如利用return语句从try语句块中退出，在方法返回前，finally子句的内容将被执行，如果finally子句中也有一个return语句，这个返回值会覆盖原始的返回值;</p>
</li>
</ul>
<h5 id="3-分析堆栈轨迹元素"><a href="#3-分析堆栈轨迹元素" class="headerlink" title="(3)分析堆栈轨迹元素"></a>(3)分析堆栈轨迹元素</h5><ul>
<li>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息;</li>
</ul>
<h4 id="5-4-异常声明碰到继承关系"><a href="#5-4-异常声明碰到继承关系" class="headerlink" title="5.4 异常声明碰到继承关系"></a>5.4 异常声明碰到继承关系</h4><ul>
<li>当重写一个函数时，子类不能比超类声明抛出更多的异常;</li>
<li>在子类的构造函数中,必须声明超类所可能抛出的全部异常;</li>
<li>利用多态(向上转型)的思想去思考这个问题;</li>
</ul>
<hr>
<h3 id="Charpter6-泛型-Generic"><a href="#Charpter6-泛型-Generic" class="headerlink" title="Charpter6.泛型(Generic)"></a>Charpter6.泛型(<strong>Generic</strong>)</h3><hr>
<h4 id="6-1-为什么使用泛型"><a href="#6-1-为什么使用泛型" class="headerlink" title="6.1 为什么使用泛型"></a>6.1 为什么使用泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Collection coll = <span class="hljs-keyword">new</span> ArrayList();<br>		coll.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>		coll.add(<span class="hljs-string">&quot;itcast&quot;</span>);<br>		coll.add(<span class="hljs-number">5</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>		Iterator it = coll.iterator();<br>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>			<span class="hljs-comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br>			String str = (String) it.next();<br>			System.out.println(str.length());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行程序时，程序报错 java.lang.ClassCastException（类型转换异常）;</p>
<p>因为任何类型的数据都可以强制转换成object类型数据储存在集合中，当我们取出一个对象时，就必须进行强制类型转换，这时候可能会出现类型转换异常，比如这里的5是int类型，int类型不能强制转换为String类;</p>
<h4 id="6-2-泛型概念"><a href="#6-2-泛型概念" class="headerlink" title="6.2 泛型概念"></a>6.2 泛型概念</h4><p>可以在类或方法中预支地使用未知的类型;</p>
<h4 id="6-3-泛型的定义与使用"><a href="#6-3-泛型的定义与使用" class="headerlink" title="6.3 泛型的定义与使用"></a>6.3 泛型的定义与使用</h4><h5 id="1-定义和使用泛型类"><a href="#1-定义和使用泛型类" class="headerlink" title="(1)定义和使用泛型类"></a>(1)定义和使用泛型类</h5><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相当于把String赋值给E</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure>
<h5 id="2-定义和使用泛型方法"><a href="#2-定义和使用泛型方法" class="headerlink" title="(2)定义和使用泛型方法"></a>(2)定义和使用泛型方法</h5><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethod</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode</span><span class="hljs-params">(E e)</span></span>&#123;<br>        System.out.println(e.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModeMethodApplicaton</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ModeMethod m = <span class="hljs-keyword">new</span> ModeMethod();<br>        m.mode(<span class="hljs-number">123</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-定义和使用泛型的接口"><a href="#3-定义和使用泛型的接口" class="headerlink" title="(3)定义和使用泛型的接口"></a>(3)定义和使用泛型的接口</h5><p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用泛型接口：</p>
<p>01.定义类时确定泛型的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span></span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>02.始终不确定泛型的类型，直到创建对象时才确定泛型的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericInterface</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-4-泛型通配符"><a href="#6-4-泛型通配符" class="headerlink" title="6.4 泛型通配符"></a>6.4 泛型通配符</h4><h5 id="1-通配符基本使用"><a href="#1-通配符基本使用" class="headerlink" title="(1)通配符基本使用"></a>(1)通配符基本使用</h5><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以使用通配符&lt;?&gt;表示;但是一旦使用泛型的通配符后,只能使用Object类的共性方法,子类自身的方法无法使用</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Collection&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    getElement(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-通配符高级使用-受限泛型"><a href="#2-通配符高级使用-受限泛型" class="headerlink" title="(2) 通配符高级使用-受限泛型"></a>(2) 通配符高级使用-受限泛型</h5><ul>
<li><p>泛型的上限:只能接受该类型以及其子类</p>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? extends 上限类&gt;对象名称<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>泛型的下限:只能接受该类型以及其超类</p>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称&lt;? <span class="hljs-keyword">super</span> 下限类&gt;对象名称<br></code></pre></td></tr></table></figure>
<p>eg:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    Collection&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    Collection&lt;Number&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    Collection&lt;Object&gt; list4 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>    <br>    getElement(list1);<br>    getElement(list2);<span class="hljs-comment">//报错</span><br>    getElement(list3);<br>    getElement(list4);<span class="hljs-comment">//报错</span><br>  <br>    getElement2(list1);<span class="hljs-comment">//报错</span><br>    getElement2(list2);<span class="hljs-comment">//报错</span><br>    getElement2(list3);<br>    getElement2(list4);<br>  <br>&#125;<br><span class="hljs-comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement1</span><span class="hljs-params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;<br><span class="hljs-comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getElement2</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="Charpter7-包装类"><a href="#Charpter7-包装类" class="headerlink" title="Charpter7.包装类"></a>Charpter7.包装类</h3><hr>
<h4 id="7-1-包装类概述"><a href="#7-1-包装类概述" class="headerlink" title="7.1 包装类概述"></a>7.1 包装类概述</h4><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中//无需导包）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="7-2-包装类的自动装箱、自动拆箱机制"><a href="#7-2-包装类的自动装箱、自动拆箱机制" class="headerlink" title="7.2 包装类的自动装箱、自动拆箱机制"></a>7.2 包装类的自动装箱、自动拆箱机制</h4><p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br>Integer iii = Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure>
<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = i.intValue();<br></code></pre></td></tr></table></figure>
<p>而Java为了方便我们使用，以及出于其他目的如性能调优，给我们提供了自动装箱、拆箱机制。这种机制简化了基本类型和包装类型的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Interger i = <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(100);</span><br>i = i +<span class="hljs-number">200</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 200;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure>
<h4 id="7-3-包装类中的缓存机制"><a href="#7-3-包装类中的缓存机制" class="headerlink" title="7.3 包装类中的缓存机制"></a>7.3 包装类中的缓存机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer num3 = <span class="hljs-number">10</span>;<br>Integer num4 = <span class="hljs-number">10</span>;<br>Integer num5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num6 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br>Integer num7 = <span class="hljs-number">128</span>;<br>Integer num8 = <span class="hljs-number">128</span>;<br>System.out.println((num3==num4) +<span class="hljs-string">&quot;	&quot;</span>+ num3.equals(num4));<span class="hljs-comment">//ture true</span><br>System.out.println((num5==num6) +<span class="hljs-string">&quot;	&quot;</span>+ num5.equals(num6));<span class="hljs-comment">//false true</span><br>System.out.println((num7==num8) +<span class="hljs-string">&quot;	&quot;</span>+ num7.equals(num8));<span class="hljs-comment">//false true</span><br></code></pre></td></tr></table></figure>
<p>为什么num7==num8会返回false呢,我们来看看底层缓存机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br> <br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br> <br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>当Integer类第一次被使用到，Integer的静态内部类就被加载，加载的时候会创建-128到127的Integer对象，同时创建一个数组cache来缓存这些对象。当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，也就是说不会再新建对象；当使用new关键字or使用valueOf()方法创建小于-128大于127的值对象时，就会创建新对象。</p>
<p>接着,Integer类重写了equals方法,让我们看看equals方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>            <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>equals方法重写后比较两个Integer对象的值,所以确定两个Integer对象的值是否相等时,应该使用equals方法而非简单的==,否则因为缓冲机制可能会带来一些问题;</p>
<p>此外，在8种包装类型中，有缓存区的有Character、Byte、Short、Integer、Long，而且它们的实现方式基本一样，都是-128到127的缓存范围。Boolean虽然没有缓存区，但是因为只有两个值true、false，所以Boolean在成员变量中就创建了两个相应的对象。没有缓存区的只有Float、Double，之所以没有原因很简单，即便是0到1这么小的范围，浮点数也有无数个，使用缓存区缓存它们不具备可能性和实用性。</p>
<p>缓存区的存在使得常用的包装类对象可以得到复用，这有利于提升性能。当我们需要创建新对象的时候再new一个，增加了灵活性。</p>
<h4 id="7-4-包装类使用过程中有可能引起的空指针异常"><a href="#7-4-包装类使用过程中有可能引起的空指针异常" class="headerlink" title="7.4 包装类使用过程中有可能引起的空指针异常"></a>7.4 包装类使用过程中有可能引起的空指针异常</h4><p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-keyword">null</span>;<br>System.out.println(a);<br></code></pre></td></tr></table></figure>
<p>此时会出现NullPointerException;需要注意</p>
<p>//Reference:<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_30973431/article/details/89332443">Java中的包装类</a></p>
<hr>
<h3 id="Charpter8-Collection"><a href="#Charpter8-Collection" class="headerlink" title="Charpter8.Collection"></a>Charpter8.Collection</h3><hr>
<h4 id="8-1-Introduction"><a href="#8-1-Introduction" class="headerlink" title="8.1 Introduction"></a>8.1 Introduction</h4><p><img src="https://s3.ax1x.com/2021/01/28/yCmIL8.png" srcset="/img/loading.gif" alt="概述"></p>
<p><img src="https://s3.ax1x.com/2021/01/30/yAPzNj.png" srcset="/img/loading.gif" alt="Collection"></p>
<p>集合是Java中的一种容器，可以用来存储多个数据。</p>
<ul>
<li><p>集合和数组的区别</p>
<p>(1)长度区别:数组的长度固定,集合的长度可变;</p>
<p>(2)内容区别:数组可以存储基本数据类型,也能存储引用类型,而集合只能存储引用类型;</p>
<p>(3)元素区别:数组中的元素必须是同一类型,集合可以存储不同类型的数据;</p>
</li>
<li><p>集合分两大类,单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p>
</li>
<li><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p>
</li>
</ul>
<h4 id="8-2-Collection接口常用方法"><a href="#8-2-Collection接口常用方法" class="headerlink" title="8.2 Collection接口常用方法"></a>8.2 Collection接口常用方法</h4><ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;az&quot;</span>);<br>        col.remove(<span class="hljs-string">&quot;az&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> hasJava = col.contains(<span class="hljs-string">&quot;Java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hasJava = &quot;</span> + hasJava);<br>        Iterator&lt;String&gt; it = col.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            String next = it.next();<br>            System.out.println(<span class="hljs-string">&quot;next = &quot;</span> + next);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        col.clear();<br>        <span class="hljs-keyword">boolean</span> empty = col.isEmpty();<br>        System.out.println(<span class="hljs-string">&quot;empty = &quot;</span> + empty);<br>        col.add(<span class="hljs-string">&quot;had&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;String&quot;</span>);<br>        <span class="hljs-keyword">int</span> size = col.size();<br>        System.out.println(<span class="hljs-string">&quot;size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;------&quot;</span>);<br>        Object[] obj = col.toArray();<br>        <span class="hljs-keyword">for</span> (Object o : obj) &#123;<br>            System.out.println(o);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Map,List,Set接口中有一个静态方法of(),方便用于建立少量且元素数目不可变的集合(of()方法只能用于这三个接口,其子类没有)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="8-3-Iterator迭代器"><a href="#8-3-Iterator迭代器" class="headerlink" title="8.3 Iterator迭代器"></a>8.3 Iterator迭代器</h4><ul>
<li><p>Iterator接口主要用于迭代遍历Collection中的元素;</p>
</li>
<li><p>获取迭代器:<code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</p>
</li>
<li><p>常用方法:</p>
<p><code>public E next()</code>:返回迭代的下一个元素。</p>
<p><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</p>
<p><code>public void remove()</code>：删除迭代器新返回的元素。</p>
</li>
<li><p>通过迭代器实现遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过迭代器清空集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;ass&quot;</span>);<br>        Iterator&lt;String&gt; it = coll.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasnext())&#123;<br>            it.next();<br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>一些细节:</p>
<p>如果迭代器的指针已经指向了集合的末尾，那么如果再调用next()会返回NoSuchElementException异常;</p>
<p>如果调用remove之前没有调用next是不合法的，会抛出IllegalStateException;</p>
<p>在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作，因为这样会产生安全隐患，java会抛出异常并发修改异常（ConcurrentModificationException），普通迭代器只支持在迭代过程中的删除动作。</p>
<p>(Reference:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33642117/article/details/52039691">Java迭代器Iterator的详解</a></p>
</li>
</ul>
<h4 id="8-4-List集合"><a href="#8-4-List集合" class="headerlink" title="8.4 List集合"></a>8.4 List集合</h4><h5 id="1-List接口"><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h5><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引index的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<h5 id="2-List接口中的常用方法"><a href="#2-List接口中的常用方法" class="headerlink" title="(2)List接口中的常用方法"></a>(2)List接口中的常用方法</h5><ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        String s = list.get(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br>        System.out.println(<span class="hljs-string">&quot;list.remove(0) = &quot;</span> + list.remove(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;list.set(0,\&quot;reflect\&quot;) = &quot;</span> + list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;reflect&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-ArrayList集合"><a href="#3-ArrayList集合" class="headerlink" title="(3)ArrayList集合"></a>(3)ArrayList集合</h5><p><code>java.util.ArrayList</code>集合的底层是数组，元素增删慢，查找快，线程不安全，效率高，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<h5 id="4-LinkedList集合"><a href="#4-LinkedList集合" class="headerlink" title="(4)LinkedList集合"></a>(4)LinkedList集合</h5><p><code>java.util.LinkedList</code>集合的底层是双向链表，元素增删快，查找慢，线程不安全，效率高。</p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
</ul>
<h5 id="5-Vector集合"><a href="#5-Vector集合" class="headerlink" title="(5)Vector集合"></a>(5)Vector集合</h5><p><code>java.util.Vector</code>集合的底层是数组，元素增删慢，查询快，线程安全，效率低。</p>
<h4 id="8-5-Set接口"><a href="#8-5-Set接口" class="headerlink" title="8.5 Set接口"></a>8.5 Set接口</h4><h5 id="1-特点"><a href="#1-特点" class="headerlink" title="(1)特点"></a>(1)特点</h5><ol>
<li>它是一个元素存取无序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就不一定按照11、22、33的顺序完成的,可能是22、33、11）。</li>
<li>它是没有索引的集合。</li>
<li>集合中不可以有重复的元素。</li>
</ol>
<h5 id="2-HashSet集合"><a href="#2-HashSet集合" class="headerlink" title="(2)HashSet集合"></a>(2)HashSet集合</h5><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<ul>
<li>hashCode:是一个十进制的整数，由系统随机给出（就是对象的逻辑地址值）;Object类的toString方法给出的地址也就是hashCode的值;而String类重写了hashCode方法,由内容导出,但是仍然可能会产生Hash冲突(eg：”重地”和”通话”);</li>
</ul>
<h5 id="3-Set集合不允许重复的原理"><a href="#3-Set集合不允许重复的原理" class="headerlink" title="(3)Set集合不允许重复的原理"></a>(3)Set集合不允许重复的原理</h5><p>hashCode值相同<strong>且</strong>equals方法返回值为true时判断重复,不允许进行操作;</p>
<p>存储的包装类必须重写hashCode方法和equals方法;</p>
<h5 id="4-HashSet存储自定义类元素"><a href="#4-HashSet存储自定义类元素" class="headerlink" title="(4)HashSet存储自定义类元素"></a>(4)HashSet存储自定义类元素</h5><ul>
<li>需要重写hashCode方法和equals方法，否则不允许重复会被打破；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashSet&lt;Person&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Person person01 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>        Person person02 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        Person person03 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>);<br>        set.add(person01);<br>        set.add(person02);<br>        set.add(person03);<br>        Iterator&lt;Person&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            Person p = it.next();<br>            System.out.println(p);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;person01.hashCode() = &quot;</span> + person01.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person02.hashCode() = &quot;</span> + person02.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;person03.hashCode() = &quot;</span> + person03.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>未重写hashCode和equals方法前输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>person01.hashCode() = <span class="hljs-number">1967205423</span><br>person02.hashCode() = <span class="hljs-number">42121758</span><br>person03.hashCode() = <span class="hljs-number">20671747</span><br></code></pre></td></tr></table></figure>
<p>Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//先用==暴力判断</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//如果比较的对象为null或者两者属于不同的类型直接返回false</span><br>        Person person = (Person) o;<span class="hljs-comment">//向下转型</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;<br>                Objects.equals(name, person.name);<span class="hljs-comment">//第一个参数和第二个参数均相同</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>重写hashCode和equals方法后输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&#123;name=<span class="hljs-string">&#x27;张三&#x27;</span>, age=<span class="hljs-number">18</span>&#125;<br>Person&#123;name=<span class="hljs-string">&#x27;李四&#x27;</span>, age=<span class="hljs-number">19</span>&#125;<br>person01.hashCode() = <span class="hljs-number">24022538</span><br>person02.hashCode() = <span class="hljs-number">26104871</span><br>person03.hashCode() = <span class="hljs-number">26104871</span><br></code></pre></td></tr></table></figure>
<p>关于重写hashCode和equals方法:<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012557538/article/details/89861552">重写hashCode和equals方法</a></p>
<h5 id="5-LinkedHashSet"><a href="#5-LinkedHashSet" class="headerlink" title="(5)LinkedHashSet"></a>(5)LinkedHashSet</h5><p>LinkedHashSet的底层数据结构是HashMap和链表,可以保证元素唯一且有序，线程不安全，效率高。</p>
<h4 id="8-6-Collections"><a href="#8-6-Collections" class="headerlink" title="8.6 Collections"></a>8.6 Collections</h4><h5 id="1-常用功能"><a href="#1-常用功能" class="headerlink" title="(1)常用功能"></a>(1)常用功能</h5><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</p>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(list,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;liuliang&quot;</span>);<br>        Collections.shuffle(list);<br>        System.out.println(list);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br>[lisi, zhangsan, liuliang]<br>[lisi, liuliang, zhangsan]<br></code></pre></td></tr></table></figure>
<h5 id="2-重写Comparable接口中的compareTo方法"><a href="#2-重写Comparable接口中的compareTo方法" class="headerlink" title="(2)重写Comparable接口中的compareTo方法"></a>(2)重写Comparable接口中的compareTo方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;wangermazi&quot;</span>,<span class="hljs-number">23</span>));<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br><span class="hljs-comment">//        return 0;</span><br><span class="hljs-comment">//        return this.age - o.age ;//按年龄升序</span><br>        <span class="hljs-keyword">return</span> o.age - <span class="hljs-keyword">this</span>.age;<span class="hljs-comment">//按年龄降序</span><br>    &#125;<br>&#125;<br><br>升序:[Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;]<br>降序:[Person&#123;name=<span class="hljs-string">&#x27;wangermazi&#x27;</span>, age=<span class="hljs-number">23</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">18</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;]<br></code></pre></td></tr></table></figure>
<h5 id="3-Comparator比较器"><a href="#3-Comparator比较器" class="headerlink" title="(3)Comparator比较器"></a>(3)Comparator比较器</h5><ul>
<li><p>Comparable和Comparator的区别:</p>
<p>Comparable:this(自己)和别人(参数)比较,自己需要实现Comparable接口,重写比较规则的compareTo方法</p>
<p>Comparator:相当于找一个第三方的裁判对两者进行比较</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">15</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">17</span>));<br>        list.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">12</span>));<br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123;<br><span class="hljs-comment">//                return 0;</span><br>                <span class="hljs-keyword">int</span> result = o2.getAge() - o1.getAge();<br>                <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>                    result = o2.getName().charAt(<span class="hljs-number">0</span>) - o1.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span>  result;<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Student&#123;name=<span class="hljs-string">&#x27;xiaoming&#x27;</span>, age=<span class="hljs-number">17</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;lisi&#x27;</span>, age=<span class="hljs-number">15</span>&#125;, Student&#123;name=<span class="hljs-string">&#x27;wangwu&#x27;</span>, age=<span class="hljs-number">12</span>&#125;]<br></code></pre></td></tr></table></figure>
<h3 id="Charpter9-Map"><a href="#Charpter9-Map" class="headerlink" title="Charpter9.Map"></a>Charpter9.Map</h3><h4 id="9-1-Introduction"><a href="#9-1-Introduction" class="headerlink" title="9.1 Introduction"></a>9.1 Introduction</h4><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<ul>
<li><p>Map&lt;K,V&gt; K(Key)-代表键的类型  V(Value)-代表值的类型；</p>
</li>
<li><p>Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。通过键可以找到对应的值；</p>
</li>
</ul>
<h4 id="9-2-Map接口中的常用方法"><a href="#9-2-Map接口中的常用方法" class="headerlink" title="9.2 Map接口中的常用方法"></a>9.2 Map接口中的常用方法</h4><ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Hint:使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
<h4 id="9-3-Map集合的遍历方式"><a href="#9-3-Map集合的遍历方式" class="headerlink" title="9.3 Map集合的遍历方式"></a>9.3 Map集合的遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * `public Set&lt;K&gt; keySet()`: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="hljs-comment"> * `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">50</span>);<br>        map.put(<span class="hljs-string">&quot;李鬼&quot;</span>,<span class="hljs-number">10086</span>);<br><br>        <span class="hljs-comment">/* 1.使用keySet方法先获取map集合中的key存到新的Set集合中</span><br><span class="hljs-comment">           2.然后使用map集合的get方法获取value</span><br><span class="hljs-comment">           3.foreach循环遍历输出即可</span><br><span class="hljs-comment">        */</span><br><span class="hljs-comment">//        Set&lt;String&gt; containKeySet = map.keySet();</span><br><span class="hljs-comment">//        for (String key : containKeySet) &#123;</span><br><span class="hljs-comment">//            Integer values = map.get(key);</span><br><span class="hljs-comment">//            System.out.println(key+values);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">/*  1.使用map集合里的entrySet方法获取map集合里的键值对到新的Set集合中</span><br><span class="hljs-comment">            2.利用entry中的getKey方法和geyValue方法获取key和value,根据所需输出</span><br><span class="hljs-comment">            Hint:也可以直接使用foreach循环输出Set集合,得到的是key=value这样的格式效果</span><br><span class="hljs-comment">         */</span><br>        <br>        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; maps : set) &#123;<br>            String key = maps.getKey();<br>            Integer value = maps.getValue();<br>            System.out.println(key+<span class="hljs-string">&quot;对应&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="9-4-LinkedHashMap"><a href="#9-4-LinkedHashMap" class="headerlink" title="9.4 LinkedHashMap"></a>9.4 LinkedHashMap</h4><p>LinkedHashMap的底层是哈希表和双向链表,双向链表用于维护键值对的顺序,所以该集合是有序的;</p>
<h4 id="9-5-综合练习"><a href="#9-5-综合练习" class="headerlink" title="9.5 综合练习"></a>9.5 综合练习</h4><h5 id="9-5-1-字符出现次数"><a href="#9-5-1-字符出现次数" class="headerlink" title="9.5.1 字符出现次数"></a>9.5.1 字符出现次数</h5><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li> 获取一个字符串对象</li>
<li> 创建一个Map集合，键代表字符，值代表次数。</li>
<li> 遍历字符串得到每个字符。</li>
<li> 判断Map中是否有该键。</li>
<li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li> 打印最终结果</li>
</ol>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        String s = scanner.nextLine();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character tmp:s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(map.get(tmp)==<span class="hljs-keyword">null</span>)&#123;<br>                map.put(tmp,<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                Integer sum = map.get(tmp);<br>                sum++;<br>                map.put(tmp,sum);<br>            &#125;<br>        &#125;<br>        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; set = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : set) &#123;<br>            Character key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(<span class="hljs-string">&quot;出现&quot;</span>+key+<span class="hljs-string">&quot;的次数为&quot;</span>+value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="9-5-2-斗地主有序版"><a href="#9-5-2-斗地主有序版" class="headerlink" title="9.5.2 斗地主有序版"></a>9.5.2 斗地主有序版</h5><p><strong>需求:</strong></p>
<ol>
<li> 准备牌：</li>
</ol>
<p>完成数字与纸牌的映射关系：</p>
<p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li> 洗牌：</li>
</ol>
<p>通过数字完成洗牌发牌</p>
<ol start="3">
<li> 发牌：</li>
</ol>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li> 看牌：</li>
</ol>
<p>通过Map集合找到对应字符展示。</p>
<p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
<p><strong>代码实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        需求:1.  准备牌：完成数字与纸牌的映射关系：</span><br><span class="hljs-comment">使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</span><br><span class="hljs-comment">         */</span><br>        List&lt;String&gt; colors = List.of(<span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>);<br>        List&lt;String&gt; numbers = List.of(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;Q&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        List&lt;Integer&gt; pokerIndex = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Integer,String&gt; poker = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Integer index=<span class="hljs-number">0</span>;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;大王&quot;</span>);<br>        index++;<br>        pokerIndex.add(index);<br>        poker.put(index,<span class="hljs-string">&quot;小王&quot;</span>);<br>        index++;<br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br>            <span class="hljs-keyword">for</span> (String color : colors) &#123;<br>                pokerIndex.add(index);<br>                poker.put(index,color+number);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*  2.洗牌通过数字完成洗牌发牌</span><br><span class="hljs-comment">         */</span><br>        Collections.shuffle(pokerIndex);<br><br><span class="hljs-comment">//        System.out.println(pokerIndex);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</span><br><span class="hljs-comment">        存放的过程中要求数字大小与斗地主规则的大小对应。</span><br><span class="hljs-comment">        将代表不同纸牌的数字分配给不同的玩家与底牌。</span><br><span class="hljs-comment">         */</span><br>        ArrayList&lt;Integer&gt; player01 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player02 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; player03 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ArrayList&lt;Integer&gt; temppoker = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Integer count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer num : pokerIndex) &#123;<br>            <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">50</span>)&#123;<br>                temppoker.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>                player01.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">1</span>)&#123;<br>                player02.add(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count%<span class="hljs-number">3</span>==<span class="hljs-number">2</span>)&#123;<br>                player03.add(num);<br>            &#125;<br>            count++;<br>        &#125;<br>        Collections.sort(player01);<br>        Collections.sort(player02);<br>        Collections.sort(player03);<br>        Collections.sort(temppoker);<br><br><span class="hljs-comment">//        System.out.println(player01);</span><br><span class="hljs-comment">//        System.out.println(player02);</span><br><span class="hljs-comment">//        System.out.println(player03);</span><br><span class="hljs-comment">//        System.out.println(temppoker);</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        4.  看牌：通过Map集合找到对应字符展示。</span><br><span class="hljs-comment">通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</span><br><span class="hljs-comment">         */</span><br>        search(<span class="hljs-string">&quot;周润发&quot;</span>,player01,poker);<br>        search(<span class="hljs-string">&quot;刘德华&quot;</span>,player02,poker);<br>        search(<span class="hljs-string">&quot;古天乐&quot;</span>,player03,poker);<br>        search(<span class="hljs-string">&quot;底牌&quot;</span>,temppoker,poker);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(String name,ArrayList list,Map poker)</span> </span>&#123;<br>        List&lt;Object&gt; listed = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Object o : list) &#123;<br>            Object o1 = poker.get(o);<br>            listed.add(o1);<br>        &#125;<br>        System.out.print(name+<span class="hljs-string">&quot;:&quot;</span>);<br>        Iterator&lt;Object&gt; it = listed.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object next = it.next();<br>            System.out.print(next+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br>输出：<br>周润发:大王 ♦<span class="hljs-number">2</span> ♠<span class="hljs-number">2</span> ♠K ♣Q ♠Q ♣<span class="hljs-number">9</span> ♥<span class="hljs-number">8</span> ♠<span class="hljs-number">8</span> ♣<span class="hljs-number">7</span> ♥<span class="hljs-number">7</span> ♦<span class="hljs-number">6</span> ♥<span class="hljs-number">6</span> ♠<span class="hljs-number">6</span> ♠<span class="hljs-number">5</span> ♣<span class="hljs-number">4</span> ♥<span class="hljs-number">4</span> ♠<span class="hljs-number">4</span> <br>刘德华:♥<span class="hljs-number">2</span> ♣A ♠A ♦K ♣K ♣J ♥J ♠J ♦<span class="hljs-number">10</span> ♥<span class="hljs-number">10</span> ♠<span class="hljs-number">10</span> ♦<span class="hljs-number">9</span> ♥<span class="hljs-number">9</span> ♠<span class="hljs-number">9</span> ♣<span class="hljs-number">6</span> ♣<span class="hljs-number">5</span> ♥<span class="hljs-number">5</span> ♥<span class="hljs-number">3</span> <br>古天乐:小王 ♣<span class="hljs-number">2</span> ♦A ♥A ♥K ♦Q ♥Q ♦J ♣<span class="hljs-number">10</span> ♦<span class="hljs-number">8</span> ♣<span class="hljs-number">8</span> ♦<span class="hljs-number">7</span> ♠<span class="hljs-number">7</span> ♦<span class="hljs-number">5</span> ♦<span class="hljs-number">4</span> ♦<span class="hljs-number">3</span> ♣<span class="hljs-number">3</span> ♠<span class="hljs-number">3</span> <br>底牌:♠<span class="hljs-number">2</span> ♥Q ♥<span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure>
<h3 id="Charter10-多线程"><a href="#Charter10-多线程" class="headerlink" title="Charter10.多线程"></a>Charter10.多线程</h3><h4 id="10-1-并发与并行"><a href="#10-1-并发与并行" class="headerlink" title="10.1 并发与并行"></a>10.1 并发与并行</h4><ul>
<li><p><strong>并发</strong>:指两个或多个事件在同一个时间段内发生;</p>
</li>
<li><p><strong>并行</strong>:指两个或多个事件在同一个时间点发生;</p>
</li>
</ul>
<h4 id="10-2-线程与进程"><a href="#10-2-线程与进程" class="headerlink" title="10.2 线程与进程"></a>10.2 线程与进程</h4><ul>
<li><p><strong>进程</strong>:是指一个内存中运行的应用程序,一个应用程序可以同时进行多个进程,进程是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建,运行到消亡的过程;</p>
</li>
<li><p><strong>线程</strong>:是进程中的一个执行单元,负责当前进程中程序的执行;一个进程中可以有单线程或者多线程;</p>
</li>
<li><p><strong>线程调度</strong>:</p>
<p>(1)分时调度:所有线程轮流获得CPU的使用权,平均分配每个线程占用CPU的时间;</p>
<p>(2)抢占调度:优先让优先级高的线程使用CPU,如果线程的优先级相同,那么会随机选择一个使用CPU;<strong>Java就是使用抢占调度的方式</strong></p>
</li>
</ul>
<h4 id="10-3-线程类"><a href="#10-3-线程类" class="headerlink" title="10.3 线程类"></a>10.3 线程类</h4><p><code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TestThread thread = <span class="hljs-keyword">new</span> TestThread();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+<span class="hljs-string">&quot;This is my thread!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常用API:</strong></p>
<ul>
<li><p><code>public Thread</code>:分配一个新线程对象。</p>
</li>
<li><p><code>public Thread(String name) </code>:分配一个指定名字的新的线程对象。</p>
</li>
<li><p><code>public Thread(Runnable target) </code>:分配一个带有指定目标新的线程对象</p>
</li>
<li><p><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。 </p>
</li>
<li><p><code>public String getName() </code>:获取当前线程名称。 </p>
</li>
<li><p><code>public void start() </code>:导致此线程开始执行; Java虚拟机调用此线程的run方法</p>
</li>
<li><p><code>public void run() </code>:此线程要执行的任务在此处定义代码。 </p>
</li>
<li><p><code>public static void sleep(long millis) </code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。//需要用try-catch语句可能抛出printStackTrace异常</p>
</li>
<li><p><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p>
</li>
</ul>
<h4 id="10-4-Runnable接口"><a href="#10-4-Runnable接口" class="headerlink" title="10.4 Runnable接口"></a>10.4 Runnable接口</h4><ul>
<li><p>通过实现Runnable接口来开启多线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	1.定义Runnable接口的实现类,重写run()方法;</span><br><span class="hljs-comment">	2.创建Runnable实现类的实例对象,并以此实例对象作为Thread的参数来创建Thread对象</span><br><span class="hljs-comment">	3.启用Thread对象的start()方法来开启多线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>       thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;这是第&quot;</span>+i+<span class="hljs-string">&quot;次输出&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过实现Runnable接口开启多线程的优势:</p>
<p>1.可以避免java单继承的局限性(继承了Thread就不能继承其他类)</p>
<p>2.使代码可以被多个线程共享,实现代码和线程独立</p>
<p>3.线程池只能放入实现Runnable或Callable类线程,不能直接放入继承Thread的类</p>
</li>
</ul>
<h4 id="10-5-通过匿名内部类实现创建线程"><a href="#10-5-通过匿名内部类实现创建线程" class="headerlink" title="10.5 通过匿名内部类实现创建线程"></a>10.5 通过匿名内部类实现创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;这是匿名内部类创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       Thread thread = <span class="hljs-keyword">new</span> Thread(run);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是main方法创建的线程&quot;</span>+<span class="hljs-string">&quot;--&gt;&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="10-6-引出线程安全问题"><a href="#10-6-引出线程安全问题" class="headerlink" title="10.6 引出线程安全问题"></a>10.6 引出线程安全问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    引出问题:在电影票卖票有多个售票窗口卖票,且这多个售票窗口共享需要兜售的票资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnableimple();<br>        Thread thread01 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread02 = <span class="hljs-keyword">new</span> Thread(run);<br>        Thread thread03 = <span class="hljs-keyword">new</span> Thread(run);<br>        thread01.start();<br>        thread02.start();<br>        thread03.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">20</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">18</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">19</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">17</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">16</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">15</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">14</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">13</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">12</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">11</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">10</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">9</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">8</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">7</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">6</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">5</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">4</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">3</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第<span class="hljs-number">2</span>张票<br>Thread-<span class="hljs-number">2</span>正在卖第<span class="hljs-number">1</span>张票<br>Thread-<span class="hljs-number">0</span>正在卖第<span class="hljs-number">0</span>张票<br>Thread-<span class="hljs-number">1</span>正在卖第-<span class="hljs-number">1</span>张票<br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p> 在这里出现了卖重复的票和卖0/-1这种不存在的票，几个线程共享使用数据导致票数不同步，这种问题称为线程不安全。</p>
<h4 id="10-7-线程同步"><a href="#10-7-线程同步" class="headerlink" title="10.7 线程同步"></a>10.7 线程同步</h4><p>为了解决线程安全问题，Java中提供了同步机制(synchronized)来解决;</p>
<h5 id="10-7-1-同步代码块"><a href="#10-7-1-同步代码块" class="headerlink" title="10.7.1 同步代码块"></a>10.7.1 同步代码块</h5><ul>
<li><code>synchronized</code>关键字可以用于方法的某个区块中,表示对这个区块的资源实行互斥访问;</li>
</ul>
<p>创建格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>同步锁:可以是任意类型(Object)的对象,注意多个线程对象要使用同一把同步锁;在开启多线程时，仅允许一个线程拿到同步锁，谁拿到同步锁即获得CPU的使用权,其他的线程得等该线程完成代码块释放锁后拿到锁才能执行;</li>
</ul>
<p>针对上面线程安全问题的优化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="10-7-2-同步方法"><a href="#10-7-2-同步方法" class="headerlink" title="10.7.2 同步方法"></a>10.7.2 同步方法</h5><ul>
<li>可以使用<code>synchronized</code>修饰方法使方法成为同步方法;</li>
</ul>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> methodName&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure>
<p>针对上面线程安全问题的优化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                 System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>同步方法本质也使用了同步锁,对于非静态方法,同步锁就是this;对于静态方法,同步锁就是当前方法所在类的字节码对象(类名.class)</li>
</ul>
<h5 id="10-7-3-Lock锁"><a href="#10-7-3-Lock锁" class="headerlink" title="10.7.3 Lock锁"></a>10.7.3 Lock锁</h5><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁操作;优化了加锁和释放锁的方式;</p>
<ul>
<li><code>public void lock();</code>加同步锁;</li>
<li><code>public void unlock();</code>释放同步锁;</li>
</ul>
<p><code>ReentrantLock</code>是一个互斥锁，也是一个<strong>可重入锁</strong>（Reentrant就是再次进入的意思）。<code>ReentrantLock</code>锁在同一个时间点只能被一个线程锁持有，但是它可以被单个线程多次获取，每获取一次<code>AQS</code>的<code>state</code>就加1，每释放一次<code>state</code>就减1。</p>
<p>针对上面线程安全问题的优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnableimple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">20</span>;<br>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>注意如果使用try-catch代码块,一定要把unlock()过程放到finally里,防止程序抛出了异常而一直不释放锁;</li>
</ul>
<h4 id="10-8-线程状态"><a href="#10-8-线程状态" class="headerlink" title="10.8 线程状态"></a>10.8 线程状态</h4><p>在线程的生命周期中,会呈现不同的线程状态;</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New</td>
<td>线程刚被创建，但还并未启动，还没调用start方法</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程在JVM中运行的状态</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个同步锁，而该锁已被其他对象占有，则该线程进入Blocked状态;等该线程获取到锁时，转变为Runnable状态;</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行唤醒动作时,该线程进入Waiting状态.进入该状态不能主动唤醒,必须等待另一个线程调用notify方法;（当我们调用Thread.sleep(time);方法时,线程进入睡眠状态也就是TimedWaiting状态，等待时间到后自动唤醒;或者使用带参数的wait方法也可;）</td>
</tr>
<tr>
<td>TimedWaiting(计时等待)</td>
<td>类似于waiting状态,但是传入了一个参数,在一直没有另一个线程唤醒时,到了超时参数后会自动唤醒;</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出或者是因为没有捕获的异常终止了run方法而导致线程被终止</td>
</tr>
</tbody></table>
<h4 id="10-9-等待唤醒机制"><a href="#10-9-等待唤醒机制" class="headerlink" title="10.9 等待唤醒机制"></a>10.9 等待唤醒机制</h4><ul>
<li><p>常用方法:</p>
<p><code>Object.wait()</code>:使线程不再执行操作,进入waitset,等待notify使其回到readyset;</p>
<p><code>Object.notify()</code>:使所选取对象的一个线程释放;</p>
<p><code>Object.notifyAll()</code>:使所选取对象的所有线程释放;</p>
</li>
</ul>
<p>包子铺卖包子问题代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    包子铺卖包子问题:</span><br><span class="hljs-comment">        1.创建包子类,内有包子的皮和馅料实例,还有包子的状态(有或无);</span><br><span class="hljs-comment">        2.创建包子铺类,当包子的状态为无时就被唤醒做包子,做完后将包子状态改为有,唤醒买家;当包子的状态为有时就休眠;</span><br><span class="hljs-comment">        3.创建买家类,当包子的状态为有时就被唤醒买包子吃,吃完后将包子状态改为无,唤醒包子铺;当包子的状态为无时就休眠;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br>        BaoZiPu baoZiPu = <span class="hljs-keyword">new</span> BaoZiPu(bz);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(bz);<br>        Thread baoziputhread = <span class="hljs-keyword">new</span> Thread(baoZiPu);<br>        Thread consumerthread = <span class="hljs-keyword">new</span> Thread(consumer);<br>        baoziputhread.start();<br>        consumerthread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZi</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String pi;<br>    <span class="hljs-keyword">public</span> String xian;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> state = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaoZiPu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.bz = bz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaoZiPu</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        bz.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;店家正在做包子,请等待!&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;薄皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;肉&quot;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (flag % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                        bz.pi = <span class="hljs-string">&quot;厚皮&quot;</span>;<br>                        bz.xian = <span class="hljs-string">&quot;韭菜&quot;</span>;<br>                    &#125;<br>                    flag++;<br>                    bz.state = <span class="hljs-keyword">true</span>;<br>                    bz.notify();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        BaoZi bz = <span class="hljs-keyword">new</span> BaoZi();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BaoZi bz)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bz = bz;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (bz) &#123;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">true</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;我买了这个&quot;</span> + bz.pi + bz.xian + <span class="hljs-string">&quot;包子,一秒钟吃完!&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">1000</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        bz.state = <span class="hljs-keyword">false</span>;<br>                        System.out.println(<span class="hljs-string">&quot;吃完了,针不戳!&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;------------------------&quot;</span>);<br>                        bz.notify();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (bz.state == <span class="hljs-keyword">false</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            bz.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个厚皮韭菜包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>店家正在做包子,请等待!<br>我买了这个薄皮肉包子,一秒钟吃完!<br>吃完了,针不戳!<br>------------------------<br>......<br></code></pre></td></tr></table></figure>
<h4 id="10-10-线程池"><a href="#10-10-线程池" class="headerlink" title="10.10 线程池"></a>10.10 线程池</h4><ul>
<li><strong>概念：</strong>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li>
</ul>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
